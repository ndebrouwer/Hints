type BlueprintProps = {
    id?: string;
    title: string;
    description?: string;
    slug?: string;
    tags?: string[];
    emailQuery?: string;
    circuitName: string;
    ignoreBodyHashCheck?: boolean;
    shaPrecomputeSelector?: string;
    emailBodyMaxLength?: number;
    emailHeaderMaxLength?: number;
    removeSoftLinebreaks?: boolean;
    githubUsername?: string;
    senderDomain?: string;
    enableHeaderMasking?: boolean;
    enableBodyMasking?: boolean;
    zkFramework?: ZkFramework;
    isPublic?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    externalInputs?: ExternalInput[];
    decomposedRegexes: DecomposedRegex[];
    status?: Status;
    verifierContract?: VerifierContract;
    version?: number;
    stars?: number;
};
type DecomposedRegex = {
    parts: DecomposedRegexPart[];
    name: string;
    maxLength: number;
    location: "body" | "header";
};
type DecomposedRegexPart = {
    isPublic: boolean;
    regexDef: string;
};
type DecomposedRegexJson = {
    parts: DecomposedRegexPartJson[];
    name: string;
    max_length: number;
    location: "body" | "header";
};
type DecomposedRegexPartJson = {
    is_public: boolean;
    regex_def: string;
};
type ExternalInput = {
    name: string;
    maxLength: number;
};
declare enum ZkFramework {
    Circom = "circom"
}
declare enum Status {
    None = 0,
    Draft = 1,
    InProgress = 2,
    Done = 3,
    Failed = 4
}
type VerifierContract = {
    address?: string;
    chain: number;
};
type BlueprintRequest = {
    id?: string;
    title: string;
    description?: string;
    slug?: string;
    tags?: string[];
    email_query?: string;
    circuit_name?: string;
    ignore_body_hash_check?: boolean;
    sha_precompute_selector?: string;
    email_body_max_length?: number;
    email_header_max_length?: number;
    remove_soft_linebreaks?: boolean;
    github_username?: string;
    sender_domain?: string;
    enable_header_masking?: boolean;
    enable_body_masking?: boolean;
    zk_framework?: string;
    is_public?: boolean;
    external_inputs?: ExternalInputResponse[];
    decomposed_regexes: DecomposedRegexResponse[];
    status?: string;
    verifier_contract_address?: string;
    verifier_contract_chain?: number;
    version?: number;
};
type BlueprintResponse = {
    id: string;
    title: string;
    description: string;
    slug: string;
    tags: string[];
    email_query: string;
    circuit_name: string;
    ignore_body_hash_check: boolean;
    sha_precompute_selector: string;
    email_body_max_length: number;
    email_header_max_length?: number;
    remove_soft_linebreaks?: boolean;
    github_username?: string;
    sender_domain: string;
    enable_header_masking?: boolean;
    enable_body_masking?: boolean;
    zk_framework: string;
    is_public: boolean;
    created_at: ServerDate;
    updated_at: ServerDate;
    external_inputs: ExternalInputResponse[];
    decomposed_regexes: DecomposedRegexResponse[];
    status: number;
    verifier_contract_address: string;
    verifier_contract_chain: number;
    version: number;
    stars: number;
};
type ServerDate = {
    seconds: number;
    nanos: number;
};
type ExternalInputResponse = {
    name: string;
    max_length: number;
};
type DecomposedRegexResponse = {
    parts: DecomposedRegexPartResponse[];
    name: string;
    max_length: number;
    location: "body" | "header";
};
type DecomposedRegexPartResponse = {
    is_public: boolean;
    regex_def: string;
};
type ListBlueprintsOptions = {
    skip?: number;
    limit?: number;
    sort?: -1 | 1;
    sortBy?: "updatedAt" | "stars";
    status?: Status[];
    isPublic?: boolean;
    search?: string;
};
type ListBlueprintsOptionsRequest = {
    skip?: number;
    limit?: number;
    sort?: -1 | 1;
    sortBy?: "updated_at" | "stars";
    status?: Status[];
    is_public?: boolean;
    search?: string;
};
type DownloadUrls = Record<string, string>;

declare enum ProofStatus {
    None = 0,
    InProgress = 1,
    Done = 2,
    Failed = 3
}
type ProofProps = {
    id: string;
    blueprintId: string;
    input: string;
    proofData?: string;
    publicData?: string;
    publicOutputs?: string[];
    externalInputs?: string;
    status?: ProofStatus;
    startedAt?: Date;
    provedAt?: Date;
};
type ProofResponse = {
    id: string;
    blueprint_id: string;
    input: string;
    proof?: string;
    public?: string;
    external_inputs?: string;
    public_outputs?: string[];
    started_at: ServerDate;
    proved_at?: ServerDate;
    status: number;
};
type ProofRequest = {
    blueprint_id: string;
    input: any;
    external_inputs: any;
};
type GenerateProofInputsParams = {
    emailHeaderMaxLength: number;
    emailBodyMaxLength: number;
    ignoreBodyHashCheck: boolean;
    removeSoftLinebreaks: boolean;
    shaPrecomputeSelector?: string;
};
type GenerateProofInputsParamsInternal = {
    maxHeaderLength: number;
    maxBodyLength: number;
    ignoreBodyHashCheck: boolean;
    removeSoftLinesBreaks: boolean;
    shaPrecomputeSelector?: string;
};
type ProofData = {
    pi_a: [string, string, string];
    pi_b: [[string, string], [string, string], [string, string]];
    pi_c: [string, string, string];
    protocol: string;
};

/**
 * A generated proof. You get get proof data and verify proofs on chain.
 */
declare class Proof {
    blueprint: Blueprint;
    props: ProofProps;
    private lastCheckedStatus;
    constructor(blueprint: Blueprint, props: ProofProps);
    getId(): string;
    /**
     * Returns a download link for the files of the proof.
     * @returns The the url to download a zip of the proof files.
     */
    getProofDataDownloadLink(): Promise<string>;
    startFilesDownload(): Promise<void>;
    /**
     * Checks the status of proof.
     * checkStatus can be used in a while(await checkStatus()) loop, since it will wait a fixed
     * amount of time before the second time you call it.
     * @returns A promise with the Status.
     */
    checkStatus(): Promise<ProofStatus>;
    waitForCompletion(): Promise<ProofStatus>;
    /**
     * Verifies the proof on chain using the verifier contract defined in the blueprint.
     * Will throw an error if it cannot verify the proof. If the function call succeeds,
     * the proof was validated.
     */
    verifyOnChain(): Promise<void>;
    /**
     * Generates call data for the proof that can be used to verify the proof on chain.
     */
    createCallData(): Promise<(bigint[] | bigint[][])[]>;
    /**
     * Fetches an existing Proof from the database.
     * @param id - Id of the Proof.
     * @returns A promise that resolves to a new instance of Proof.
     */
    static getProofById(id: string, baseUrl: string): Promise<Proof>;
    static responseToProofProps(response: ProofResponse): ProofProps;
    /**
     * @returns The public data and proof data.
     */
    getProofData(): {
        proofData: string;
        publicData: string;
        publicOutputs: string[];
        externalInputs: string;
    };
}

type ProverOptions = {
    isLocal: boolean;
};
type ExternalInputInput = {
    name: string;
    value: string;
    maxLength: number;
};

/**
 * Represents a Prover generated from a blueprint that can generate Proofs
 */
declare class Prover {
    options: ProverOptions;
    blueprint: Blueprint;
    constructor(blueprint: Blueprint, options?: ProverOptions);
    /**
     * Generates a proof for a given email.
     * @param eml - Email to prove agains the blueprint of this Prover.
     * @returns A promise that resolves to a new instance of Proof. The Proof will have the status
     * Done or Failed.
     */
    generateProof(eml: string, externalInputs?: ExternalInputInput[]): Promise<Proof>;
    /**
     * Starts proving for a given email.
     * @param eml - Email to prove agains the blueprint of this Prover.
     * @returns A promise that resolves to a new instance of Proof. The Proof will have the status
     * InProgress.
     */
    generateProofRequest(eml: string, externalInputs?: ExternalInputInput[]): Promise<Proof>;
}

/**
 * Interface for authentication for creating and updating blueprints
 */
type Auth = {
    /**
     * Retrieves the authentication token
     * e.g. from a req for next.js or the localstorage for frontend
     * @returns Promise that resolves to the token string or null if no token exists
     */
    getToken: () => Promise<string | null>;
    /**
     * Callback triggered when the authentication token expires
     * @returns Promise that resolves when expired token is handled
     */
    onTokenExpired: () => Promise<void>;
};

/**
 * Represents a Regex Blueprint including the decomposed regex access to the circuit.
 */
declare class Blueprint {
    props: BlueprintProps;
    auth?: Auth;
    baseUrl: string;
    stars: number;
    private lastCheckedStatus;
    constructor(props: BlueprintProps, baseUrl: string, auth?: Auth);
    addAuth(auth: Auth): void;
    /**
     * Fetches an existing RegexBlueprint from the database.
     * @param {string} id - Id of the RegexBlueprint.
     * @returns A promise that resolves to a new instance of RegexBlueprint.
     */
    static getBlueprintById(id: string, baseUrl: string, auth?: Auth): Promise<Blueprint>;
    /**
     * Fetches an existing RegexBlueprint by slug from the database.
     * @param slug - Slug of the blueprint. Must include version, e.g. "slug:v1"
     * @param version - Version of the slug.
     * @returns A promise that resolves to a new instance of RegexBlueprint.
     */
    static getBlueprintBySlug(slug: string, baseUrl: string, auth?: Auth): Promise<Blueprint>;
    private static responseToBlueprintProps;
    private static blueprintPropsToRequest;
    /**
     * Submits a new RegexBlueprint to the registry as draft.
     * This does not compile the circuits yet and you will still be able to make changes.
     * @returns A promise. Once it resolves, `getId` can be called.
     */
    submitDraft(): Promise<void>;
    /**
     * Submits a new version of the RegexBlueprint to the registry as draft.
     * This does not compile the circuits yet and you will still be able to make changes.
     * @param newProps - The updated blueprint props.
     * @returns A promise. Once it resolves, the current Blueprint will be replaced with the new one.
     */
    submitNewVersionDraft(newProps: BlueprintProps): Promise<void>;
    /**
     * Submits a new version of the blueprint. This will save the new blueprint version
     * and start the compilation.
     * This will also overwrite the current Blueprint with its new version, even if the last
     * version was not compiled yet.
     * @param newProps - The updated blueprint props.
     */
    submitNewVersion(newProps: BlueprintProps): Promise<void>;
    /**
     * Lists blueblueprints, only including the latest version per unique slug.
     * @param options - Options to filter the blueprints by.
     * @returns A promise. Once it resolves, `getId` can be called.
     */
    static listBlueprints(baseUrl: string, options?: ListBlueprintsOptions, auth?: Auth): Promise<Blueprint[]>;
    /**
     * Submits a blueprint. This will save the blueprint if it didn't exist before
     * and start the compilation.
     */
    submit(): Promise<void>;
    private _checkStatus;
    /**
     * Checks the status of blueprint.
     * checkStatus can be used in a while(await checkStatus()) loop, since it will wait a fixed
     * amount of time the second time you call it.
     * @returns A promise with the Status.
     */
    checkStatus(): Promise<Status>;
    /**
     * Get the id of the blueprint.
     * @returns The id of the blueprint. If it was not saved yet, return null.
     */
    getId(): string | null;
    /**
     * Returns a download link for the ZKeys of the blueprint.
     * @returns The the url to download the ZKeys.
     */
    getZKeyDownloadLink(): Promise<DownloadUrls>;
    /**
     * Directly starts a download of the ZKeys in the browser.
     * Must be called within a user action, like a button click.
     */
    startZKeyDownload(): Promise<void>;
    /**
     * Creates an instance of Prover with which you can create proofs.
     * @returns An instance of Prover.
     */
    createProver(): Prover;
    /**
     * Verifies a proof on chain.
     * @param proof - The generated proof you want to verify.
     * @returns A true if the verification was successfull, false if it failed.
     */
    verifyProofOnChain(proof: Proof): Promise<boolean>;
    /**
     * Returns a deep cloned version of the Blueprints props.
     * This can be used to update properties and then to use them with createNewVersion.
     * @param proof - The generated proof you want to verify.
     * @returns A true if the verification was successfull, false if it failed.
     */
    getClonedProps(): BlueprintProps;
    /**
     * Returns true if the blueprint can be updated. A blueprint can be updated if the circuits
     * haven't beed compiled yet, i.e. the status is not Done. The blueprint also must be saved
     * already before it can be updated.
     * @returns true if it can be updated
     */
    canUpdate(): boolean;
    /**
     * Updates an existing blueprint that is not compiled yet.
     * @param newProps - The props the blueprint should be updated to.
     * @returns a promise.
     */
    update(newProps: BlueprintProps): Promise<void>;
    listAllVersions(): Promise<Blueprint[]>;
    addStar(): Promise<number>;
    removeStar(): Promise<number>;
    getStars(): Promise<number>;
    cancelCompilation(): Promise<void>;
    delete(): Promise<void>;
}

type SdkOptions = {
    auth?: Auth;
    baseUrl?: string;
};

type ParsedEmail = {
    canonicalizedHeader: string;
    canonicalizedBody: string;
    signature: number[];
    publicKey: any[];
    cleanedBody: string;
    headers: Map<string, string[]>;
};

declare function startJsonFileDownload(json: string, name?: string): void;

declare function parseEmail(eml: string): Promise<ParsedEmail>;
declare function testBlueprint(eml: string, blueprint: BlueprintProps, revealPrivate?: boolean): Promise<string[][]>;
declare function testDecomposedRegex(body: string, header: string, decomposedRegex: DecomposedRegex | DecomposedRegexJson, revealPrivate?: boolean): Promise<string[]>;
declare function generateProofInputs(eml: string, decomposedRegexes: DecomposedRegex[], externalInputs: ExternalInputInput[], params: GenerateProofInputsParams): Promise<string>;

declare function getLoginWithGithubUrl(callbackUrl: string, githubClientId?: string): string;

declare const _default: (sdkOptions?: SdkOptions) => {
    createBlueprint(props: BlueprintProps): Blueprint;
    getBlueprint(slug: string): Promise<Blueprint>;
    getBlueprintById(id: string): Promise<Blueprint>;
    listBlueprints(options?: ListBlueprintsOptions): Promise<Blueprint[]>;
    getProof(id: string): Promise<Proof>;
    getStarredBlueprints(): Promise<string[]>;
};

export { type Auth, Blueprint, type BlueprintProps, type BlueprintRequest, type BlueprintResponse, type DecomposedRegex, type DecomposedRegexJson, type DecomposedRegexPart, type DecomposedRegexPartJson, type DecomposedRegexPartResponse, type DecomposedRegexResponse, type DownloadUrls, type ExternalInput, type ExternalInputInput, type ExternalInputResponse, type GenerateProofInputsParams, type GenerateProofInputsParamsInternal, type ListBlueprintsOptions, type ListBlueprintsOptionsRequest, type ParsedEmail, Proof, type ProofData, type ProofProps, type ProofRequest, type ProofResponse, ProofStatus, type ProverOptions, type ServerDate, Status, type VerifierContract, ZkFramework, _default as default, generateProofInputs, getLoginWithGithubUrl, parseEmail, startJsonFileDownload, testBlueprint, testDecomposedRegex };
