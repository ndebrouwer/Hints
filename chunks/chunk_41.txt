    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractEmailDomainIdxes(emailAddr)[0];
    expect("dummy.com").toEqual(emailAddr.slice(prefixIdxes[0], prefixIdxes[1]));
    for (let idx = 0; idx < 256; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });
});



---
File: /@zk-email/zk-regex-circom/tests/from_addr.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
  include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(600000);
describe("From Addr Regex", () => {
  let circuit;
  beforeAll(async () => {
    {
      const email_addr_json = readFileSync(
        path.join(__dirname, "../circuits/common/from_all.json"),
        "utf8"
      );
      const circom = compiler.genFromDecomposed(
        email_addr_json,
        "FromAllRegex"
      );
      writeFileSync(
        path.join(__dirname, "../circuits/common/from_all_regex.circom"),
        circom
      );
    }
    {
      const email_addr_json = readFileSync(
        path.join(__dirname, "../circuits/common/reversed_bracket.json"),
        "utf8"
      );
      const circom = compiler.genFromDecomposed(
        email_addr_json,
        "ReversedBracketRegex"
      );
      writeFileSync(
        path.join(
          __dirname,
          "../circuits/common/reversed_bracket_regex.circom"
        ),
        circom
      );
    }
    {
      const email_addr_json = readFileSync(
        path.join(__dirname, "../circuits/common/email_addr.json"),
        "utf8"
      );
      const circom = compiler.genFromDecomposed(
        email_addr_json,
        "EmailAddrRegex"
      );
      writeFileSync(
        path.join(__dirname, "../circuits/common/email_addr_regex.circom"),
        circom
      );
    }
    circuit = await wasm_tester(
      path.join(__dirname, "./circuits/test_from_addr_regex.circom"),
      option
    );
  });

  it("from field from beginning case 1", async () => {
    const fromStr = "from:suegamisora@gmail.com\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field from beginning case 2", async () => {
    const fromStr = "from:Sora Suegami <suegamisora@gmail.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field from beginning case 3 (email address as a name)", async () => {
    const fromStr = "from:dummy@example.com<suegamisora@gmail.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field from beginning case 4 (non-English string is used as a name)", async () => {
    const fromStr = 'from: "末神奏宙" <suegamisora@gmail.com>\r\n';
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field after new line case 1", async () => {
    const fromStr = "dummy\r\nfrom:suegamisora@gmail.com\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field after new line case 2", async () => {
    const fromStr = "dummy\r\nfrom:Sora Suegami <suegamisora@gmail.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field after new line case 3 (email address as a name)", async () => {
    const fromStr =
      "dummy\r\nfrom:dummy@example.com<suegamisora@gmail.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field after new line case 4 (non-English string is used as a name)", async () => {
    const fromStr = 'dummy\r\nfrom: "末神奏宙" <suegamisora@gmail.com>\r\n';
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field in the invalid field", async () => {
    const fromStr = "\r\nto:from:Sora Suegami <suegamisora@gmail.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    async function failFn() {
      await circuit.calculateWitness(circuitInputs);
    }
    await expect(failFn).rejects.toThrow();
  });

  it('invalid from field with 255', async () => {
    const fromStr = `from:Sora Suegami <suegamisora@gmail.com>\r\n`;
    let paddedStr = apis.padString(fromStr, 1022);
    paddedStr.unshift(49);
    paddedStr.unshift(255);
    const circuitInputs = {
      msg: paddedStr
    };
    async function failFn() {
      const witness = await circuit.calculateWitness(circuitInputs);
      await circuit.checkConstraints(witness);
    }
    await expect(failFn).rejects.toThrow();
  });

  it("from field containing @ in the name part", async () => {
    const fromStr = "from:Sora Suegami <suegamisora@gmail.com@dummy.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    expect("suegamisora@gmail.com@dummy.com").toEqual(fromStr.slice(prefixIdxes[0], prefixIdxes[1]));
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field starting from @", async () => {
    const fromStr = "from:Sora Suegami <@gmail.com@dummy.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    expect("@gmail.com@dummy.com").toEqual(fromStr.slice(prefixIdxes[0], prefixIdxes[1]));
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field with double <> 1", async () => {
    const fromStr = "from:\"Some name <victim@any-domain>\" <attacker@outlook.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    expect("attacker@outlook.com").toEqual(fromStr.slice(prefixIdxes[0], prefixIdxes[1]));
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });


  it("from field with double <> 2", async () => {
    const fromStr = "from:\"Some name <victim@any-domain>\" < attacker@outlook.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    expect(" attacker@outlook.com").toEqual(fromStr.slice(prefixIdxes[0], prefixIdxes[1]));
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });


  it("from field with double <> 3", async () => {
    const fromStr = "from:\"Some name <victim@any-domain>\" <attacker@outlook.com >\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    // console.log((witness[1]));
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    expect("attacker@outlook.com ").toEqual(fromStr.slice(prefixIdxes[0], prefixIdxes[1]));
    for (let idx = 0; idx < 1024; ++idx) {
      // if (witness[2 + idx] !== 0n) {
      //   console.log('idx:', idx, 'witness:', witness[2 + idx]);
      // }
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("from field with triple <>", async () => {
    const fromStr = "from:\"Some name <victim1@any-domain<victim1@any-domain>>\" <attacker@outlook.com>\r\n";
    const paddedStr = apis.padString(fromStr, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractFromAddrIdxes(fromStr)[0];
    expect("attacker@outlook.com").toEqual(fromStr.slice(prefixIdxes[0], prefixIdxes[1]));
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });
});



---
File: /@zk-email/zk-regex-circom/tests/international_chars.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
  include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(300000);
describe("Simple Regex Decomposed", () => {
  let circuit;
  beforeAll(async () => {
    const email_addr_json = readFileSync(
      path.join(__dirname, "./circuits/international_chars_decomposed.json"),
      "utf8"
    );
    const circom = compiler.genFromDecomposed(
      email_addr_json,
      "InternationalCharsDecomposed"
    );
    writeFileSync(
      path.join(__dirname, "./circuits/international_chars_decomposed.circom"),
      circom
    );
    circuit = await wasm_tester(
      path.join(
        __dirname,
        "./circuits/test_international_chars_decomposed.circom"
      ),
      option
    );
  });

  it("case 1", async () => {
    const input =
      "Latin-Extension=Ʃƣƙ Greek=ϕω Cyrillic=иЩ Arabic=أبت Devanagari=आदित्य Hiragana&Katakana=なツ";
    const paddedStr = apis.padString(input, 128);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [
      [16, 17, 18, 19, 20, 21],
      [29, 30, 31, 32],
      [43, 44, 45, 46],
      [55, 56, 57, 58, 59, 60, 61, 62],
      [75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92],
      [112, 113, 114, 115, 116, 117],
    ];
    for (let substr_idx = 0; substr_idx < 6; ++substr_idx) {
      for (let idx = 0; idx < 128; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 128 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 128 * substr_idx + idx]);
        }
      }
    }
  });
});



---
File: /@zk-email/zk-regex-circom/tests/invitation_code.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
    include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(300000);
describe("Invitation Code Decomposed (taken from ether-email-auth)", () => {
    let circuit;
    beforeAll(async () => {
        const email_addr_json = readFileSync(
            path.join(__dirname, "./circuits/invitation_code_with_prefix.json"),
            "utf8"
        );
        const circom = compiler.genFromDecomposed(
            email_addr_json,
            "InvitationCodeWithPrefixRegex"
        );
        writeFileSync(
            path.join(__dirname, "./circuits/invitation_code_with_prefix_regex.circom"),
            circom
        );
        circuit = await wasm_tester(
            path.join(
                __dirname,
                "./circuits/test_invitation_code_with_prefix_regex.circom"
            ),
            option
        );
    });

    it("case 1", async () => {
        const input =
            "Re: Accept guardian request for 0x04884491560f38342C56E26BDD0fEAbb68E2d2FC Code 01eb9b204cc24c3baee11accc37d253a9c53e92b1a2cc07763475c135d575b76";
        const paddedStr = apis.padString(input, 256);
        const circuitInputs = {
            msg: paddedStr,
        };
        const witness = await circuit.calculateWitness(circuitInputs);
        await circuit.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const revealedIdx = [
            [74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143],
        ];
        for (let substr_idx = 0; substr_idx < 1; ++substr_idx) {
            for (let idx = 0; idx < 256; ++idx) {
                if (revealedIdx[substr_idx].includes(idx)) {
                    expect(BigInt(paddedStr[idx])).toEqual(
                        witness[2 + 256 * substr_idx + idx]
                    );
                } else {
                    expect(0n).toEqual(witness[2 + 256 * substr_idx + idx]);
                }
            }
        }
    });
});



---
File: /@zk-email/zk-regex-circom/tests/message_id_regex.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
  include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(120000);
describe("Message Id Regex", () => {
  let circuit;
  beforeAll(async () => {
    const email_addr_json = readFileSync(
      path.join(__dirname, "../circuits/common/message_id.json"),
      "utf8"
    );
    const circom = compiler.genFromDecomposed(
      email_addr_json,
      "MessageIdRegex"
    );
    writeFileSync(
      path.join(__dirname, "../circuits/common/message_id_regex.circom"),
      circom
    );
    circuit = await wasm_tester(
      path.join(__dirname, "./circuits/test_message_id_regex.circom"),
      option
    );
  });

  it("message id from beginning", async () => {
    const messageIdStr = `message-id:<CAJ7Y6jdOGRFj4RbA=JU034DwHUnRapUZzqLN4hGkG3ou23dFbw@mail.gmail.com>\r\n`;
    const paddedStr = apis.padString(messageIdStr, 256);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractMessageIdIdxes(messageIdStr)[0];
    for (let idx = 0; idx < 256; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("message id after new line", async () => {
    const messageIdStr =
      "dummy\r\nmessage-id:<CAJ7Y6jdOGRFj4RbA=JU034DwHUnRapUZzqLN4hGkG3ou23dFbw@mail.gmail.com>\r\n";
    const paddedStr = apis.padString(messageIdStr, 256);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractMessageIdIdxes(messageIdStr)[0];
    for (let idx = 0; idx < 256; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("invalid message id", async () => {
    const messageIdStr = `to:message-id:<CAJ7Y6jdOGRFj4RbA=JU034DwHUnRapUZzqLN4hGkG3ou23dFbw@mail.gmail.com>\r\n`;
    const paddedStr = apis.padString(messageIdStr, 256);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(0n).toEqual(witness[1]);
    for (let idx = 0; idx < 256; ++idx) {
      expect(0n).toEqual(witness[2 + idx]);
    }
  });
});



---
File: /@zk-email/zk-regex-circom/tests/negate_regex.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
  include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(120000);
describe("Negate Regex", () => {
  let circuit1;
  let circuit2;
  beforeAll(async () => {
    writeFileSync(
      path.join(__dirname, "./circuits/negate1_regex.circom"),
      compiler.genFromDecomposed(
        readFileSync(
          path.join(__dirname, "./circuits/negate1.json"),
          "utf8"
        ),
        "Negate1Regex"
      )
    );
    circuit1 = await wasm_tester(
      path.join(__dirname, "./circuits/test_negate1_regex.circom"),
      option
    );
    writeFileSync(
      path.join(__dirname, "./circuits/negate2_regex.circom"),
      compiler.genFromDecomposed(
        readFileSync(
          path.join(__dirname, "./circuits/negate2.json"),
          "utf8"
        ),
        "Negate2Regex"
      )
    );
    circuit2 = await wasm_tester(
      path.join(__dirname, "./circuits/test_negate2_regex.circom"),
      option
    );
  });

  it("case 1 with regex 1", async () => {
    const input = "a: ABCDEFG XYZ.";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit1.calculateWitness(circuitInputs);
    await circuit1.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]];
    for (let substr_idx = 0; substr_idx < 1; ++substr_idx) {
      for (let idx = 0; idx < 64; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 64 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 64 * substr_idx + idx]);
        }
      }
    }
  });

  it("case 2 with regex 1", async () => {
    const input = "a: CRIPTOGRAFíA.";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit1.calculateWitness(circuitInputs);
    await circuit1.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]];
    for (let substr_idx = 0; substr_idx < 1; ++substr_idx) {
      for (let idx = 0; idx < 64; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 64 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 64 * substr_idx + idx]);
        }
      }
    }
  });

  it("case 3 with regex 1", async () => {
    const input = "a: あいう.";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit1.calculateWitness(circuitInputs);
    await circuit1.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]];
    for (let substr_idx = 0; substr_idx < 1; ++substr_idx) {
      for (let idx = 0; idx < 64; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 64 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 64 * substr_idx + idx]);
        }
      }
    }
  });

  it("case 4 with regex 1", async () => {
    const input = "a: التشفير.";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit1.calculateWitness(circuitInputs);
    await circuit1.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]];
    for (let substr_idx = 0; substr_idx < 1; ++substr_idx) {
      for (let idx = 0; idx < 64; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 64 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 64 * substr_idx + idx]);
        }
      }
    }
  });

  it("case 1 with regex 2", async () => {
    const input = "abdefia";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit2.calculateWitness(circuitInputs);
    await circuit2.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx =  [2,3,4,5];
    for (let idx = 0; idx < 64; ++idx) {
      if (revealedIdx.includes(idx)) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2  + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("invalid case 1 with regex 2", async () => {
    const input = "a";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit2.calculateWitness(circuitInputs);
    await circuit2.checkConstraints(witness);
    expect(0n).toEqual(witness[1]);
    for (let idx = 0; idx < 64; ++idx) {
      expect(0n).toEqual(witness[2 + idx]);
    }
  });
});



---
File: /@zk-email/zk-regex-circom/tests/plus.test.js
---

import circom_tester from 'circom_tester';
import * as path from 'path';
import { readFileSync, writeFileSync } from 'fs';
import apis from '../../apis/pkg';
import compiler from '../../compiler/pkg';
const option = {
    include: path.join(__dirname, '../../../node_modules')
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(600000);
describe('Plus Regex', () => {
    let circuit1;
    let circuit2;
    let circuit3;
    let circuit4;
    // let circuit5;
    // let circuit6;
    beforeAll(async () => {
        writeFileSync(
            path.join(__dirname, './circuits/plus1_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/plus1.json'),
                    'utf8'
                ),
                'Plus1Regex'
            )
        );
        circuit1 = await wasm_tester(
            path.join(__dirname, './circuits/test_plus1_regex.circom'),
            option
        );

        writeFileSync(
            path.join(__dirname, './circuits/plus2_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/plus2.json'),
                    'utf8'
                ),
                'Plus2Regex'
            )
        );
        circuit2 = await wasm_tester(
            path.join(__dirname, './circuits/test_plus2_regex.circom'),
            option
        );

        writeFileSync(
            path.join(__dirname, './circuits/plus3_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/plus3.json'),
                    'utf8'
                ),
                'Plus3Regex'
            )
        );
        circuit3 = await wasm_tester(
            path.join(__dirname, './circuits/test_plus3_regex.circom'),
            option
        );

        writeFileSync(
            path.join(__dirname, './circuits/plus4_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/plus4.json'),
                    'utf8'
                ),
                'Plus4Regex'
            )
        );
        circuit4 = await wasm_tester(
            path.join(__dirname, './circuits/test_plus4_regex.circom'),
            option
        );

        // writeFileSync(
        //     path.join(__dirname, "./circuits/plus5_regex.circom"),
        //     compiler.genFromDecomposed(
        //         readFileSync(
        //             path.join(__dirname, "./circuits/plus5.json"),
        //             "utf8"
        //         ),
        //         "Plus5Regex"
        //     )
        // );
        // circuit5 = await wasm_tester(
        //     path.join(__dirname, "./circuits/test_plus5_regex.circom"),
        //     option
        // );

        // writeFileSync(
        //     path.join(__dirname, "./circuits/plus6_regex.circom"),
        //     compiler.genFromDecomposed(
        //         readFileSync(
        //             path.join(__dirname, "./circuits/plus6.json"),
        //             "utf8"
        //         ),
        //         "Plus6Regex"
        //     )
        // );
        // circuit6 = await wasm_tester(
        //     path.join(__dirname, "./circuits/test_plus6_regex.circom"),
        //     option
        // );
    });

    it('plus1 valid case 1', async () => {
        const inputStr = `ab`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus1.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus1 valid case 2', async () => {
        const inputStr = `aaaab`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus1.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus1 valid case 3', async () => {
        const inputStr = `7aab89ac`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus1.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus1 invalid case 1', async () => {
        const inputStr = `b`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('plus1 invalid case 2', async () => {
        const inputStr = `aacaadae`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('plus1 invalid case 3', async () => {
        const inputStr = `aaaaaaaa`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('plus2 valid case 1', async () => {
        const inputStr = `ab`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus2.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus2 valid case 2', async () => {
        const inputStr = `ac`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus2.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus2 valid case 3', async () => {
        const inputStr = `abccbbcc`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus2.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus2 valid case 4', async () => {
        const inputStr = `7abbcaa`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus2.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus2 invalid case 1', async () => {
        const inputStr = `adefghij`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('plus3 valid case 1', async () => {
        const inputStr = `abcbcbc`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus3.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus3 valid case 2', async () => {
        const inputStr = `acbabcbc`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus3.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus3 valid case 3', async () => {
        const inputStr = `abccbcbb`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus3.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus3 invalid case 1', async () => {
        const inputStr = `abab`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('plus4 valid case 1', async () => {
        const inputStr = `1234512b`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit4.calculateWitness(circuitInputs);
        await circuit4.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus4.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus4 valid case 2', async () => {
        const inputStr = `2134512b`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit4.calculateWitness(circuitInputs);
        await circuit4.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(path.join(__dirname, './circuits/plus4.json'), 'utf8'),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('plus4 invalid case 1', async () => {
        const inputStr = `1234b`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit4.calculateWitness(circuitInputs);
        await circuit4.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('plus4 invalid case 2', async () => {
        const inputStr = `34512`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit4.calculateWitness(circuitInputs);
        await circuit4.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    // it("plus5 valid case 1", async () => {
    //     const inputStr = `aa`;
    //     const paddedStr = apis.padString(inputStr, 8);
    //     const circuitInputs = {
    //         msg: paddedStr,
    //     };
    //     const witness = await circuit5.calculateWitness(circuitInputs);
    //     await circuit5.checkConstraints(witness);
    //     expect(1n).toEqual(witness[1]);
    //     const prefixIdxes = apis.extractSubstrIdxes(
    //         inputStr,
    //         readFileSync(
    //             path.join(__dirname, "./circuits/plus5.json"),
    //             "utf8"
    //         ),false
    //     )[0];
    //     for (let idx = 0; idx < 8; ++idx) {
    //         if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
    //             expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
    //         } else {
    //             expect(0n).toEqual(witness[2 + idx]);
    //         }
    //     }
    // });

    // it("plus5 valid case 2", async () => {
    //     const inputStr = `aaaababb`;
    //     const paddedStr = apis.padString(inputStr, 8);
    //     const circuitInputs = {
    //         msg: paddedStr,
    //     };
    //     const witness = await circuit5.calculateWitness(circuitInputs);
    //     await circuit5.checkConstraints(witness);
    //     expect(1n).toEqual(witness[1]);
    //     const prefixIdxes = apis.extractSubstrIdxes(
    //         inputStr,
    //         readFileSync(
    //             path.join(__dirname, "./circuits/plus5.json"),
    //             "utf8"
    //         ),false
    //     )[0];
    //     for (let idx = 0; idx < 8; ++idx) {
    //         if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
    //             expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
    //         } else {
    //             expect(0n).toEqual(witness[2 + idx]);
    //         }
    //     }
    // });

    // it("plus5 valid case 3", async () => {
    //     const inputStr = `bbcw2cab`;
    //     const paddedStr = apis.padString(inputStr, 8);
    //     const circuitInputs = {
    //         msg: paddedStr,
    //     };
    //     const witness = await circuit5.calculateWitness(circuitInputs);
    //     await circuit5.checkConstraints(witness);
    //     expect(1n).toEqual(witness[1]);
    //     const prefixIdxes = apis.extractSubstrIdxes(
    //         inputStr,
    //         readFileSync(
    //             path.join(__dirname, "./circuits/plus5.json"),
    //             "utf8"
    //         ),false
    //     )[0];
    //     for (let idx = 0; idx < 8; ++idx) {
    //         if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
    //             expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
    //         } else {
    //             expect(0n).toEqual(witness[2 + idx]);
    //         }
    //     }
    // });

    // it("plus5 invalid case 1", async () => {
    //     const inputStr = `872jdiua`;
    //     const paddedStr = apis.padString(inputStr, 8);
    //     const circuitInputs = {
    //         msg: paddedStr,
    //     };
    //     const witness = await circuit5.calculateWitness(circuitInputs);
    //     await circuit5.checkConstraints(witness);
    //     expect(0n).toEqual(witness[1]);
    //     for (let idx = 0; idx < 8; ++idx) {
    //         expect(0n).toEqual(witness[2 + idx]);
    //     }
    // });

    // it("plus5 invalid case 2", async () => {
    //     const inputStr = `872jdiu7`;
    //     const paddedStr = apis.padString(inputStr, 8);
    //     const circuitInputs = {
    //         msg: paddedStr,
    //     };
    //     const witness = await circuit5.calculateWitness(circuitInputs);
    //     await circuit5.checkConstraints(witness);
    //     expect(0n).toEqual(witness[1]);
    //     for (let idx = 0; idx < 8; ++idx) {
    //         expect(0n).toEqual(witness[2 + idx]);
    //     }
    // });

    // it("plus6 valid case 1", async () => {
    //     const inputStr = `aaaabbbb`;
    //     const paddedStr = apis.padString(inputStr, 8);
    //     const circuitInputs = {
    //         msg: paddedStr,
    //     };
    //     const witness = await circuit6.calculateWitness(circuitInputs);
    //     await circuit6.checkConstraints(witness);
    //     expect(1n).toEqual(witness[1]);
    //     const prefixIdxes = apis.extractSubstrIdxes(
    //         inputStr,
    //         readFileSync(
    //             path.join(__dirname, "./circuits/plus6.json"),
    //             "utf8"
    //         ),false
    //     )[0];
    //     for (let idx = 0; idx < 8; ++idx) {
    //         if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
    //             expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
    //         } else {
    //             expect(0n).toEqual(witness[2 + idx]);
    //         }
    //     }
    // });

    // it("plus6 invalid case 1", async () => {
    //     const inputStr = ``;
    //     const paddedStr = apis.padString(inputStr, 8);
    //     const circuitInputs = {
    //         msg: paddedStr,
    //     };
    //     const witness = await circuit6.calculateWitness(circuitInputs);
    //     await circuit6.checkConstraints(witness);
    //     expect(0n).toEqual(witness[1]);
    //     for (let idx = 0; idx < 8; ++idx) {
    //         expect(0n).toEqual(witness[2 + idx]);
    //     }
    // });
});



---
File: /@zk-email/zk-regex-circom/tests/question.test.js
---

import circom_tester from 'circom_tester';
import * as path from 'path';
import { readFileSync, writeFileSync } from 'fs';
import apis from '../../apis/pkg';
import compiler from '../../compiler/pkg';
const option = {
    include: path.join(__dirname, '../../../node_modules')
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(600000);
describe('Question Regex', () => {
    let circuit1;
    let circuit2;
    let circuit3;
    beforeAll(async () => {
        writeFileSync(
            path.join(__dirname, './circuits/question1_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/question1.json'),
                    'utf8'
                ),
                'Question1Regex'
            )
        );
        circuit1 = await wasm_tester(
            path.join(__dirname, './circuits/test_question1_regex.circom'),
            option
        );

        writeFileSync(
            path.join(__dirname, './circuits/question2_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/question2.json'),
                    'utf8'
                ),
                'Question2Regex'
            )
        );
        circuit2 = await wasm_tester(
            path.join(__dirname, './circuits/test_question2_regex.circom'),
            option
        );

        writeFileSync(
            path.join(__dirname, './circuits/question3_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/question3.json'),
                    'utf8'
                ),
                'Question3Regex'
            )
        );
        circuit3 = await wasm_tester(
            path.join(__dirname, './circuits/test_question3_regex.circom'),
            option
        );
    });

    it('question1 valid case 1', async () => {
        const inputStr = `b`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question1.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question1 valid case 2', async () => {
        const inputStr = `ab`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question1.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question1 valid case 3', async () => {
        const inputStr = `199aabb`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question1.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question1 invalid case 1', async () => {
        const inputStr = `aaaaaaaa`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('question1 invalid case 2', async () => {
        const inputStr = `cccccccc`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('question2 valid case 1', async () => {
        const inputStr = `12b`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question2.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question2 valid case 2', async () => {
        const inputStr = `11x2bb`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question2.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question2 invalid case 1', async () => {
        const inputStr = `1x2`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('question2 invalid case 2', async () => {
        const inputStr = `1xb`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('question3 valid case 1', async () => {
        const inputStr = `12c`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question3.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question3 valid case 2', async () => {
        const inputStr = `12ac`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question3.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question3 valid case 2', async () => {
        const inputStr = `12bc`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question3.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question3 valid case 4', async () => {
        const inputStr = `12a12bc1`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/question3.json'),
                'utf8'
            ),
            false
        )[0];
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('question3 invalid case 1', async () => {
        const inputStr = `1ac`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('question3 invalid case 2', async () => {
        const inputStr = `12abc`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('question3 invalid case 3', async () => {
        const inputStr = `12a12b`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit3.calculateWitness(circuitInputs);
        await circuit3.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });
});



---
File: /@zk-email/zk-regex-circom/tests/reveal_check.test.js
---

import circom_tester from 'circom_tester';
import * as path from 'path';
import { readFileSync, writeFileSync } from 'fs';
import apis from '../../apis/pkg';
import compiler from '../../compiler/pkg';
const option = {
    include: path.join(__dirname, '../../../node_modules')
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(600000);
describe('Revealed Chars Check', () => {
    let circuit1;
    let circuit2;
    beforeAll(async () => {
        writeFileSync(
            path.join(__dirname, './circuits/reveal_check1_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/reveal_check1.json'),
                    'utf8'
                ),
                'RevealCheck1Regex'
            )
        );
        circuit1 = await wasm_tester(
            path.join(__dirname, './circuits/test_reveal_check1_regex.circom'),
            option
        );

        writeFileSync(
            path.join(__dirname, './circuits/reveal_check2_regex.circom'),
            compiler.genFromDecomposed(
                readFileSync(
                    path.join(__dirname, './circuits/reveal_check2.json'),
                    'utf8'
                ),
                'RevealCheck2Regex'
            )
        );
        circuit2 = await wasm_tester(
            path.join(__dirname, './circuits/test_reveal_check2_regex.circom'),
            option
        );
    });

    it('reveal check1 valid case 1', async () => {
        const inputStr = `aba`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/reveal_check1.json'),
                'utf8'
            ),
            false
        )[0];
        expect(prefixIdxes).toEqual([0, 3]);
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('reveal check1 valid case 2', async () => {
        const inputStr = `7abaab9`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/reveal_check1.json'),
                'utf8'
            ),
            false
        )[0];
        expect(prefixIdxes).toEqual([1, 4]);
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('reveal check1 invalid case 1', async () => {
        const inputStr = `aca`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('reveal check1 invalid case 2', async () => {
        const inputStr = `aaa`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit1.calculateWitness(circuitInputs);
        await circuit1.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('reveal check2 valid case 1', async () => {
        const inputStr = `aa`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/reveal_check2.json'),
                'utf8'
            ),
            false
        )[0];
        expect(prefixIdxes).toEqual([0, 2]);
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('reveal check2 valid case 2', async () => {
        const inputStr = `ab`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/reveal_check2.json'),
                'utf8'
            ),
            false
        )[0];
        expect(prefixIdxes).toEqual([0, 2]);
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('reveal check2 valid case 3', async () => {
        const inputStr = `aba`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(1n).toEqual(witness[1]);
        const prefixIdxes = apis.extractSubstrIdxes(
            inputStr,
            readFileSync(
                path.join(__dirname, './circuits/reveal_check2.json'),
                'utf8'
            ),
            false
        )[0];
        expect(prefixIdxes).toEqual([0, 2]);
        for (let idx = 0; idx < 8; ++idx) {
            if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
                expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
            } else {
                expect(0n).toEqual(witness[2 + idx]);
            }
        }
    });

    it('reveal check2 invalid case 1', async () => {
        const inputStr = `ac`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('reveal check2 invalid case 2', async () => {
        const inputStr = `bad`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });

    it('reveal check2 invalid case 3', async () => {
        const inputStr = `bad`;
        const paddedStr = apis.padString(inputStr, 8);
        const circuitInputs = {
            msg: paddedStr
        };
        const witness = await circuit2.calculateWitness(circuitInputs);
        await circuit2.checkConstraints(witness);
        expect(0n).toEqual(witness[1]);
        for (let idx = 0; idx < 8; ++idx) {
            expect(0n).toEqual(witness[2 + idx]);
        }
    });
});



---
File: /@zk-email/zk-regex-circom/tests/simple_regex_decomposed.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
  include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(120000);
describe("Simple Regex Decomposed", () => {
  let circuit;
  beforeAll(async () => {
    const email_addr_json = readFileSync(
      path.join(__dirname, "./circuits/simple_regex_decomposed.json"),
      "utf8"
    );
    const circom = compiler.genFromDecomposed(
      email_addr_json,
      "SimpleRegexDecomposed"
    );
    writeFileSync(
      path.join(__dirname, "./circuits/simple_regex_decomposed.circom"),
      circom
    );
    circuit = await wasm_tester(
      path.join(__dirname, "./circuits/test_simple_regex_decomposed.circom"),
      option
    );
  });

  it("case 1", async () => {
    const input = "email was meant for @zkRegex.";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [[21, 22, 23, 24, 25, 26, 27]];
    for (let substr_idx = 0; substr_idx < 1; ++substr_idx) {
      for (let idx = 0; idx < 64; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 64 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 64 * substr_idx + idx]);
        }
      }
    }
  });
});



---
File: /@zk-email/zk-regex-circom/tests/simple_regex.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
  include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(120000);
describe("Simple Regex", () => {
  let circuit;
  beforeAll(async () => {
    const substrs_json = readFileSync(
      path.join(__dirname, "./circuits/simple_regex_substrs.json"),
      "utf8"
    );
    const circom = compiler.genFromRaw(
      "1=(a|b) (2=(b|c)+ )+d",
      substrs_json,
      "SimpleRegex"
    );
    writeFileSync(
      path.join(__dirname, "./circuits/simple_regex.circom"),
      circom
    );
    circuit = await wasm_tester(
      path.join(__dirname, "./circuits/test_simple_regex.circom"),
      option
    );
  });

  it("case 1", async () => {
    const input = "1=a 2=b d";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [[2], [6], [8]];
    for (let substr_idx = 0; substr_idx < 3; ++substr_idx) {
      for (let idx = 0; idx < 64; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 64 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 64 * substr_idx + idx]);
        }
      }
    }
  });

  it("case 2", async () => {
    const input = "1=a 2=b 2=bc 2=c d";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [[2], [6, 10, 11, 15], [17]];
    for (let substr_idx = 0; substr_idx < 3; ++substr_idx) {
      for (let idx = 0; idx < 64; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 64 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 64 * substr_idx + idx]);
        }
      }
    }
  });

  it("case 3", async () => {
    const input = "1=a 2=b 2=bc 2=c da 1=a 2=cb 2=c 2=b dd";
    const paddedStr = apis.padString(input, 64);
    const circuitInputs = {
      msg: paddedStr,
    };

    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const revealedIdx = [
      [2, 22],
      [6, 10, 11, 15, 26, 27, 31, 35],
      [17, 37],
    ];
    for (let substr_idx = 0; substr_idx < 3; ++substr_idx) {
      for (let idx = 0; idx < 64; ++idx) {
        if (revealedIdx[substr_idx].includes(idx)) {
          expect(BigInt(paddedStr[idx])).toEqual(
            witness[2 + 64 * substr_idx + idx]
          );
        } else {
          expect(0n).toEqual(witness[2 + 64 * substr_idx + idx]);
        }
      }
    }
  });
});



---
File: /@zk-email/zk-regex-circom/tests/subject_all.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
  include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(120000);
describe("Subject All Regex", () => {
  let circuit;
  beforeAll(async () => {
    const email_addr_json = readFileSync(
      path.join(__dirname, "../circuits/common/subject_all.json"),
      "utf8"
    );
    const circom = compiler.genFromDecomposed(
      email_addr_json,
      "SubjectAllRegex"
    );
    writeFileSync(
      path.join(__dirname, "../circuits/common/subject_all_regex.circom"),
      circom
    );
    circuit = await wasm_tester(
      path.join(__dirname, "./circuits/test_subject_all_regex.circom"),
      option
    );
  });

  it("subject from beginning", async () => {
    const subjectStr = "subject:This is a test.\r\n";
    const paddedStr = apis.padString(subjectStr, 256);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractSubjectAllIdxes(subjectStr)[0];
    for (let idx = 0; idx < 256; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("subject after new line", async () => {
    const subjectStr = "dummy\r\nsubject:This is a test.\r\n";
    const paddedStr = apis.padString(subjectStr, 256);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractSubjectAllIdxes(subjectStr)[0];
    for (let idx = 0; idx < 256; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("subject from beginning and non-English case", async () => {
    const subjectStr = "subject:これはテストです。\r\n";
    const paddedStr = apis.padString(subjectStr, 256);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractSubjectAllIdxes(subjectStr)[0];
    for (let idx = 0; idx < 256; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("subject in the invalid field", async () => {
    const subjectStr = "\r\nto:subject:This is a subject in To field.\r\n";
    const paddedStr = apis.padString(subjectStr, 256);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(0n).toEqual(witness[1]);
    for (let idx = 0; idx < 256; ++idx) {
      expect(0n).toEqual(witness[2 + idx]);
    }
  });

  it('invalid subject field with 255', async () => {
    const subjectStr = `subject:This is a subject in To field.\r\n`;
    let paddedStr = apis.padString(subjectStr, 1022);
    paddedStr.unshift(49);
    paddedStr.unshift(255);
    const circuitInputs = {
      msg: paddedStr
    };
    async function failFn() {
      const witness = await circuit.calculateWitness(circuitInputs);
      await circuit.checkConstraints(witness);
    }
    await expect(failFn).rejects.toThrow();
  });
});



---
File: /@zk-email/zk-regex-circom/tests/timestamp.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
  include: path.join(__dirname, "../../../node_modules"),
};
const wasm_tester = circom_tester.wasm;

jest.setTimeout(600000);
describe("Timestamp Regex", () => {
  let circuit;
  beforeAll(async () => {
    const email_addr_json = readFileSync(
      path.join(__dirname, "../circuits/common/timestamp.json"),
      "utf8"
    );
    const circom = compiler.genFromDecomposed(
      email_addr_json,
      "TimestampRegex"
    );
    writeFileSync(
      path.join(__dirname, "../circuits/common/timestamp_regex.circom"),
      circom
    );
    circuit = await wasm_tester(
      path.join(__dirname, "./circuits/test_timestamp_regex.circom"),
      option
    );
  });

  it("timestamp in the header", async () => {
    const signatureField = `dkim-signature:v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20230601; t=1694989812; x=1695594612; dara=google.com; h=to:subject:message-id:date:from:mime-version:from:to:cc:subject :date:message-id:reply-to; bh=BWETwQ9JDReS4GyR2v2TTR8Bpzj9ayumsWQJ3q7vehs=; b=`;
    const paddedStr = apis.padString(signatureField, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractTimestampIdxes(signatureField)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });

  it("timestamp after new line", async () => {
    const signatureField = `\r\ndkim-signature:v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20230601; t=1694989812; x=1695594612; dara=google.com; h=to:subject:message-id:date:from:mime-version:from:to:cc:subject :date:message-id:reply-to; bh=BWETwQ9JDReS4GyR2v2TTR8Bpzj9ayumsWQJ3q7vehs=; b=`;
    const paddedStr = apis.padString(signatureField, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(1n).toEqual(witness[1]);
    const prefixIdxes = apis.extractTimestampIdxes(signatureField)[0];
    for (let idx = 0; idx < 1024; ++idx) {
      if (idx >= prefixIdxes[0] && idx < prefixIdxes[1]) {
        expect(BigInt(paddedStr[idx])).toEqual(witness[2 + idx]);
      } else {
        expect(0n).toEqual(witness[2 + idx]);
      }
    }
  });


  it("invalid timestamp", async () => {
    const signatureField = `to:dkim-signature:v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20230601; t=1694989812; x=1695594612; dara=google.com; h=to:subject:message-id:date:from:mime-version:from:to:cc:subject :date:message-id:reply-to; bh=BWETwQ9JDReS4GyR2v2TTR8Bpzj9ayumsWQJ3q7vehs=; b=`;
    const paddedStr = apis.padString(signatureField, 1024);
    const circuitInputs = {
      msg: paddedStr,
    };
    const witness = await circuit.calculateWitness(circuitInputs);
    await circuit.checkConstraints(witness);
    expect(0n).toEqual(witness[1]);
    for (let idx = 0; idx < 1024; ++idx) {
      expect(0n).toEqual(witness[2 + idx]);
    }
  });
});



---
File: /@zk-email/zk-regex-circom/tests/to_addr.test.js
---

import circom_tester from "circom_tester";
import * as path from "path";
import { readFileSync, writeFileSync } from "fs";
import apis from "../../apis/pkg";
import compiler from "../../compiler/pkg";
const option = {
