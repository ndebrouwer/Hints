        } while (!F.isSquare(x3b));

        P[1] = F.sqrt(x3b);

        const s = F.isNegative(P[1]);
        if (greatest ^ s) P[1] = F.neg(P[1]);

        let Pbuff = new Uint8Array(this.F.n8*2);
        Pbuff.set(P[0]);
        Pbuff.set(P[1], this.F.n8);

        if (this.cofactor) {
            Pbuff = this.timesScalar(Pbuff, this.cofactor);
        }

        return Pbuff;
    }



    toObject(a) {
        if (this.isZero(a)) {
            return [
                this.F.toObject(this.F.zero),
                this.F.toObject(this.F.one),
                this.F.toObject(this.F.zero),
            ];
        }
        const x = this.F.toObject(a.slice(0, this.F.n8));
        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));
        let z;
        if (a.byteLength == this.F.n8*3) {
            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));
        } else {
            z = this.F.toObject(this.F.one);
        }
        return [x, y, z];
    }

    fromObject(a) {
        const x = this.F.fromObject(a[0]);
        const y = this.F.fromObject(a[1]);
        let z;
        if (a.length==3) {
            z = this.F.fromObject(a[2]);
        } else {
            z = this.F.one;
        }
        if (this.F.isZero(z, this.F.one)) {
            return this.zeroAffine;
        } else if (this.F.eq(z, this.F.one)) {
            const buff = new Uint8Array(this.F.n8*2);
            buff.set(x);
            buff.set(y, this.F.n8);
            return buff;
        } else {
            const buff = new Uint8Array(this.F.n8*3);
            buff.set(x);
            buff.set(y, this.F.n8);
            buff.set(z, this.F.n8*2);
            return buff;
        }
    }

    e(a) {
        if (a instanceof Uint8Array) return a;
        return this.fromObject(a);
    }

    x(a) {
        const tmp = this.toAffine(a);
        return tmp.slice(0, this.F.n8);
    }

    y(a) {
        const tmp = this.toAffine(a);
        return tmp.slice(this.F.n8);
    }

}





---
File: /@zk-email/helpers/node_modules/ffjavascript/src/wasm_field1.js
---

import * as Scalar from "./scalar.js";
import * as utils from "./utils.js";
import { getThreadRng } from "./random.js";
import buildBatchConvert from "./engine_batchconvert.js";
import BigBuffer from "./bigbuffer.js";


export default class WasmField1 {

    constructor(tm, prefix, n8, p) {
        this.tm = tm;
        this.prefix = prefix;

        this.p = p;
        this.n8 = n8;
        this.type = "F1";
        this.m = 1;

        this.half = Scalar.shiftRight(p, Scalar.one);
        this.bitLength = Scalar.bitLength(p);
        this.mask = Scalar.sub(Scalar.shiftLeft(Scalar.one, this.bitLength), Scalar.one);

        this.pOp1 = tm.alloc(n8);
        this.pOp2 = tm.alloc(n8);
        this.pOp3 = tm.alloc(n8);
        this.tm.instance.exports[prefix + "_zero"](this.pOp1);
        this.zero = this.tm.getBuff(this.pOp1, this.n8);
        this.tm.instance.exports[prefix + "_one"](this.pOp1);
        this.one = this.tm.getBuff(this.pOp1, this.n8);

        this.negone = this.neg(this.one);
        this.two = this.add(this.one, this.one);

        this.n64 = Math.floor(n8/8);
        this.n32 = Math.floor(n8/4);

        if(this.n64*8 != this.n8) {
            throw new Error("n8 must be a multiple of 8");
        }

        this.half = Scalar.shiftRight(this.p, Scalar.one);
        this.nqr = this.two;
        let r = this.exp(this.nqr, this.half);
        while (!this.eq(r, this.negone)) {
            this.nqr = this.add(this.nqr, this.one);
            r = this.exp(this.nqr, this.half);
        }

        this.shift = this.mul(this.nqr, this.nqr);
        this.shiftInv = this.inv(this.shift);

        this.s = 0;
        let t = Scalar.sub(this.p, Scalar.one);

        while ( !Scalar.isOdd(t) ) {
            this.s = this.s + 1;
            t = Scalar.shiftRight(t, Scalar.one);
        }

        this.w = [];
        this.w[this.s] = this.exp(this.nqr, t);

        for (let i= this.s-1; i>=0; i--) {
            this.w[i] = this.square(this.w[i+1]);
        }

        if (!this.eq(this.w[0], this.one)) {
            throw new Error("Error calculating roots of unity");
        }

        this.batchToMontgomery = buildBatchConvert(tm, prefix + "_batchToMontgomery", this.n8, this.n8);
        this.batchFromMontgomery = buildBatchConvert(tm, prefix + "_batchFromMontgomery", this.n8, this.n8);
    }


    op2(opName, a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    op2Bool(opName, a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
    }

    op1(opName, a) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    op1Bool(opName, a) {
        this.tm.setBuff(this.pOp1, a);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    }

    add(a,b) {
        return this.op2("_add", a, b);
    }


    eq(a,b) {
        return this.op2Bool("_eq", a, b);
    }

    isZero(a) {
        return this.op1Bool("_isZero", a);
    }

    sub(a,b) {
        return this.op2("_sub", a, b);
    }

    neg(a) {
        return this.op1("_neg", a);
    }

    inv(a) {
        return this.op1("_inverse", a);
    }

    toMontgomery(a) {
        return this.op1("_toMontgomery", a);
    }

    fromMontgomery(a) {
        return this.op1("_fromMontgomery", a);
    }

    mul(a,b) {
        return this.op2("_mul", a, b);
    }

    div(a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
        this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    square(a) {
        return this.op1("_square", a);
    }

    isSquare(a) {
        return this.op1Bool("_isSquare", a);
    }

    sqrt(a) {
        return this.op1("_sqrt", a);
    }

    exp(a, b) {
        if (!(b instanceof Uint8Array)) {
            b = Scalar.toLEBuff(Scalar.e(b));
        }
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    isNegative(a) {
        return this.op1Bool("_isNegative", a);
    }

    e(a, b) {
        if (a instanceof Uint8Array) return a;
        let ra = Scalar.e(a, b);
        if (Scalar.isNegative(ra)) {
            ra = Scalar.neg(ra);
            if (Scalar.gt(ra, this.p)) {
                ra = Scalar.mod(ra, this.p);
            }
            ra = Scalar.sub(this.p, ra);
        } else {
            if (Scalar.gt(ra, this.p)) {
                ra = Scalar.mod(ra, this.p);
            }
        }
        const buff = utils.leInt2Buff(ra, this.n8);
        return this.toMontgomery(buff);
    }

    toString(a, radix) {
        const an = this.fromMontgomery(a);
        const s = Scalar.fromRprLE(an, 0);
        return Scalar.toString(s, radix);
    }

    fromRng(rng) {
        let v;
        const buff = new Uint8Array(this.n8);
        do {
            v = Scalar.zero;
            for (let i=0; i<this.n64; i++) {
                v = Scalar.add(v,  Scalar.shiftLeft(rng.nextU64(), 64*i));
            }
            v = Scalar.band(v, this.mask);
        } while (Scalar.geq(v, this.p));
        Scalar.toRprLE(buff, 0, v, this.n8);
        return buff;
    }

    random() {
        return this.fromRng(getThreadRng());
    }

    toObject(a) {
        const an = this.fromMontgomery(a);
        return Scalar.fromRprLE(an, 0);
    }

    fromObject(a) {
        const buff = new Uint8Array(this.n8);
        Scalar.toRprLE(buff, 0, a, this.n8);
        return this.toMontgomery(buff);
    }

    toRprLE(buff, offset, a) {
        buff.set(this.fromMontgomery(a), offset);
    }

    toRprBE(buff, offset, a) {
        const buff2 = this.fromMontgomery(a);
        for (let i=0; i<this.n8/2; i++) {
            const aux = buff2[i];
            buff2[i] = buff2[this.n8-1-i];
            buff2[this.n8-1-i] = aux;
        }
        buff.set(buff2, offset);
    }

    fromRprLE(buff, offset) {
        offset = offset || 0;
        const res = buff.slice(offset, offset + this.n8);
        return this.toMontgomery(res);
    }

    async batchInverse(buffIn) {
        let returnArray = false;
        const sIn = this.n8;
        const sOut = this.n8;

        if (Array.isArray(buffIn)) {
            buffIn = utils.array2buffer(buffIn, sIn );
            returnArray = true;
        } else {
            buffIn = buffIn.slice(0, buffIn.byteLength);
        }

        const nPoints = Math.floor(buffIn.byteLength / sIn);
        if ( nPoints * sIn !== buffIn.byteLength) {
            throw new Error("Invalid buffer size");
        }
        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);
        const opPromises = [];
        for (let i=0; i<this.tm.concurrency; i++) {
            let n;
            if (i< this.tm.concurrency-1) {
                n = pointsPerChunk;
            } else {
                n = nPoints - i*pointsPerChunk;
            }
            if (n==0) continue;

            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);
            const task = [
                {cmd: "ALLOCSET", var: 0, buff:buffChunk},
                {cmd: "ALLOC", var: 1, len:sOut * n},
                {cmd: "CALL", fnName: this.prefix + "_batchInverse", params: [
                    {var: 0},
                    {val: sIn},
                    {val: n},
                    {var: 1},
                    {val: sOut},
                ]},
                {cmd: "GET", out: 0, var: 1, len:sOut * n},
            ];
            opPromises.push(
                this.tm.queueAction(task)
            );
        }

        const result = await Promise.all(opPromises);

        let fullBuffOut;
        if (buffIn instanceof BigBuffer) {
            fullBuffOut = new BigBuffer(nPoints*sOut);
        } else {
            fullBuffOut = new Uint8Array(nPoints*sOut);
        }

        let p =0;
        for (let i=0; i<result.length; i++) {
            fullBuffOut.set(result[i][0], p);
            p+=result[i][0].byteLength;
        }

        if (returnArray) {
            return utils.buffer2array(fullBuffOut, sOut);
        } else {
            return fullBuffOut;
        }

    }

}





---
File: /@zk-email/helpers/node_modules/ffjavascript/src/wasm_field2.js
---

import { getThreadRng } from "./random.js";
import * as Scalar from "./scalar.js";


export default class WasmField2 {

    constructor(tm, prefix, F) {
        this.tm = tm;
        this.prefix = prefix;

        this.F = F;
        this.type = "F2";
        this.m = F.m * 2;
        this.n8 = this.F.n8*2;
        this.n32 = this.F.n32*2;
        this.n64 = this.F.n64*2;

        this.pOp1 = tm.alloc(F.n8*2);
        this.pOp2 = tm.alloc(F.n8*2);
        this.pOp3 = tm.alloc(F.n8*2);
        this.tm.instance.exports[prefix + "_zero"](this.pOp1);
        this.zero = tm.getBuff(this.pOp1, this.n8);
        this.tm.instance.exports[prefix + "_one"](this.pOp1);
        this.one = tm.getBuff(this.pOp1, this.n8);

        this.negone = this.neg(this.one);
        this.two = this.add(this.one, this.one);

    }

    op2(opName, a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    op2Bool(opName, a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
    }

    op1(opName, a) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    op1Bool(opName, a) {
        this.tm.setBuff(this.pOp1, a);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    }

    add(a,b) {
        return this.op2("_add", a, b);
    }

    eq(a,b) {
        return this.op2Bool("_eq", a, b);
    }

    isZero(a) {
        return this.op1Bool("_isZero", a);
    }

    sub(a,b) {
        return this.op2("_sub", a, b);
    }

    neg(a) {
        return this.op1("_neg", a);
    }

    inv(a) {
        return this.op1("_inverse", a);
    }

    isNegative(a) {
        return this.op1Bool("_isNegative", a);
    }

    toMontgomery(a) {
        return this.op1("_toMontgomery", a);
    }

    fromMontgomery(a) {
        return this.op1("_fromMontgomery", a);
    }

    mul(a,b) {
        return this.op2("_mul", a, b);
    }

    mul1(a,b) {
        return this.op2("_mul1", a, b);
    }

    div(a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
        this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    square(a) {
        return this.op1("_square", a);
    }

    isSquare(a) {
        return this.op1Bool("_isSquare", a);
    }

    sqrt(a) {
        return this.op1("_sqrt", a);
    }

    exp(a, b) {
        if (!(b instanceof Uint8Array)) {
            b = Scalar.toLEBuff(Scalar.e(b));
        }
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    e(a, b) {
        if (a instanceof Uint8Array) return a;
        if ((Array.isArray(a)) && (a.length == 2)) {
            const c1 = this.F.e(a[0], b);
            const c2 = this.F.e(a[1], b);
            const res = new Uint8Array(this.F.n8*2);
            res.set(c1);
            res.set(c2, this.F.n8*2);
            return res;
        } else {
            throw new Error("invalid F2");
        }
    }

    toString(a, radix) {
        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);
        const s2 = this.F.toString(a.slice(this.F.n8), radix);
        return `[${s1}, ${s2}]`;
    }

    fromRng(rng) {
        const c1 = this.F.fromRng(rng);
        const c2 = this.F.fromRng(rng);
        const res = new Uint8Array(this.F.n8*2);
        res.set(c1);
        res.set(c2, this.F.n8);
        return res;
    }

    random() {
        return this.fromRng(getThreadRng());
    }

    toObject(a) {
        const c1 = this.F.toObject(a.slice(0, this.F.n8));
        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));
        return [c1, c2];
    }

    fromObject(a) {
        const buff = new Uint8Array(this.F.n8*2);
        const b1 = this.F.fromObject(a[0]);
        const b2 = this.F.fromObject(a[1]);
        buff.set(b1);
        buff.set(b2, this.F.n8);
        return buff;
    }

    c1(a) {
        return a.slice(0, this.F.n8);
    }

    c2(a) {
        return a.slice(this.F.n8);
    }

}




---
File: /@zk-email/helpers/node_modules/ffjavascript/src/wasm_field3.js
---



import { getThreadRng } from "./random.js";
import * as Scalar from "./scalar.js";


export default class WasmField3 {

    constructor(tm, prefix, F) {
        this.tm = tm;
        this.prefix = prefix;

        this.F = F;
        this.type = "F3";
        this.m = F.m * 3;
        this.n8 = this.F.n8*3;
        this.n32 = this.F.n32*3;
        this.n64 = this.F.n64*3;

        this.pOp1 = tm.alloc(F.n8*3);
        this.pOp2 = tm.alloc(F.n8*3);
        this.pOp3 = tm.alloc(F.n8*3);
        this.tm.instance.exports[prefix + "_zero"](this.pOp1);
        this.zero = tm.getBuff(this.pOp1, this.n8);
        this.tm.instance.exports[prefix + "_one"](this.pOp1);
        this.one = tm.getBuff(this.pOp1, this.n8);

        this.negone = this.neg(this.one);
        this.two = this.add(this.one, this.one);

    }

    op2(opName, a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    op2Bool(opName, a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
    }

    op1(opName, a) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    op1Bool(opName, a) {
        this.tm.setBuff(this.pOp1, a);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    }


    eq(a,b) {
        return this.op2Bool("_eq", a, b);
    }

    isZero(a) {
        return this.op1Bool("_isZero", a);
    }

    add(a,b) {
        return this.op2("_add", a, b);
    }

    sub(a,b) {
        return this.op2("_sub", a, b);
    }

    neg(a) {
        return this.op1("_neg", a);
    }

    inv(a) {
        return this.op1("_inverse", a);
    }

    isNegative(a) {
        return this.op1Bool("_isNegative", a);
    }

    toMontgomery(a) {
        return this.op1("_toMontgomery", a);
    }

    fromMontgomery(a) {
        return this.op1("_fromMontgomery", a);
    }

    mul(a,b) {
        return this.op2("_mul", a, b);
    }

    div(a, b) {
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
        this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
    }

    square(a) {
        return this.op1("_square", a);
    }

    isSquare(a) {
        return this.op1Bool("_isSquare", a);
    }

    sqrt(a) {
        return this.op1("_sqrt", a);
    }

    exp(a, b) {
        if (!(b instanceof Uint8Array)) {
            b = Scalar.toLEBuff(Scalar.e(b));
        }
        this.tm.setBuff(this.pOp1, a);
        this.tm.setBuff(this.pOp2, b);
        this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);
        return this.getBuff(this.pOp3, this.n8);
    }

    e(a, b) {
        if (a instanceof Uint8Array) return a;
        if ((Array.isArray(a)) && (a.length == 3)) {
            const c1 = this.F.e(a[0], b);
            const c2 = this.F.e(a[1], b);
            const c3 = this.F.e(a[2], b);
            const res = new Uint8Array(this.F.n8*3);
            res.set(c1);
            res.set(c2, this.F.n8);
            res.set(c3, this.F.n8*2);
            return res;
        } else {
            throw new Error("invalid F3");
        }
    }

    toString(a, radix) {
        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);
        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);
        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);
        return `[${s1}, ${s2}, ${s3}]`;
    }

    fromRng(rng) {
        const c1 = this.F.fromRng(rng);
        const c2 = this.F.fromRng(rng);
        const c3 = this.F.fromRng(rng);
        const res = new Uint8Array(this.F.n8*3);
        res.set(c1);
        res.set(c2, this.F.n8);
        res.set(c3, this.F.n8*2);
        return res;
    }

    random() {
        return this.fromRng(getThreadRng());
    }

    toObject(a) {
        const c1 = this.F.toObject(a.slice(0, this.F.n8));
        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));
        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));
        return [c1, c2, c3];
    }

    fromObject(a) {
        const buff = new Uint8Array(this.F.n8*3);
        const b1 = this.F.fromObject(a[0]);
        const b2 = this.F.fromObject(a[1]);
        const b3 = this.F.fromObject(a[2]);
        buff.set(b1);
        buff.set(b2, this.F.n8);
        buff.set(b3, this.F.n8*2);
        return buff;
    }

    c1(a) {
        return a.slice(0, this.F.n8);
    }

    c2(a) {
        return a.slice(this.F.n8, this.F.n8*2);
    }

    c3(a) {
        return a.slice(this.F.n8*2);
    }

}





---
File: /@zk-email/helpers/node_modules/ffjavascript/test/algebra.js
---

/*
    Copyright 2018 0kims association.

    This file is part of zksnark JavaScript library.

    zksnark JavaScript library is a free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    zksnark JavaScript library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along with
    zksnark JavaScript library. If not, see <https://www.gnu.org/licenses/>.
*/

import chai from "chai";

import * as Scalar from "../src/scalar.js";
import buildBn128 from "../src/bn128.js";
import F1Field from "../src/f1field.js";

const assert = chai.assert;


describe("F1 testing", function() {
    this.timeout(0);

    let bn128;
    before( async() => {
        bn128 = await buildBn128();
    });
    after( async() => {
        bn128.terminate();
    });

    it("Should compute euclidean", () => {
        const F = new F1Field(Scalar.fromString("7"));
        const res = F.inv(F.e(4));

        assert(F.eq(res, F.e(2)));
    });

    it("Should multiply and divide in F1", () => {
        const a = bn128.F1.e("1");
        const b = bn128.F1.e("-1");
        const c = bn128.F1.mul(a,b);
        const d = bn128.F1.div(c,b);

        assert(bn128.F1.eq(a, d));
    });

    it("Should compute sqrts", () => {
        const F = new F1Field(bn128.r);
        const a = F.e("4");
        let b = F.sqrt(a);
        assert(F.eq(F.e(0), F.sqrt(F.e("0"))));
        assert(F.eq(b, F.e("2")));
        // assert(F.sqrt(F.nqr) === null);
    });

    it("Should compute sqrt of 100 random numbers", () => {
        const F = new F1Field(bn128.r);
        for (let j=0;j<100; j++) {
            let a = F.random();
            let s = F.sqrt(a);
            if (s != null) {
                assert(F.eq(F.square(s), a));
            }
        }
    });
});

describe("Curve G1 Test", function() {
    this.timeout(0);

    let bn128;
    before( async() => {
        bn128 = await buildBn128();
    });
    after( async() => {
        bn128.terminate();
    });

    it("r*one == 0", () => {
        const res = bn128.G1.timesScalar(bn128.G1.g, bn128.r);

        assert(bn128.G1.eq(res, bn128.G1.zero), "G1 does not have range r");
    });

    it("Should add match in various in G1", () => {

        const r1 = bn128.Fr.e(33);
        const r2 = bn128.Fr.e(44);

        const gr1 = bn128.G1.timesFr(bn128.G1.g, r1);
        const gr2 = bn128.G1.timesFr(bn128.G1.g, r2);

        const grsum1 = bn128.G1.add(gr1, gr2);

        const grsum2 = bn128.G1.timesFr(bn128.G1.g, bn128.Fr.add(r1, r2));

        assert(bn128.G1.eq(grsum1, grsum2));
    });
});

describe("Curve G2 Test", function() {
    this.timeout(0);

    let bn128;
    before( async() => {
        bn128 = await buildBn128();
    });
    after( async() => {
        bn128.terminate();
    });

    it ("r*one == 0", () => {
        const res = bn128.G2.timesScalar(bn128.G2.g, bn128.r);

        assert(bn128.G2.eq(res, bn128.G2.zero), "G2 does not have range r");
    });

    it("Should add match in various in G2", () => {
        const r1 = bn128.Fr.e(33);
        const r2 = bn128.Fr.e(44);

        const gr1 = bn128.G2.timesFr(bn128.G2.g, r1);
        const gr2 = bn128.G2.timesFr(bn128.G2.g, r2);

        const grsum1 = bn128.G2.add(gr1, gr2);

        const grsum2 = bn128.G2.timesFr(bn128.G2.g, bn128.Fr.add(r1, r2));

        /*
        console.log(G2.toString(grsum1));
        console.log(G2.toString(grsum2));
        */

        assert(bn128.G2.eq(grsum1, grsum2));
    });
});

describe("F6 testing", function() {
    this.timeout(0);

    let bn128;
    before( async() => {
        bn128 = await buildBn128();
    });
    after( async() => {
        bn128.terminate();
    });

    it("Should multiply and divide in F6", () => {

        const a = bn128.F6.fromObject([
            [Scalar.e("1"), Scalar.e("2")],
            [Scalar.e("3"), Scalar.e("4")],
            [Scalar.e("5"), Scalar.e("6")]
        ]);
        const b = bn128.F6.fromObject([
            [Scalar.e("12"), Scalar.e("11")],
            [Scalar.e("10"), Scalar.e("9")],
            [Scalar.e("8"), Scalar.e("7")]
        ]);
        const c = bn128.F6.mul(a,b);
        const d = bn128.F6.div(c,b);

        assert(bn128.F6.eq(a, d));
    });
});

describe("F12 testing", function() {
    this.timeout(0);

    let bn128;
    before( async() => {
        bn128 = await buildBn128();
    });
    after( async() => {
        bn128.terminate();
    });

    it("Should multiply and divide in F12", () => {
        const a = bn128.Gt.fromObject([
            [
                [Scalar.e("1"), Scalar.e("2")],
                [Scalar.e("3"), Scalar.e("4")],
                [Scalar.e("5"), Scalar.e("6")]
            ],
            [
                [Scalar.e("7"), Scalar.e("8")],
                [Scalar.e("9"), Scalar.e("10")],
                [Scalar.e("11"), Scalar.e("12")]
            ]
        ]);
        const b = bn128.Gt.fromObject([
            [
                [Scalar.e("12"), Scalar.e("11")],
                [Scalar.e("10"), Scalar.e("9")],
                [Scalar.e("8"), Scalar.e("7")]
            ],
            [
                [Scalar.e("6"), Scalar.e("5")],
                [Scalar.e("4"), Scalar.e("3")],
                [Scalar.e("2"), Scalar.e("1")]
            ]
        ]);
        const c = bn128.F12.mul(a,b);
        const d = bn128.F12.div(c,b);

        assert(bn128.F12.eq(a, d));
    });
});

describe("Pairing", function() {
    this.timeout(0);

    let bn128;
    before( async() => {
        bn128 = await buildBn128();
    });
    after( async() => {
        bn128.terminate();
    });

    /*
    it("Should match pairing", () => {
        for (let i=0; i<1; i++) {
            const bn128 = new BN128();

            const g1a = bn128.G1.mulScalar(bn128.G1.g, 25);
            const g2a = bn128.G2.mulScalar(bn128.G2.g, 30);

            const g1b = bn128.G1.mulScalar(bn128.G1.g, 30);
            const g2b = bn128.G2.mulScalar(bn128.G2.g, 25);

            const pre1a = bn128.prepareG1(g1a);
            const pre2a = bn128.prepareG2(g2a);
            const pre1b = bn128.prepareG1(g1b);
            const pre2b = bn128.prepareG2(g2b);

            const r1 = bn128.millerLoop(pre1a, pre2a);
            const r2 = bn128.millerLoop(pre1b, pre2b);

            const rbe = bn128.F12.mul(r1, bn128.F12.inverse(r2));

            const res = bn128.finalExponentiation(rbe);

            assert(bn128.F12.eq(res, bn128.F12.one));
        }
    })
    */
    it("Should generate another pairing pairing", () => {
        for (let i=0; i<1; i++) {
            const g1a = bn128.G1.timesScalar(bn128.G1.g, 10);
            const g2a = bn128.G2.timesScalar(bn128.G2.g, 1);

            const g1b = bn128.G1.timesScalar(bn128.G1.g, 1);
            const g2b = bn128.G2.timesScalar(bn128.G2.g, 10);

            const pre1a = bn128.prepareG1(g1a);
            const pre2a = bn128.prepareG2(g2a);
            const pre1b = bn128.prepareG1(g1b);
            const pre2b = bn128.prepareG2(g2b);

            const r1 = bn128.millerLoop(pre1a, pre2a);
            const r2 = bn128.finalExponentiation(r1);

            const r3 = bn128.millerLoop(pre1b, pre2b);

            const r4 = bn128.finalExponentiation(r3);

            /*
            console.log("ML1: " ,bn128.F12.toString(r1));
            console.log("FE1: " ,bn128.F12.toString(r2));
            console.log("ML2: " ,bn128.F12.toString(r3));
            console.log("FE2: " ,bn128.F12.toString(r4));
            */

            assert(bn128.F12.eq(r2, r4));


            /*
            const r2 = bn128.millerLoop(pre1b, pre2b);

            const rbe = bn128.F12.mul(r1, bn128.F12.inverse(r2));

            const res = bn128.finalExponentiation(rbe);

            assert(bn128.F12.eq(res, bn128.F12.one));
            */
        }
    });
});

describe("Compressed Form", function() {
    this.timeout(0);

    let bn128;
    before( async() => {
        bn128 = await buildBn128();
    });
    after( async() => {
        bn128.terminate();
    });

    it("Should test rpr of G2", () => {
        const P1 = bn128.G2.fromObject([
            [
                Scalar.e("1b2327ce7815d3358fe89fd8e5695305ed23682db29569f549ab8f48cae1f1c4",16),
                Scalar.e("1ed41ca6b3edc06237af648f845c270ff83bcde333f17863c1b71a43b271b46d",16)
            ],
            [
                Scalar.e("122057912ab892abcf2e729f0f342baea3fe1b484840eb97c7d78cd7530f4ab5",16),
                Scalar.e("2cb317fd40d56eeb17b0c1ff9443661a42ec00cea060012873b3f643f1a5bff8",16)
            ],
            [
                Scalar.one,
                Scalar.zero
            ]
        ]);
        const buff = new Uint8Array(64);
        bn128.G2.toRprCompressed(buff, 0, P1);

        const P2 = bn128.G2.fromRprCompressed(buff, 0);

        /*
        console.log(bn128.G2.toString(P1, 16));
        console.log(bn128.G2.toString(P2, 16));
        */

        assert(bn128.G2.eq(P1,P2));
    });
});



---
File: /@zk-email/helpers/node_modules/ffjavascript/test/bn128.js
---

import assert from "assert";
import buildBn128 from "../src/bn128.js";
import {log2} from "../src/utils.js";
import BigBuffer from "../src/bigbuffer.js";

describe("bn128", async function () {
    this.timeout(0);

    const logger = {
        error: (msg) => { console.log("ERROR: "+msg); },
        warning: (msg) => { console.log("WARNING: "+msg); },
        info: (msg) => { console.log("INFO: "+msg); },
        debug: (msg) => { console.log("DEBUG: "+msg); },
    };

    let bn128;
    before( async() => {
        bn128 = await buildBn128();
        console.log(bn128.Fr.toString(bn128.Fr.w[28]));
    });
    after( async() => {
        bn128.terminate();
    });

    it("It shoud do an inverse FFT in G1", async () => {
        const Fr = bn128.Fr;
        const G1 = bn128.G1;

        const a = [];
        for (let i=0; i<8; i++) a[i] = Fr.e(i+1);

        const aG_expected = [];
        for (let i=0; i<8; i++) aG_expected[i] = G1.timesFr(G1.g, a[i]);

        const A = await bn128.Fr.fft(a);


        const AG = [];
        for (let i=0; i<8; i++) AG[i] = G1.timesFr(G1.g, A[i]);

        const aG_calculated = await G1.ifft(AG, "jacobian", "jacobian");

        for (let i=0; i<8; i++) {
            assert(G1.eq(aG_calculated[i], aG_expected[i]));
        }
    });


    it("It shoud do a big FFT/IFFT in Fr", async () => {
        const Fr = bn128.Fr;

        const N = 1<<10;

        const a = new BigBuffer(N*bn128.Fr.n8);
        for (let i=0; i<N; i++) {
            if (i%100000 == 0) logger.debug(`setup ${i}/${N}`);
            const num = Fr.e(i+1);
            a.set(num, i*bn128.Fr.n8);
        }

        const A = await bn128.Fr.fft(a, "", "", logger, "fft");
        const Ainv = await bn128.Fr.ifft(A, "", "", logger, "ifft");

        for (let i=0; i<N; i++) {
            if (i%100000 == 0) logger.debug(`checking ${i}/${N}`);
            // console.log(Fr.toString(Ainv[i]));
            const num1 = Ainv.slice(i*Fr.n8, i*Fr.n8+Fr.n8);
            const num2 = a.slice(i*Fr.n8, i*Fr.n8+Fr.n8);

            assert(num1, num2);
        }
    });



    it("It shoud do a big FFT/IFFT in Fr", async () => {
        const Fr = bn128.Fr;
        const N = 8192*16;

        const a = [];
        for (let i=0; i<N; i++) a[i] = Fr.e(i+1);

        const A = await bn128.Fr.fft(a);
        const Ainv = await bn128.Fr.ifft(A);

        for (let i=0; i<N; i++) {
//            console.log(Fr.toString(Ainv[i]));
            assert(Fr.eq(a[i], Ainv[i]));
        }
    });


    it("It shoud do a big FFTExt/IFFTExt in Fr", async () => {
        const Fr = bn128.Fr;
        const N = 16;

        const oldS = Fr.s;
        Fr.s = log2(N)-1;   // Force ext

        const a = [];
        for (let i=0; i<N; i++) a[i] = Fr.e(i+1);

        const A = await bn128.Fr.fft(a);
        const Ainv = await bn128.Fr.ifft(A);

        for (let i=0; i<N; i++) {
//            console.log(Fr.toString(Ainv[i]));
            assert(Fr.eq(a[i], Ainv[i]));
        }

        Fr.s = oldS;
    });


    it("It shoud do a big FFT/IFFT in G1", async () => {
        const Fr = bn128.Fr;
        const G1 = bn128.G1;
        const N = 512;

        const a = [];
        for (let i=0; i<N; i++) a[i] = Fr.e(i+1);

        const aG = [];
        for (let i=0; i<N; i++) aG[i] = G1.timesFr(G1.g, a[i]);

        const AG = await G1.fft(aG, "jacobian", "jacobian");
        const AGInv = await G1.ifft(AG, "jacobian", "affine");

        for (let i=0; i<N; i++) {
            assert(G1.eq(aG[i], AGInv[i]));
        }
    });

    it("It shoud do a big FFT/IFFT in G1 ext", async () => {
        const Fr = bn128.Fr;
        const G1 = bn128.G1;
        const N = 1<<13;

        const oldS = Fr.s;
        Fr.s = log2(N)-1;

        const a = [];
        for (let i=0; i<N; i++) a[i] = Fr.e(i+1);

        const aG = [];
        for (let i=0; i<N; i++) aG[i] = G1.timesFr(G1.g, a[i]);

        const AG = await G1.fft(aG, "jacobian", "jacobian");
        const AGInv = await G1.ifft(AG, "jacobian", "affine");

        for (let i=0; i<N; i++) {
            assert(G1.eq(aG[i], AGInv[i]));
        }

        Fr.s = oldS;
    });

    it("It shoud do Multiexp", async () => {
        const Fr = bn128.Fr;
        const G1 = bn128.G1;
        const N = 1 << 10;

        const scalars = new BigBuffer(N*bn128.Fr.n8);
        const bases = new BigBuffer(N*G1.F.n8*2);
        let acc = Fr.zero;
        for (let i=0; i<N; i++) {
            if (i%100000 == 0) logger.debug(`setup ${i}/${N}`);
            const num = Fr.e(i+1);
            scalars.set(Fr.fromMontgomery(num), i*bn128.Fr.n8);
            bases.set(G1.toAffine(G1.timesFr(G1.g, num)), i*G1.F.n8*2);
            acc = Fr.add(acc, Fr.square(num));
        }

        const accG = G1.timesFr(G1.g, acc);
        const accG2 = await G1.multiExpAffine(bases, scalars, logger, "test");

        assert(G1.eq(accG, accG2 ));
    });


});




---
File: /@zk-email/helpers/node_modules/ffjavascript/test/pols.js
---

/*
    Copyright 2018 0kims association.

    This file is part of zksnark JavaScript library.

    zksnark JavaScript library is a free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    zksnark JavaScript library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along with
    zksnark JavaScript library. If not, see <https://www.gnu.org/licenses/>.
*/

import chai from "chai";

import * as Scalar from "../src/scalar.js";
import PolField from "../src/polfield.js";
import ZqField from "../src/f1field.js";

const assert = chai.assert;

const r  = Scalar.fromString("21888242871839275222246405745257275088548364400416034343698204186575808495617");

describe("Polynomial field", () => {
    it("Should compute a multiplication", () => {
        const PF = new PolField(new ZqField(r));

        const a = [PF.F.e(1), PF.F.e(2), PF.F.e(3)];
        const b = [PF.F.e(1), PF.F.e(2), PF.F.e(3)];
        const res = PF.mul(a,b);

        assert(PF.eq(res, [PF.F.e(1), PF.F.e(4), PF.F.e(10), PF.F.e(12), PF.F.e(9)]));
    });
    it("Should compute a multiplication 2", () => {
        const PF = new PolField(new ZqField(r));

        const a = [PF.F.e(5), PF.F.e(1)];
        const b = [PF.F.e(-5), PF.F.e(1)];
        const res = PF.mul(a,b);

        assert(PF.eq(res, [PF.F.e(-25), PF.F.e(0), PF.F.e(1)]));
    });
    it("Should compute an addition", () => {
        const PF = new PolField(new ZqField(r));

        const a = [PF.F.e(5), PF.F.e(1)];
        const b = [PF.F.e(-5), PF.F.e(1)];
        const res = PF.add(a,b);

        assert(PF.eq(res, [PF.F.e(0), PF.F.e(2)]));
    });
    it("Should compute a substraction", () => {
        const PF = new PolField(new ZqField(r));

        const a = [PF.F.e(5), PF.F.e(3), PF.F.e(4)];
        const b = [PF.F.e(5), PF.F.e(1)];
        const res = PF.sub(a,b);

        assert(PF.eq(res, [PF.F.e(0), PF.F.e(2), PF.F.e(4)]));
    });
    it("Should compute reciprocal", () => {
        const PF = new PolField(new ZqField(r));

        const a = PF.normalize([PF.F.e(4), PF.F.e(1), PF.F.e(-3), PF.F.e(-1), PF.F.e(2),PF.F.e(1), PF.F.e(-1), PF.F.e(1)]);
        const res = PF._reciprocal(a, 3, 0);

        assert(PF.eq(res, PF.normalize([PF.F.e(12), PF.F.e(15), PF.F.e(3), PF.F.e(-4), PF.F.e(-3), PF.F.e(0), PF.F.e(1), PF.F.e(1)])));
    });
    it("Should div2", () => {
        const PF = new PolField(new ZqField(r));

        // x^6
        const a = [PF.F.e(0), PF.F.e(0), PF.F.e(0), PF.F.e(0), PF.F.e(0),PF.F.e(0), PF.F.e(1)];
        // x^5
        const b = [PF.F.e(0), PF.F.e(0), PF.F.e(0), PF.F.e(0), PF.F.e(0), PF.F.e(1)];

        const res = PF._div2(6, b);
        assert(PF.eq(res, [PF.F.e(0), PF.F.e(1)]));

        const res2 = PF.div(a,b);
        assert(PF.eq(res2, [PF.F.e(0), PF.F.e(1)]));
    });
    it("Should div", () => {
        const PF = new PolField(new ZqField(r));

        const a = [PF.F.e(1), PF.F.e(2), PF.F.e(3), PF.F.e(4), PF.F.e(5),PF.F.e(6), PF.F.e(7)];
        const b = [PF.F.e(8), PF.F.e(9), PF.F.e(10), PF.F.e(11), PF.F.e(12), PF.F.e(13)];

        const c = PF.mul(a,b);
        const d = PF.div(c,b);

        assert(PF.eq(a, d));
    });
    it("Should div big/small", () => {
        const PF = new PolField(new ZqField(r));

        const a = [PF.F.e(1), PF.F.e(2), PF.F.e(3), PF.F.e(4), PF.F.e(5),PF.F.e(6), PF.F.e(7)];
        const b = [PF.F.e(8), PF.F.e(9)];

        const c = PF.mul(a,b);
        const d = PF.div(c,b);

        assert(PF.eq(a, d));
    });
    it("Should div random big", () => {
        const PF = new PolField(new ZqField(r));

        let a = [];
        let b = [];
        for (let i=0; i<1000; i++) a.push(PF.F.e(Math.floor(Math.random()*100000) -500000));
        for (let i=0; i<900; i++) b.push(PF.F.e(Math.floor(Math.random()*100000) -500000));

        a = PF.normalize(a);
        b = PF.normalize(a);

        const c = PF.mul(a,b);

        const d = PF.div(c,b);

        assert(PF.eq(a, d));
    }).timeout(10000);
    it("Should evaluate and zero", () => {
        const PF = new PolField(new ZqField(r));
        const p = [PF.F.neg(PF.F.e(2)), PF.F.e(1)];
        const v = PF.eval(p, PF.F.e(2));
        assert(PF.F.eq(v, PF.F.e(0)));
    });
    it("Should evaluate bigger number", () => {
        const PF = new PolField(new ZqField(r));
        const p = [PF.F.e(1), PF.F.e(2), PF.F.e(3)];
        const v = PF.eval(p, PF.F.e(2));
        assert(PF.F.eq(v, PF.F.e(17)));
    });
    it("Should create lagrange polynomial minmal", () => {
        const PF = new PolField(new ZqField(r));

        const points=[];
        points.push([PF.F.e(1), PF.F.e(1)]);
        points.push([PF.F.e(2), PF.F.e(2)]);
        points.push([PF.F.e(3), PF.F.e(5)]);

        const p=PF.lagrange(points);

        for (let i=0; i<points.length; i++) {
            const v = PF.eval(p, points[i][0]);
            assert(PF.F.eq(v, points[i][1]));
        }
    });
    it("Should create lagrange polynomial", () => {
        const PF = new PolField(new ZqField(r));

        const points=[];
        points.push([PF.F.e(1), PF.F.e(2)]);
        points.push([PF.F.e(2), PF.F.e(-2)]);
        points.push([PF.F.e(3), PF.F.e(0)]);
        points.push([PF.F.e(4), PF.F.e(453345)]);

        const p=PF.lagrange(points);

        for (let i=0; i<points.length; i++) {
            const v = PF.eval(p, points[i][0]);
            assert(PF.F.eq(v, points[i][1]));
        }
    });
    it("Should test ruffini", () => {
        const PF = new PolField(new ZqField(r));
        const a = [PF.F.e(1), PF.F.e(2), PF.F.e(3), PF.F.e(4), PF.F.e(5),PF.F.e(6), PF.F.e(7)];

        const b = PF.mul(a, [PF.F.e(-7), PF.F.e(1)]);
        const c = PF.ruffini(b, PF.F.e(7));

        assert(PF.eq(a, c));
    });
    it("Should test roots", () => {
        const PF = new PolField(new ZqField(r));
        let rt;


        rt = PF.oneRoot(256, 16);
        for (let i=0; i<8; i++) {
            rt = PF.F.mul(rt, rt);
        }
        assert(PF.F.eq(rt, PF.F.one));

        rt = PF.oneRoot(256, 15);
        for (let i=0; i<8; i++) {
            rt = PF.F.mul(rt, rt);
        }
        assert(PF.F.eq(rt, PF.F.one));

        rt = PF.oneRoot(8, 3);
        for (let i=0; i<3; i++) {
            rt = PF.F.mul(rt, rt);
        }
        assert(PF.F.eq(rt, PF.F.one));

        rt = PF.oneRoot(8, 0);
        assert(PF.F.eq(rt, PF.F.one));

    });
    it("Should create a polynomial with values at roots with fft", () => {
        const PF = new PolField(new ZqField(r));
        const a = [PF.F.e(1), PF.F.e(2), PF.F.e(3), PF.F.e(4), PF.F.e(5),PF.F.e(6), PF.F.e(7)];

        const p = PF.ifft(a);

        for (let i=0; i<a.length; i++) {
            const s = PF.eval(p, PF.oneRoot(8,i));
            assert(PF.F.eq(s, a[i]));
        }

    });

});



---
File: /@zk-email/helpers/node_modules/ffjavascript/test/ratzqfield.js
---

/*
    Copyright 2018 0kims association.

    This file is part of zksnark JavaScript library.

    zksnark JavaScript library is a free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    zksnark JavaScript library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along with
    zksnark JavaScript library. If not, see <https://www.gnu.org/licenses/>.
*/

import chai from "chai";

import * as Scalar from "../src/scalar.js";
import ZqField from "../src/f1field.js";
import RatField from "../src/ratfield.js";

const q  = Scalar.fromString("21888242871839275222246405745257275088548364400416034343698204186575808495617");
const Z = new ZqField(q);
const R = new RatField(Z);

const assert = chai.assert;

function r(a,b) {
    return [Z.e(a), Z.e(b)];
}


describe("Rational zq Field", () => {
    it("Should compare correctly", () => {
        assert( R.eq(r(3,5), r(6,10)));
        assert(!R.eq(r(3,5), r(6,11)));
    });
    it("Should add correctly", () => {
        const a = r(7,4);
        const b = r(5,12);

        assert(R.eq( R.add(a,b), r(13, 6)));
    });
    it("Should substract", () => {
        const a = r(7,4);
        const b = r(5,12);

        assert(R.eq( R.sub(a,b), r(4, 3)));
    });
    it("Should multiply", () => {
        const a = r(7,4);
        const b = r(5,12);

        assert(R.eq( R.mul(a,b), r(35, 48)));
    });
    it("Should div", () => {
        const a = r(7,4);
        const b = r(5,12);

        assert(R.eq( R.div(a,b), r(7*12, 5*4)));
    });
    it("Should square", () => {
        const a = r(7,4);

        assert(R.eq( R.square(a), r(49, 16)));
    });
    it("Should affine", () => {
        const a = r(12,4);
        const aa = R.affine(a);
        assert(Z.eq( aa[0], Z.e(3)));
        assert(Z.eq( aa[1], Z.one));
    });
    it("Should convert from Z to R", () => {
        const vz = Z.e(34);
        const vr = R.fromF(vz);

        assert(R.eq( vr, r(34,1)));
    });
    it("Should convert from R to Z", () => {
        const vr = r(32, 2);
        const vz = R.toF(vr);

        assert(Z.eq( vz, Z.e(16)));
    });
});



---
File: /@zk-email/helpers/node_modules/ffjavascript/test/scalar.js
---

import assert from "assert";

import * as Scalar from "../src/scalar.js";

describe("Basic scalar convertions", () => {
    it("Should convertion Native", () => {
        assert(Scalar.eq(Scalar.e("0x12"), 18));
        assert(Scalar.eq(Scalar.e("0x12", 16), 18));
        assert(Scalar.eq(Scalar.e("12", 16), 18));
        assert(Scalar.eq(Scalar.e("18"), 18));
        assert(Scalar.eq(Scalar.e("18", 10), 18));
        assert(Scalar.eq(Scalar.e(18, 10), 18));
        assert(Scalar.eq(Scalar.e(18n, 10), 18));
        assert(Scalar.eq(Scalar.e(0x12, 10), 18));
        assert(Scalar.eq(Scalar.e(0x12n, 10), 18));

    });
    it("Should convert to js Number Native", () => {
        const maxJsNum = Number.MAX_SAFE_INTEGER;
        const maxToScalar = Scalar.e(maxJsNum);

        const backToNum = Scalar.toNumber(maxToScalar);
        assert(backToNum, maxJsNum);

        const overMaxJsNum = Scalar.add(maxToScalar, 1);
        assert.throws(() => Scalar.toNumber(overMaxJsNum));
    });
});



---
File: /@zk-email/helpers/node_modules/ffjavascript/test/sqrt.js
---

/*
    Copyright 2018 0kims association.

    This file is part of zksnark JavaScript library.

    zksnark JavaScript library is a free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    zksnark JavaScript library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along with
    zksnark JavaScript library. If not, see <https://www.gnu.org/licenses/>.
*/

import chai from "chai";

import * as Scalar from "../src/scalar.js";
import buildBn128 from "../src/bn128.js";
import F1Field from "../src/f1field.js";

const assert = chai.assert;


describe("Sqrt testing", () => {
    let bn128;
    before( async() => {
        bn128 = await buildBn128();
    });
    after( async() => {
        bn128.terminate();
    });

    /*
    it("Should compute sqrts", () => {
        const F = new F1Field(bn128.r);
        const a = F.e(2);
        const b = F.sqrt_v(a);
        console.log(F.toString(b));
    });
    */
    it("Should compute basic sqrts", () => {
        const F = new F1Field(bn128.r);
        assert(F.eq(F.e(0), F.sqrt(F.e("0"))));
        const a = F.e("9");
        let b = F.sqrt(a);
        assert(F.eq(b, F.e("3")));
        assert(F.sqrt(F.sqrt_z) === null);
    });
    it("Should compute sqrt p%4 = 1", () => {
        const F = new F1Field(bn128.r);
        const e = Scalar.div(Scalar.pow(F.p, F.m), 2);
        for (let i=0; i<100; i++) {
            const x2 = F.random();
            const x = F.sqrt(x2);
            if (x==null) {
                assert(F.eq( F.pow(x2, e), F.negone));
            } else {
                assert(F.eq(F.square(x), x2));
            }
        }
    });
    it("Should compute sqrt p%4 = 3", () => {
        const F = new F1Field(bn128.q);
        const e = Scalar.div(Scalar.pow(F.p, F.m), 2);
        for (let i=0; i<100; i++) {
            const x2 = F.random();
            const x = F.sqrt(x2);
            if (x==null) {
                assert(F.eq( F.pow(x2, e), F.negone));
            } else {
                assert(F.eq(F.square(x), x2));
            }
        }
    });
    it("Should compute sqrt m=2 p%4 = 3", () => {
        const F = bn128.F2;
        const e = Scalar.div(Scalar.exp(F.F.p, F.m), 2);
        for (let i=0; i<100; i++) {
            const x2 = F.random();
            if (!F.isSquare(x2)) {
                assert(F.eq( F.exp(x2, e), F.negone));
            } else {
                const x = F.sqrt(x2);
                assert(F.eq(F.square(x), x2));
            }
        }
    });

});




---
File: /@zk-email/helpers/node_modules/ffjavascript/test/utils.js
---

import assert from "assert";

import * as ScalarN from "../src/scalar.js";

import * as utilsN from "../src/utils.js";

describe("Utils native", () => {
    const num = ScalarN.e("21888242871839275222246405745257275088614511777268538073601725287587578984328");

    it("Should convert integer to buffer little-endian", () => {
        const buff = utilsN.leInt2Buff(num, 32);
        const numFromBuff = utilsN.leBuff2int(buff);

        assert(ScalarN.eq(num, numFromBuff), true);
    });

    it("Should convert integer to buffer big-endian", () => {
        const buff = utilsN.beInt2Buff(num, 32);
        const numFromBuff = utilsN.beBuff2int(buff);

        assert(ScalarN.eq(num, numFromBuff), true);
    });

    it("Should stringify bigInt", () => {
        const str = utilsN.stringifyBigInts(num);
        const numFromStr = utilsN.unstringifyBigInts(str);

        assert(ScalarN.eq(num, numFromStr), true);
    });
});


---
File: /@zk-email/helpers/node_modules/ffjavascript/test/zqfield.js
---

import ZqField from "../src/f1field.js";
import * as Scalar from "../src/scalar.js";
import assert from "assert";

const q = Scalar.fromString("21888242871839275222246405745257275088696311157297823662689037894645226208583");
const r = Scalar.fromString("21888242871839275222246405745257275088548364400416034343698204186575808495617");

describe("F1 testing", () => {
    it("Should compute euclidean", () => {
        const F = new ZqField(7);
        const res = F.inv(F.e(4));

        assert(F.eq(res,F.e(2)));
    });

    it("Should multiply and divide in F1", () => {
        const F = new ZqField(q);
        const a = F.e("1");
        const b = F.normalize(-3);
        const c = F.mul(a,b);
        const d = F.div(c,b);

        assert(F.eq(a, d));
    });

    it("Should compute sqrts", () => {
        const F = new ZqField(q);
        const a = F.e("4");
        let b = F.sqrt(a);
        assert(F.eq(F.e(0), F.sqrt(F.e("0"))));
        assert(F.eq(b, F.e("2")));
        assert(F.sqrt(F.nqr) === null);
    });

    it("Should compute sqrt of 100 random numbers", () => {
        const F = new ZqField(r);
        for (let j=0;j<100; j++) {
            let a = F.random();
            let s = F.sqrt(a);
            if (s != null) {
                assert(F.eq(F.square(s), a));
            }
        }
    });
});



---
File: /@zk-email/helpers/node_modules/ffjavascript/main.js
---


import * as _Scalar  from "./src/scalar.js";
export const Scalar=_Scalar;

export {default as PolField} from "./src/polfield.js";
export {default as F1Field} from "./src/f1field.js";
export {default as F2Field} from "./src/f2field.js";
export {default as F3Field} from "./src/f3field.js";

export {default as ZqField} from "./src/f1field.js";

export {default as EC} from "./src/ec.js";

export {default as buildBn128} from "./src/bn128.js";
export {default as buildBls12381} from "./src/bls12381.js";

import * as _utils from "./src/utils.js";
export const utils = _utils;
export {default as ChaCha} from "./src/chacha.js";

export {default as BigBuffer} from "./src/bigbuffer.js";

export {getCurveFromR, getCurveFromQ, getCurveFromName} from "./src/curves.js";




---
File: /@zk-email/helpers/node_modules/ffjavascript/rollup.cjs.config.js
---

import fs from "fs";
import { builtinModules as builtin } from "module";

const pkg = JSON.parse(fs.readFileSync("./package.json"));

export default {
    input: "main.js",
    output: {
        file: "build/main.cjs",
        format: "cjs",
    },
    external: [
        ...Object.keys(pkg.dependencies),
        ...builtin,
    ]
};



---
File: /@zk-email/helpers/node_modules/ffjavascript/test.js
---


const bn128 = require("./index").bn128;
const utils = require("./index").utils;

const Fq = bn128.F1;

const blake2b = require("blake2b");

const ChaCha = require("./src/chacha");

const pubKey = {
    tau_g1_s: [
        Fq.e("0x1403cf4fed293e66a8cd522be9f938524111f6f08762371bff53ee387a39cf13"),
        Fq.e("0x2accbda355c222301a1bd802db7454d86a4ec2ee89ae895ca21f147d6b705740"),
        Fq.e("1")
    ],
    tau_g1_sx: [
        Fq.e("0x12996cf89d854246f1ab002e446436b77a64349117ec1fb2aa57a304890e81ef"),
        Fq.e("0x0c17fd067df52c480a1db3c6890821f975932d89d0d53c6c60777cc56f1dd712"),
        Fq.e("1")
    ],
    alpha_g1_s:[
        Fq.e("0x12a64bbe8af7fcb19052e25e188c1fcdac454928142f8e89f58e03249e18b223"),
        Fq.e("0x22be31a388d0ec551530e1b1581b671b4340e88990de805a7bfed8bdb9c1accd"),
        Fq.e("1")
    ],
    alpha_g1_sx: [
        Fq.e("0x262ff8dd594374c6ed5e892ba31315f6e47c500784a12ea8d2c573730888a392"),
        Fq.e("0x0b3a94f2b61178f2974e039cfd671e7405ec43eb2c09dc8f43a34f450917a62f"),
        Fq.e("1")
    ],
    beta_g1_s: [
        Fq.e("0x0d9b3088b69daf6746c6bba4f9b359234abbfd3306bce14b198e7a5556c777e6"),
        Fq.e("0x066d1acac914883df6a9dc57dc2037a481ba4b8646efe13e2584b9258bd52d0c"),
        Fq.e("1")
    ],
    beta_g1_sx: [
        Fq.e("0x248232878c359dbe632c387dc0d955520e8d3363f1cd9621ec9fd4a05460c754"),
        Fq.e("0x12074f06ef232a472cb36c328e760c4acfb4bedad4ca3ee09971578a0fe185ab"),
        Fq.e("1")
    ],
    tau_g2_spx: [
        [
            Fq.e("0x0fe02fcc3aee51c1f3a37f3f152ebe5476ae659468f2ee81cdeb19d0dad366c5"),
            Fq.e("0x01aeb4db892bcb273aada80f5eab10e2e50ae59a5c274b0d7303f5c5a52ee88b"),
        ],[
            Fq.e("0x2d00022d840d493fb93c68a63b29e2692c0cd3caf354fe60eae1ebacefc2c948"),
            Fq.e("0x204065ff10344153a08cfe4ae543c47fba883ef8a54530fa6a52c87e5c28ef2b"),
        ],[
            Fq.e("1"),
            Fq.e("0")
        ]
    ],
    alpha_g2_spx: [
        [
            Fq.e("0x2e649d01a58a7795762df8f0634c273ebce6950a9a2ba3d4459458620d3164a0"),
            Fq.e("0x1b58044d3e205a918124fea3983583199b4f99fd0abb39ede2c684b0810bdc1e"),
        ],[
            Fq.e("0x021d41558cea5fa32c9f3de5834cb2ee45ce4cdf471353395d019dfe0c9c2509"),
            Fq.e("0x1c04148bac3f17b219c2655cd63ad2596ea63293103487be488a1d5a9054ddbf"),
        ],[
            Fq.e("1"),
            Fq.e("0")
        ]
    ],
    beta_g2_spx: [
        [
            Fq.e("0x029251aed5163109667300035ce200b7195fc6e261581ba38776d87d7f0b1a7d"),
            Fq.e("0x09d6847f1b945ccdc00418a807f4b0af67ec5c0030c4f203581eff9d4af4347f"),
        ],[
            Fq.e("0x04b62ecdc94bf94fcefdf93f06ca4f63026a47a0d4138941b8ee45b9f7177e5c"),
            Fq.e("0x1f0a6bff3945f207f407ff1c813b66a28b495f55a3788c3e200c74817e86f7ce"),
        ],[
            Fq.e("1"),
            Fq.e("0")
        ]
    ]
};


const challange = Buffer.from(
    "bc0bde7980381fa642b2097591dd83f1"+
    "ed15b003e15c35520af32c95eb519149"+
    "2a6f3175215635cfc10e6098e2c612d0"+
    "ca84f1a9f90b5333560c8af59b9209f4", "hex");

function getG2sp(persinalization, challange, g1s, g1sx) {

    const h = blake2b(64);
    h.update(Buffer.from([persinalization]));
    h.update(challange);
    h.update( utils.beInt2Buff(g1s[0],32));
    h.update( utils.beInt2Buff(g1s[1],32));
    h.update( utils.beInt2Buff(g1sx[0],32));
    h.update( utils.beInt2Buff(g1sx[1],32));
    const hash = Buffer.from(h.digest());

    const seed = [];
    for (let i=0; i<8; i++) {
        seed[i] = hash.readUInt32BE(i*4);
    }

    const rng = new ChaCha(seed);

    const g2_sp = bn128.G2.fromRng(rng);

    return g2_sp;

}

const tau_g2_sp = getG2sp(0, challange, pubKey.tau_g1_s, pubKey.tau_g1_sx);
if (bn128.F12.eq(
    bn128.pairing(pubKey.tau_g1_sx,tau_g2_sp),
    bn128.pairing(pubKey.tau_g1_s, pubKey.tau_g2_spx))) {
    console.log("Key tau matches!!");
} else {
    console.log("ERROR Key tau does not match!!");
}

const alpha_g2_sp = getG2sp(1, challange, pubKey.alpha_g1_s, pubKey.alpha_g1_sx);
if (bn128.F12.eq(
    bn128.pairing(pubKey.alpha_g1_sx,        alpha_g2_sp),
    bn128.pairing(pubKey.alpha_g1_s , pubKey.alpha_g2_spx))) {
    console.log("Key alfa matches!!");
} else {
    console.log("ERROR Alfa tau does not match!!");
}

const beta_g2_sp = getG2sp(2, challange, pubKey.beta_g1_s, pubKey.beta_g1_sx);
if (bn128.F12.eq(
    bn128.pairing(pubKey.beta_g1_sx,        beta_g2_sp),
    bn128.pairing(pubKey.beta_g1_s , pubKey.beta_g2_spx))) {
    console.log("Key beta matches!!");
} else {
    console.log("ERROR Beta tau does not match!!");
}




---
File: /@zk-email/helpers/node_modules/r1csfile/src/r1csfile.js
---

import {F1Field, getCurveFromR} from "ffjavascript";
import  BigArray from "@iden3/bigarray";
import * as binFileUtils from "@iden3/binfileutils";

export const R1CS_FILE_HEADER_SECTION = 1;
export const R1CS_FILE_CONSTRAINTS_SECTION = 2;
export const R1CS_FILE_WIRE2LABELID_SECTION = 3;
export const R1CS_FILE_CUSTOM_GATES_LIST_SECTION = 4;
export const R1CS_FILE_CUSTOM_GATES_USES_SECTION = 5;

export async function readR1csHeader(fd,sections,singleThread) {
    let options;
    if (typeof singleThread === "object") {
        options = singleThread;
    } else if (typeof singleThread === "undefined") {
        options= {
            singleThread: false,
        };
    } else {
        options = {
            singleThread: singleThread,
        };
    }

    const res = {};
    await binFileUtils.startReadUniqueSection(fd, sections, 1);
    // Read Header
    res.n8 = await fd.readULE32();
    res.prime = await binFileUtils.readBigInt(fd, res.n8);

    if (options.F) {
        if (options.F.p != res.prime) throw new Error("Different Prime");
        res.F = options.F;
    } else if (options.getFieldFromPrime) {
        res.F = await options.getFieldFromPrime(res.prime, options.singleThread);
    } else if (options.getCurveFromPrime) {
        res.curve = await options.getCurveFromPrime(res.prime, options.singleThread);
        res.F = res.curve.Fr;
    } else {
        try {
            res.curve = await getCurveFromR(res.prime, options.singleThread);
            res.F = res.curve.Fr;
        } catch (err) {
            res.F = new F1Field(res.prime);
        }
    }

    res.nVars = await fd.readULE32();
    res.nOutputs = await fd.readULE32();
    res.nPubInputs = await fd.readULE32();
    res.nPrvInputs = await fd.readULE32();
    res.nLabels = await fd.readULE64();
    res.nConstraints = await fd.readULE32();
    res.useCustomGates = typeof sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== "undefined" && sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== null
        && typeof sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== "undefined" && sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== null;

    await binFileUtils.endReadSection(fd);

    return res;
}

export async function readConstraints(fd,sections, r1cs, logger, loggerCtx) {
    let options;
    if (typeof logger === "object") {
        options = logger;
    } else if (typeof logger === "undefined") {
        options= {};
    } else {
        options = {
            logger: logger,
            loggerCtx: loggerCtx,
        };
    }

    const bR1cs = await binFileUtils.readSection(fd, sections, 2);
    let bR1csPos = 0;
    let constraints;
    if (r1cs.nConstraints>1<<20) {
        constraints = new BigArray();
    } else {
        constraints = [];
    }
    for (let i=0; i<r1cs.nConstraints; i++) {
        if ((options.logger)&&(i%100000 == 0)) options.logger.info(`${options.loggerCtx}: Loading constraints: ${i}/${r1cs.nConstraints}`);
        const c = readConstraint();
        constraints.push(c);
    }
    return constraints;


    function readConstraint() {
        const c = [];
        c[0] = readLC();
        c[1] = readLC();
        c[2] = readLC();
        return c;
    }

    function readLC() {
        const lc= {};

        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos+4);
        bR1csPos += 4;
        const buffUL32V = new DataView(buffUL32.buffer);
        const nIdx = buffUL32V.getUint32(0, true);

        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4+r1cs.n8)*nIdx );
        bR1csPos += (4+r1cs.n8)*nIdx;
        const buffV = new DataView(buff.buffer);
        for (let i=0; i<nIdx; i++) {
            const idx = buffV.getUint32(i*(4+r1cs.n8), true);
            const val = r1cs.F.fromRprLE(buff, i*(4+r1cs.n8)+4);
            lc[idx] = val;
        }
        return lc;
    }
}

export async function readMap(fd, sections, r1cs, logger, loggerCtx) {
    let options;
    if (typeof logger === "object") {
        options = logger;
    } else if (typeof logger === "undefined") {
        options= {};
    } else {
        options = {
            logger: logger,
            loggerCtx: loggerCtx,
        };
    }
    const bMap = await binFileUtils.readSection(fd, sections, 3);
    let bMapPos = 0;
    let map;

    if (r1cs.nVars>1<<20) {
        map = new BigArray();
    } else {
        map = [];
    }
    for (let i=0; i<r1cs.nVars; i++) {
        if ((options.logger)&&(i%10000 == 0)) options.logger.info(`${options.loggerCtx}: Loading map: ${i}/${r1cs.nVars}`);
        const idx = readULE64();
        map.push(idx);
    }

    return map;

    function readULE64() {
        const buffULE64 = bMap.slice(bMapPos, bMapPos+8);
        bMapPos += 8;
        const buffULE64V = new DataView(buffULE64.buffer);
        const LSB = buffULE64V.getUint32(0, true);
        const MSB = buffULE64V.getUint32(4, true);

        return MSB * 0x100000000 + LSB;
    }

}

export async function readR1csFd(fd, sections, options) {
    /**
     * Options properties:
     *  loadConstraints: <bool> true by default
     *  loadMap:         <bool> false by default
     *  loadCustomGates: <bool> true by default
     */

    if(typeof options !== "object") {
        throw new Error("readR1csFd: options must be an object");
    }

    options.loadConstraints = options.loadConstraints || true;
    options.loadMap = options.loadMap || false;
    options.loadCustomGates = options.loadCustomGates || true;

    const res = await readR1csHeader(fd, sections, options);

    if (options.loadConstraints) {
        res.constraints = await readConstraints(fd, sections, res, options);
    }

    // Read Labels

    if (options.loadMap) {
        res.map = await readMap(fd, sections, res, options);
    }

    if (options.loadCustomGates) {
        if (res.useCustomGates) {
            res.customGates = await readCustomGatesListSection(fd, sections, res.F.n8);
            res.customGatesUses = await readCustomGatesUsesSection(fd, sections, options);
        } else {
            res.customGates = [];
            res.customGatesUses = [];
        }
    }
    return res;
}

export async function readR1cs(fileName, loadConstraints, loadMap, singleThread, logger, loggerCtx) {
    let options;
    if (typeof loadConstraints === "object") {
        options = loadConstraints;
    } else if (typeof loadConstraints === "undefined") {
        options= {
            loadConstraints: true,
            loadMap: false,
            loadCustomGates: true
        };
    } else {
        options = {
            loadConstraints: loadConstraints,
            loadMap: loadMap,
            singleThread: singleThread,
            logger: logger,
            loggerCtx: loggerCtx
        };
    }

    const {fd, sections} = await binFileUtils.readBinFile(fileName, "r1cs", 1, 1<<25, 1<<22);

    const res = await readR1csFd(fd, sections, options);

    await fd.close();

    return res;
}

export async function readCustomGatesListSection(fd, sections, fieldSize) {
    await binFileUtils.startReadUniqueSection(fd, sections, R1CS_FILE_CUSTOM_GATES_LIST_SECTION);

    let num = await fd.readULE32();

    let customGates = [];
    for (let i = 0; i < num; i++) {
        let customGate = {};
        customGate.templateName = await fd.readString();
        let numParameters = await fd.readULE32();

        customGate.parameters = Array(numParameters);
        let buff = await fd.read(fieldSize * numParameters);

        for (let j = 0; j < numParameters; j++) {
            customGate.parameters[j] = buff.slice(j * fieldSize, j * fieldSize + fieldSize);
        }
        customGates.push(customGate);
    }
    await binFileUtils.endReadSection(fd);

    return customGates;
}

export async function readCustomGatesUsesSection(fd,sections, options) {
    const bR1cs = await binFileUtils.readSection(fd, sections, R1CS_FILE_CUSTOM_GATES_USES_SECTION);
    const bR1cs32 = new Uint32Array(bR1cs.buffer, bR1cs.byteOffset, bR1cs.byteLength/4);
    const nCustomGateUses = bR1cs32[0];
    let bR1csPos = 1;
    let customGatesUses;
    if (nCustomGateUses>1<<20) {
        customGatesUses = new BigArray();
    } else {
        customGatesUses = [];
    }
    for (let i=0; i<nCustomGateUses; i++) {
        if ((options.logger)&&(i%100000 == 0)) options.logger.info(`${options.loggerCtx}: Loading custom gate uses: ${i}/${nCustomGateUses}`);
        let c = {};
        c.id = bR1cs32[bR1csPos++];
        let numSignals = bR1cs32[bR1csPos++];
        c.signals = [];
        for (let j = 0; j < numSignals; j++) {
            const LSB = bR1cs32[bR1csPos++];
            const MSB = bR1cs32[bR1csPos++];
            c.signals.push(MSB * 0x100000000 + LSB);
        }
        customGatesUses.push(c);
    }
    return customGatesUses;
}

export async function writeR1csHeader(fd, cir) {
    await binFileUtils.startWriteSection(fd, 1);
    await fd.writeULE32(cir.n8); // Temporally set to 0 length
    await binFileUtils.writeBigInt(fd, cir.prime, cir.n8);

    await fd.writeULE32(cir.nVars);
    await fd.writeULE32(cir.nOutputs);
    await fd.writeULE32(cir.nPubInputs);
    await fd.writeULE32(cir.nPrvInputs);
    await fd.writeULE64(cir.nLabels);
    await fd.writeULE32(cir.constraints.length);

    await binFileUtils.endWriteSection(fd);
}

export async function writeR1csConstraints(fd, cir, logger, loggerCtx) {
    await binFileUtils.startWriteSection(fd, 2);

    for (let i=0; i<cir.constraints.length; i++) {
        if ((logger)&&(i%10000 == 0)) logger.info(`${loggerCtx}: writing constraint: ${i}/${cir.constraints.length}`);
        await writeConstraint(cir.constraints[i]);
    }

    await binFileUtils.endWriteSection(fd);


    function writeConstraint(c) {
        const n8 = cir.n8;
        const F = cir.F || cir.curve.Fr;
        const idxA = Object.keys(c[0]);
        const idxB = Object.keys(c[1]);
        const idxC = Object.keys(c[2]);
        const buff = new Uint8Array((idxA.length+idxB.length+idxC.length)*(n8+4) + 12);
        const buffV = new DataView(buff.buffer);
        let o=0;

        buffV.setUint32(o, idxA.length, true); o+=4;
        for (let i=0; i<idxA.length; i++) {
            const coef = idxA[i];
            buffV.setUint32(o, coef, true); o+=4;
            F.toRprLE(buff, o, c[0][coef]); o+=n8;
        }

        buffV.setUint32(o, idxB.length, true); o+=4;
        for (let i=0; i<idxB.length; i++) {
            const coef = idxB[i];
            buffV.setUint32(o, coef, true); o+=4;
            F.toRprLE(buff, o, c[1][coef]); o+=n8;
        }

        buffV.setUint32(o, idxC.length, true); o+=4;
        for (let i=0; i<idxC.length; i++) {
            const coef = idxC[i];
            buffV.setUint32(o, coef, true); o+=4;
            F.toRprLE(buff, o, c[2][coef]); o+=n8;
        }

        return fd.write(buff);
    }

}


export async function writeR1csMap(fd, cir, logger, loggerCtx) {
    await binFileUtils.startWriteSection(fd, 3);

    if (cir.map.length != cir.nVars) throw new Error("Invalid map size");
    for (let i=0; i<cir.nVars; i++) {
        if ((logger)&&(i%10000 == 0)) logger.info(`${loggerCtx}: writing map: ${i}/${cir.nVars}`);
        await fd.writeULE64(cir.map[i]);
    }

    await binFileUtils.endWriteSection(fd);
}



export async function writeR1cs(fileName, cir, logger, loggerCtx) {

    const fd = await binFileUtils.createBinFile(fileName, "r1cs", 1, 3, 1<<25, 1<<22);

    await writeR1csHeader(fd, cir);

    await writeR1csConstraints(fd, cir, logger, loggerCtx);

    await writeR1csMap(fd, cir, logger, loggerCtx);

    await fd.close();
}



---
File: /@zk-email/helpers/node_modules/r1csfile/test/r1csfile_cg.test.js
---

import path from "path";
import assert from "assert";
import {readR1cs} from "../src/r1csfile.js";

const cgList = [
    {
        "templateName": "RANGE_CHECK",
        "parameters": [10, 20]
    },
    {
        "templateName": "POSEIDON_HASH",
        "parameters": [5, 6]
    },
];

const cgUses = [
    {
        "id": 0,
        "signals": [6, 7]
    },
    {
        "id": 0,
        "signals": [8, 9]
    },
    {
        "id": 1,
        "signals": [4, 5, 6]
    },
];

describe("Parse R1CS Custom Gates Sections file", function () {

    it("Parse R1CS Custom Gates example file", async () => {
        let fileName = path.join("test", "testutils", "circuitCG.r1cs");
        const cir = await readR1cs(fileName, {loadCustomGates: true});

