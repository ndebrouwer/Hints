Directory Structure:

└── ./
    └── @zk-email
        ├── circuits
        │   ├── helpers
        │   │   ├── email-nullifier.circom
        │   │   ├── remove-soft-line-breaks.circom
        │   │   └── reveal-substring.circom
        │   ├── lib
        │   │   ├── base64.circom
        │   │   ├── bigint-func.circom
        │   │   ├── bigint.circom
        │   │   ├── fp.circom
        │   │   ├── rsa.circom
        │   │   └── sha.circom
        │   ├── utils
        │   │   ├── array.circom
        │   │   ├── bytes.circom
        │   │   ├── constants.circom
        │   │   ├── functions.circom
        │   │   ├── hash.circom
        │   │   └── regex.circom
        │   ├── email-verifier.circom
        │   ├── package.json
        │   └── README.md
        ├── helpers
        │   ├── dist
        │   │   ├── dkim
        │   │   │   ├── dns-archive.d.ts
        │   │   │   ├── dns-archive.js
        │   │   │   ├── dns-over-http.d.ts
        │   │   │   ├── dns-over-http.js
        │   │   │   ├── index.d.ts
        │   │   │   ├── index.js
        │   │   │   ├── sanitizers.d.ts
        │   │   │   └── sanitizers.js
        │   │   ├── lib
        │   │   │   ├── mailauth
        │   │   │   │   ├── body
        │   │   │   │   │   ├── index.d.ts
        │   │   │   │   │   ├── index.js
        │   │   │   │   │   ├── relaxed.d.ts
        │   │   │   │   │   ├── relaxed.js
        │   │   │   │   │   ├── simple.d.ts
        │   │   │   │   │   └── simple.js
        │   │   │   │   ├── header
        │   │   │   │   │   ├── index.d.ts
        │   │   │   │   │   ├── index.js
        │   │   │   │   │   ├── relaxed.d.ts
        │   │   │   │   │   ├── relaxed.js
        │   │   │   │   │   ├── simple.d.ts
        │   │   │   │   │   └── simple.js
        │   │   │   │   ├── dkim-verifier.d.ts
        │   │   │   │   ├── dkim-verifier.js
        │   │   │   │   ├── message-parser.d.ts
        │   │   │   │   ├── message-parser.js
        │   │   │   │   ├── parse-dkim-headers.d.ts
        │   │   │   │   ├── parse-dkim-headers.js
        │   │   │   │   ├── tools.d.ts
        │   │   │   │   └── tools.js
        │   │   │   ├── fast-sha256.d.ts
        │   │   │   └── fast-sha256.js
        │   │   ├── binary-format.d.ts
        │   │   ├── binary-format.js
        │   │   ├── chunked-zkey.d.ts
        │   │   ├── chunked-zkey.js
        │   │   ├── constants.d.ts
        │   │   ├── constants.js
        │   │   ├── hash.d.ts
        │   │   ├── hash.js
        │   │   ├── index.d.ts
        │   │   ├── index.js
        │   │   ├── input-generators.d.ts
        │   │   ├── input-generators.js
        │   │   ├── sha-utils.d.ts
        │   │   └── sha-utils.js
        │   ├── node_modules
        │   │   ├── @iden3
        │   │   │   └── binfileutils
        │   │   │       ├── src
        │   │   │       │   └── binfileutils.js
        │   │   │       └── rollup.cjs.config.js
        │   │   ├── circom_runtime
        │   │   │   ├── c
        │   │   │   │   ├── old
        │   │   │   │   │   ├── buildasm
        │   │   │   │   │   │   ├── old
        │   │   │   │   │   │   │   ├── buildfieldasm.js
        │   │   │   │   │   │   │   ├── buildzqfield.js
        │   │   │   │   │   │   │   └── buildzqfieldtester.js
        │   │   │   │   │   │   ├── buildzqfield.js
        │   │   │   │   │   │   ├── buildzqfieldtester.js
        │   │   │   │   │   │   └── tester.cpp
        │   │   │   │   │   ├── mainjson.cpp
        │   │   │   │   │   └── zqfield.cpp
        │   │   │   │   ├── calcwit.cpp
        │   │   │   │   ├── main.cpp
        │   │   │   │   └── utils.cpp
        │   │   │   ├── js
        │   │   │   │   ├── utils.js
        │   │   │   │   └── witness_calculator.js
        │   │   │   ├── .eslintrc.js
        │   │   │   ├── calcwit.js
        │   │   │   ├── main.js
        │   │   │   └── rollup.cjs.config.js
        │   │   ├── ffjavascript
        │   │   │   ├── src
        │   │   │   │   ├── bigbuffer.js
        │   │   │   │   ├── bls12381.js
        │   │   │   │   ├── bn128.js
        │   │   │   │   ├── chacha.js
        │   │   │   │   ├── curves.js
        │   │   │   │   ├── ec.js
        │   │   │   │   ├── engine_applykey.js
        │   │   │   │   ├── engine_batchconvert.js
        │   │   │   │   ├── engine_fft.js
        │   │   │   │   ├── engine_multiexp.js
        │   │   │   │   ├── engine_pairing.js
        │   │   │   │   ├── engine.js
        │   │   │   │   ├── f1field.js
        │   │   │   │   ├── f2field.js
        │   │   │   │   ├── f3field.js
        │   │   │   │   ├── fft.js
        │   │   │   │   ├── fsqrt.js
        │   │   │   │   ├── futils.js
        │   │   │   │   ├── polfield.js
        │   │   │   │   ├── random.js
        │   │   │   │   ├── ratfield.js
        │   │   │   │   ├── scalar.js
        │   │   │   │   ├── threadman_thread.js
        │   │   │   │   ├── threadman.js
        │   │   │   │   ├── utils.js
        │   │   │   │   ├── wasm_curve.js
        │   │   │   │   ├── wasm_field1.js
        │   │   │   │   ├── wasm_field2.js
        │   │   │   │   └── wasm_field3.js
        │   │   │   ├── test
        │   │   │   │   ├── algebra.js
        │   │   │   │   ├── bn128.js
        │   │   │   │   ├── pols.js
        │   │   │   │   ├── ratzqfield.js
        │   │   │   │   ├── scalar.js
        │   │   │   │   ├── sqrt.js
        │   │   │   │   ├── utils.js
        │   │   │   │   └── zqfield.js
        │   │   │   ├── main.js
        │   │   │   ├── rollup.cjs.config.js
        │   │   │   └── test.js
        │   │   ├── r1csfile
        │   │   │   ├── src
        │   │   │   │   └── r1csfile.js
        │   │   │   ├── test
        │   │   │   │   ├── r1csfile_cg.test.js
        │   │   │   │   └── r1csfile.js
        │   │   │   └── rollup.cjs.config.js
        │   │   ├── snarkjs
        │   │   │   ├── build
        │   │   │   │   ├── snarkjs.js
        │   │   │   │   └── snarkjs.min.js
        │   │   │   ├── config
        │   │   │   │   ├── rollup.cjs.config.js
        │   │   │   │   ├── rollup.cli.config.js
        │   │   │   │   ├── rollup.iife_min.config.js
        │   │   │   │   └── rollup.iife.config.js
        │   │   │   ├── scripts
        │   │   │   │   ├── lagrange_fftext.js
        │   │   │   │   ├── prover_fftext.js
        │   │   │   │   ├── prover2_fftext.js
        │   │   │   │   └── verify_fftext.js
        │   │   │   ├── src
        │   │   │   │   ├── bigarray.js
        │   │   │   │   ├── chunk_utils.js
        │   │   │   │   ├── clprocessor.js
        │   │   │   │   ├── curves.js
        │   │   │   │   ├── groth16_exportsoliditycalldata.js
        │   │   │   │   ├── groth16_fullprove.js
        │   │   │   │   ├── groth16_prove.js
        │   │   │   │   ├── groth16_verify.js
        │   │   │   │   ├── groth16.js
        │   │   │   │   ├── keypair.js
        │   │   │   │   ├── loadsyms.js
        │   │   │   │   ├── misc.js
        │   │   │   │   ├── mpc_applykey.js
        │   │   │   │   ├── plonk_exportsoliditycalldata.js
        │   │   │   │   ├── plonk_fullprove.js
        │   │   │   │   ├── plonk_prove.js
        │   │   │   │   ├── plonk_setup.js
        │   │   │   │   ├── plonk_verify.js
        │   │   │   │   ├── plonk.js
        │   │   │   │   ├── powersoftau_beacon.js
        │   │   │   │   ├── powersoftau_challenge_contribute.js
        │   │   │   │   ├── powersoftau_contribute.js
        │   │   │   │   ├── powersoftau_convert.js
        │   │   │   │   ├── powersoftau_export_challenge.js
        │   │   │   │   ├── powersoftau_export_json.js
        │   │   │   │   ├── powersoftau_import.js
        │   │   │   │   ├── powersoftau_new.js
        │   │   │   │   ├── powersoftau_preparephase2.js
        │   │   │   │   ├── powersoftau_truncate.js
        │   │   │   │   ├── powersoftau_utils.js
        │   │   │   │   ├── powersoftau_verify.js
        │   │   │   │   ├── powersoftau.js
        │   │   │   │   ├── r1cs_export_json.js
        │   │   │   │   ├── r1cs_info.js
        │   │   │   │   ├── r1cs_print.js
        │   │   │   │   ├── r1cs.js
        │   │   │   │   ├── solidity.js
        │   │   │   │   ├── taskmanager.js
        │   │   │   │   ├── wtns_calculate.js
        │   │   │   │   ├── wtns_debug.js
        │   │   │   │   ├── wtns_export_json.js
        │   │   │   │   ├── wtns_utils.js
        │   │   │   │   ├── wtns.js
        │   │   │   │   ├── zkey_beacon.js
        │   │   │   │   ├── zkey_bellman_contribute.js
        │   │   │   │   ├── zkey_contribute.js
        │   │   │   │   ├── zkey_export_bellman.js
        │   │   │   │   ├── zkey_export_json.js
        │   │   │   │   ├── zkey_export_solidityverifier.js
        │   │   │   │   ├── zkey_export_verificationkey.js
        │   │   │   │   ├── zkey_import_bellman.js
        │   │   │   │   ├── zkey_new.js
        │   │   │   │   ├── zkey_utils.js
        │   │   │   │   ├── zkey_verify_frominit.js
        │   │   │   │   ├── zkey_verify_fromr1cs.js
        │   │   │   │   └── zkey.js
        │   │   │   ├── test
        │   │   │   │   ├── fullprocess.js
        │   │   │   │   └── keypar_test.js
        │   │   │   ├── cli.js
        │   │   │   └── main.js
        │   │   └── wasmcurves
        │   │       ├── benchmarks
        │   │       │   └── multiexp.js
        │   │       ├── build
        │   │       │   ├── bls12381_wasm.js
        │   │       │   ├── bn128_wasm.js
        │   │       │   ├── mnt6753_wasm.js
        │   │       │   └── pedersenparams_mnt6753.js
        │   │       ├── src
        │   │       │   ├── bls12381
        │   │       │   │   └── build_bls12381.js
        │   │       │   ├── bn128
        │   │       │   │   └── build_bn128.js
        │   │       │   ├── mnt6753
        │   │       │   │   └── build_mnt6753.js
        │   │       │   ├── bigint.js
        │   │       │   ├── build_applykey.js
        │   │       │   ├── build_batchconvertion.js
        │   │       │   ├── build_batchinverse.js
        │   │       │   ├── build_batchop.js
        │   │       │   ├── build_curve_jacobian_a0.js
        │   │       │   ├── build_curve_projective.js
        │   │       │   ├── build_f1.js
        │   │       │   ├── build_f1m.js
        │   │       │   ├── build_f2m.js
        │   │       │   ├── build_f3m.js
        │   │       │   ├── build_fft.js
        │   │       │   ├── build_int.js
        │   │       │   ├── build_mem.js
        │   │       │   ├── build_mulacc.js
        │   │       │   ├── build_multiexp.js
        │   │       │   ├── build_pedersenhash.js
        │   │       │   ├── build_pol.js
        │   │       │   ├── build_qap.js
        │   │       │   ├── build_test.js
        │   │       │   ├── build_testf1.js
        │   │       │   ├── build_testg1.js
        │   │       │   ├── build_timesscalar.js
        │   │       │   ├── build_timesscalarnaf.js
        │   │       │   ├── build_tomcook.js
        │   │       │   ├── f1.js
        │   │       │   └── utils.js
        │   │       ├── test
        │   │       │   ├── helpers
        │   │       │   │   └── helpers.js
        │   │       │   ├── bls12381.js
        │   │       │   ├── bn128.js
        │   │       │   ├── f1.js
        │   │       │   ├── fft.js
        │   │       │   ├── int.js
        │   │       │   ├── mnt6753.js
        │   │       │   └── tomcook.js
        │   │       ├── tools
        │   │       │   ├── buildpedersentablebases_mnt6753.js
        │   │       │   ├── buildwasm_bls12381.js
        │   │       │   ├── buildwasm_bn128.js
        │   │       │   └── buildwasm_mnt6753.js
        │   │       ├── .eslintrc.js
        │   │       └── index.js
        │   └── src
        │       ├── dkim
        │       │   ├── dns-archive.ts
        │       │   ├── dns-over-http.ts
        │       │   ├── index.ts
        │       │   └── sanitizers.ts
        │       ├── lib
        │       │   ├── mailauth
        │       │   │   ├── body
        │       │   │   │   ├── index.ts
        │       │   │   │   ├── relaxed.ts
        │       │   │   │   └── simple.ts
        │       │   │   ├── header
        │       │   │   │   ├── index.ts
        │       │   │   │   ├── relaxed.ts
        │       │   │   │   └── simple.ts
        │       │   │   ├── dkim-verifier.ts
        │       │   │   ├── message-parser.ts
        │       │   │   ├── parse-dkim-headers.ts
        │       │   │   └── tools.ts
        │       │   └── fast-sha256.ts
        │       ├── binary-format.ts
        │       ├── chunked-zkey.ts
        │       ├── constants.ts
        │       ├── hash.ts
        │       ├── index.ts
        │       ├── input-generators.ts
        │       └── sha-utils.ts
        ├── relayer-utils
        │   ├── relayer_utils_bg.js
        │   ├── relayer_utils.d.ts
        │   └── relayer_utils.js
        ├── sdk
        │   ├── dist
        │   │   ├── index.d.ts
        │   │   └── index.js
        │   └── README.md
        └── zk-regex-circom
            ├── circuits
            │   └── common
            │       ├── body_hash_regex.circom
            │       ├── body_hash.json
            │       ├── email_addr_regex.circom
            │       ├── email_addr_with_name_old.json
            │       ├── email_addr_with_name_regex.circom
            │       ├── email_addr.json
            │       ├── email_domain_regex.circom
            │       ├── email_domain.json
            │       ├── from_addr_regex.circom
            │       ├── from_addr?.json
            │       ├── from_all_regex.circom
            │       ├── from_all.json
            │       ├── message_id_regex.circom
            │       ├── message_id.json
            │       ├── reversed_bracket_regex.circom
            │       ├── reversed_bracket.json
            │       ├── reversed_email_addr_with_name_regex.circom
            │       ├── subject_all_regex.circom
            │       ├── subject_all.json
            │       ├── timestamp_regex.circom
            │       ├── timestamp.json
            │       ├── to_addr_regex.circom
            │       ├── to_addr?.json
            │       ├── to_all_regex.circom
            │       └── to_all.json
            └── tests
                ├── circuits
                │   ├── asterisk1_regex.circom
                │   ├── asterisk1.json
                │   ├── asterisk2_regex.circom
                │   ├── asterisk2.json
                │   ├── asterisk3_regex.circom
                │   ├── asterisk3.json
                │   ├── caret1_regex.circom
                │   ├── caret1.json
                │   ├── caret2_regex.circom
                │   ├── caret2.json
                │   ├── caret3_regex.circom
                │   ├── caret3.json
                │   ├── caret4_regex.circom
                │   ├── caret4.json
                │   ├── caret5_regex.circom
                │   ├── caret5.json
                │   ├── dollar1_regex.circom
                │   ├── dollar1.json
                │   ├── dollar2_regex.circom
                │   ├── dollar2.json
                │   ├── dot1_regex.circom
                │   ├── dot1.json
                │   ├── dot2_regex.circom
                │   ├── dot2.json
                │   ├── international_chars_decomposed.circom
                │   ├── international_chars_decomposed.json
                │   ├── invitation_code_with_prefix_regex.circom
                │   ├── invitation_code_with_prefix.json
                │   ├── negate1_regex.circom
                │   ├── negate1.json
                │   ├── negate2_regex.circom
                │   ├── negate2.json
                │   ├── plus1_regex.circom
                │   ├── plus1.json
                │   ├── plus2_regex.circom
                │   ├── plus2.json
                │   ├── plus3_regex.circom
                │   ├── plus3.json
                │   ├── plus4_regex.circom
                │   ├── plus4.json
                │   ├── question1_regex.circom
                │   ├── question1.json
                │   ├── question2_regex.circom
                │   ├── question2.json
                │   ├── question3_regex.circom
                │   ├── question3.json
                │   ├── reveal_check1_regex.circom
                │   ├── reveal_check1.json
                │   ├── reveal_check2_regex.circom
                │   ├── reveal_check2.json
                │   ├── simple_regex_decomposed.circom
                │   ├── simple_regex_decomposed.json
                │   ├── simple_regex_substrs.json
                │   ├── simple_regex.circom
                │   ├── test_asterisk1_regex.circom
                │   ├── test_asterisk2_regex.circom
                │   ├── test_asterisk3_regex.circom
                │   ├── test_body_hash_regex.circom
                │   ├── test_caret1_regex.circom
                │   ├── test_caret2_regex.circom
                │   ├── test_caret3_regex.circom
                │   ├── test_caret4_regex.circom
                │   ├── test_caret5_regex.circom
                │   ├── test_dollar1_regex.circom
                │   ├── test_dollar2_regex.circom
                │   ├── test_dot1_regex.circom
                │   ├── test_dot2_regex.circom
                │   ├── test_email_addr_regex.circom
                │   ├── test_email_domain_regex.circom
                │   ├── test_from_addr_regex.circom
                │   ├── test_international_chars_decomposed.circom
                │   ├── test_invitation_code_with_prefix_regex.circom
                │   ├── test_message_id_regex.circom
                │   ├── test_negate1_regex.circom
                │   ├── test_negate2_regex.circom
                │   ├── test_plus1_regex.circom
                │   ├── test_plus2_regex.circom
                │   ├── test_plus3_regex.circom
                │   ├── test_plus4_regex.circom
                │   ├── test_question1_regex.circom
                │   ├── test_question2_regex.circom
                │   ├── test_question3_regex.circom
                │   ├── test_reveal_check1_regex.circom
                │   ├── test_reveal_check2_regex.circom
                │   ├── test_simple_regex_decomposed.circom
                │   ├── test_simple_regex.circom
                │   ├── test_subject_all_regex.circom
                │   ├── test_timestamp_regex.circom
                │   └── test_to_addr_regex.circom
                ├── asterisk.test.js
                ├── body_hash_regex.test.js
                ├── caret.test.js
                ├── dollar.test.js
                ├── dot.test.js
                ├── email_addr.test.js
                ├── email_domain.test.js
                ├── from_addr.test.js
                ├── international_chars.test.js
                ├── invitation_code.test.js
                ├── message_id_regex.test.js
                ├── negate_regex.test.js
                ├── plus.test.js
                ├── question.test.js
                ├── reveal_check.test.js
                ├── simple_regex_decomposed.test.js
                ├── simple_regex.test.js
                ├── subject_all.test.js
                ├── timestamp.test.js
                └── to_addr.test.js



---
File: /@zk-email/circuits/helpers/email-nullifier.circom
---


pragma circom 2.1.6;

include "circomlib/circuits/poseidon.circom";


/// @title EmailNullifier
/// @notice An opinionated way of calculating the email nullifier
/// @notice nullifier = poseidon(poseidon(signature))
/// @notice Not used in core circuits now, but can be used by projects building on ZKEmail
/// @param bitPerChunk The number of bits per chunk the signature is split into
/// @param chunkSize The number of chunks the signature is split into
/// @input signature The signature of the email
/// @output out The email nullifier
template EmailNullifier(bitPerChunk, chunkSize) {
    signal input signature[chunkSize];

    signal output out;

    signal signatureHash <== PoseidonLarge(bitPerChunk, chunkSize)(signature);

    out <== Poseidon(1)([signatureHash]);
}



---
File: /@zk-email/circuits/helpers/remove-soft-line-breaks.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/comparators.circom";
include "circomlib/circuits/mux1.circom";
include "../utils/hash.circom";

/// @title RemoveSoftLineBreaks
/// @notice This template verifies the removal of soft line breaks from an encoded input string
/// @dev Soft line breaks are defined as "=\r\n" sequences in the encoded input
/// @param maxLength The maximum length of the input strings
/// @input encoded An array of ASCII values representing the input string with potential soft line breaks
/// @input decoded An array of ASCII values representing the expected output after removing soft line breaks
/// @output isValid A signal that is 1 if the decoded input correctly represents the encoded input with soft line breaks removed, 0 otherwise
template RemoveSoftLineBreaks(maxLength) {
    signal input encoded[maxLength];
    signal input decoded[maxLength];
    signal output isValid;

    // Helper signals
    signal r;
    signal processed[maxLength];
    signal isEquals[maxLength];
    signal isCr[maxLength];
    signal isLf[maxLength];
    signal tempSoftBreak[maxLength - 2];
    signal isSoftBreak[maxLength];
    signal shouldZero[maxLength];
    signal rEnc[maxLength];
    signal sumEnc[maxLength];
    signal rDec[maxLength];
    signal sumDec[maxLength];

    // Helper components
    component muxEnc[maxLength];

    // Deriving r from Poseidon hash
    component rHasher = PoseidonModular(2 * maxLength);
    for (var i = 0; i < maxLength; i++) {
        rHasher.in[i] <== encoded[i];
    }
    for (var i = 0; i < maxLength; i++) {
        rHasher.in[maxLength + i] <== decoded[i];
    }
    r <== rHasher.out;

    // Check for '=' (61 in ASCII)
    for (var i = 0; i < maxLength; i++) {
        isEquals[i] <== IsEqual()([encoded[i], 61]);
    }

    // Check for '\r' (13 in ASCII)
    for (var i = 0; i < maxLength - 1; i++) {
        isCr[i] <== IsEqual()([encoded[i + 1], 13]);
    }
    isCr[maxLength - 1] <== 0;

    // Check for '\n' (10 in ASCII)
    for (var i = 0; i < maxLength - 2; i++) {
        isLf[i] <== IsEqual()([encoded[i + 2], 10]);
    }
    isLf[maxLength - 2] <== 0;
    isLf[maxLength - 1] <== 0;

    // Identify soft line breaks
    for (var i = 0; i < maxLength - 2; i++) {
        tempSoftBreak[i] <== isEquals[i] * isCr[i];
        isSoftBreak[i] <== tempSoftBreak[i] * isLf[i];
    }
    // Handle the last two characters
    isSoftBreak[maxLength - 2] <== 0;
    isSoftBreak[maxLength - 1] <== 0;

    // Determine which characters should be zeroed
    for (var i = 0; i < maxLength; i++) {
        if (i == 0) {
            shouldZero[i] <== isSoftBreak[i];
        } else if (i == 1) {
            shouldZero[i] <== isSoftBreak[i] + isSoftBreak[i-1];
        } else if (i == maxLength - 1) {
            shouldZero[i] <== isSoftBreak[i-1] + isSoftBreak[i-2];
        } else {
            shouldZero[i] <== isSoftBreak[i] + isSoftBreak[i-1] + isSoftBreak[i-2];
        }
    }

    // Process the encoded input
    for (var i = 0; i < maxLength; i++) {
        processed[i] <== (1 - shouldZero[i]) * encoded[i];
    }

    // Calculate powers of r for encoded
    muxEnc[0] = Mux1();
    muxEnc[0].c[0] <== r;
    muxEnc[0].c[1] <== 1;
    muxEnc[0].s <== shouldZero[0];
    rEnc[0] <== muxEnc[0].out;

    for (var i = 1; i < maxLength; i++) {
        muxEnc[i] = Mux1();
        muxEnc[i].c[0] <== rEnc[i - 1] * r;
        muxEnc[i].c[1] <== rEnc[i - 1];
        muxEnc[i].s <== shouldZero[i];
        rEnc[i] <== muxEnc[i].out;
    }

    // Calculate powers of r for decoded
    rDec[0] <== r;
    for (var i = 1; i < maxLength; i++) {
        rDec[i] <== rDec[i - 1] * r;
    }

    // Calculate rlc for processed
    sumEnc[0] <== rEnc[0] * processed[0];
    for (var i = 1; i < maxLength; i++) {
        sumEnc[i] <== sumEnc[i - 1] + rEnc[i] * processed[i];
    }

    // Calculate rlc for decoded
    sumDec[0] <== rDec[0] * decoded[0];
    for (var i = 1; i < maxLength; i++) {
        sumDec[i] <== sumDec[i - 1] + rDec[i] * decoded[i];
    }

    // Check if rlc for decoded is equal to rlc for encoded
    isValid <== IsEqual()([sumEnc[maxLength - 1], sumDec[maxLength - 1]]);
}


---
File: /@zk-email/circuits/helpers/reveal-substring.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/comparators.circom";
include "../utils/array.circom";

/// @title RevealSubstring
/// @notice This circuit reveals a substring from an input array and verifies its uniqueness
/// @dev Ensures the revealed substring occurs exactly once in the input
/// @dev Note: This circuit assumes that the consuming circuit handles input validation
///      (e.g., checking that substringStartIndex and substringLength are within valid ranges)
/// @param maxLength The maximum length of the input array
/// @param maxSubstringLength The maximum length of the substring to be revealed
template RevealSubstring(maxLength, maxSubstringLength, shouldCheckUniqueness) {
    assert(maxSubstringLength < maxLength);

    signal input in[maxLength];
    signal input substringStartIndex;
    signal input substringLength;

    signal output substring[maxSubstringLength];

    // Substring start index should be less than maxLength
    signal isSubstringStartIndexValid <== LessThan(log2Ceil(maxLength))([substringStartIndex, maxLength]);
    isSubstringStartIndexValid === 1;

    // Substring length should be less than maxSubstringLength + 1
    signal isSubstringLengthValid <== LessThan(log2Ceil(maxSubstringLength + 1))([substringLength, maxSubstringLength + 1]);
    isSubstringLengthValid === 1;

    // substring index + substring length should be less than maxLength + 1
    signal sum <== substringStartIndex + substringLength;
    signal isSumValid <== LessThan(log2Ceil(maxLength + 1))([sum, maxLength + 1]);
    isSumValid === 1;

    // Extract the substring
    component selectSubArray = SelectSubArray(maxLength, maxSubstringLength);
    selectSubArray.in <== in;
    selectSubArray.startIndex <== substringStartIndex;
    selectSubArray.length <== substringLength;

    if (shouldCheckUniqueness) {
        // Check if the substring occurs exactly once in the input
        component countSubstringOccurrences = CountSubstringOccurrences(maxLength, maxSubstringLength);
        countSubstringOccurrences.in <== in;
        countSubstringOccurrences.substring <== selectSubArray.out;
        countSubstringOccurrences.count === 1;
    }

    substring <== selectSubArray.out;
}


---
File: /@zk-email/circuits/lib/base64.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/comparators.circom";


/// @title Base64Decode
/// @notice Decodes a Base64 encoded string to array of bytes.
/// @notice Only support inputs with length = `byteLength` (no 0 padding).
/// @notice It is known that padding char '=' can be replaed with `A` to produce the same output
///         as Base64Lookup returns `0` for both, but a pracical attack from this is unlikely.
/// @param byteLength Byte length of the encoded value - length of the output array.
/// @input in Base64 encoded string; assumes elements to be valid Base64 characters.
/// @output out Decoded array of bytes.
template Base64Decode(byteLength) {
    var charLength = 4 * ((byteLength + 2) \ 3); // 4 chars encode 3 bytes
    
    signal input in[charLength];
    signal output out[byteLength];

    component bitsIn[charLength\4][4];
    component bitsOut[charLength\4][3];
    component translate[charLength\4][4];

    var idx = 0;
    for (var i = 0; i < charLength; i += 4) {
        for (var j = 0; j < 3; j++) {
            bitsOut[i\4][j] = Bits2Num(8);
        }

        for (var j = 0; j < 4; j++) {
            bitsIn[i\4][j] = Num2Bits(6);
            translate[i\4][j] = Base64Lookup();
            translate[i\4][j].in <== in[i+j];
            translate[i\4][j].out ==> bitsIn[i\4][j].in;
        }

        // Do the re-packing from four 6-bit words to three 8-bit words.
        for (var j = 0; j < 6; j++) {
            bitsOut[i\4][0].in[j+2] <== bitsIn[i\4][0].out[j];
        }
        bitsOut[i\4][0].in[0] <== bitsIn[i\4][1].out[4];
        bitsOut[i\4][0].in[1] <== bitsIn[i\4][1].out[5];

        for (var j = 0; j < 4; j++) {
            bitsOut[i\4][1].in[j+4] <== bitsIn[i\4][1].out[j];
        }
        for (var j = 0; j < 4; j++) {
            bitsOut[i\4][1].in[j] <== bitsIn[i\4][2].out[j+2];
        }

        bitsOut[i\4][2].in[6] <== bitsIn[i\4][2].out[0];
        bitsOut[i\4][2].in[7] <== bitsIn[i\4][2].out[1];
        for (var j = 0; j < 6; j++) {
            bitsOut[i\4][2].in[j] <== bitsIn[i\4][3].out[j];
        }

        for (var j = 0; j < 3; j++) {
            if (idx+j < byteLength) {
                out[idx+j] <== bitsOut[i\4][j].out;
            }
        }
        idx += 3;
    }
}


/// @title Base64Lookup
/// @notice http://0x80.pl/notesen/2016-01-17-sse-base64-decoding.html#vector-lookup-base
/// @input in input character; assumes input to be valid Base64 character (though constrained implicitly).
/// @output out output bit value.
template Base64Lookup() {
    signal input in;
    signal output out;

    // ['A', 'Z']
    component le_Z = LessThan(8);
    le_Z.in[0] <== in;
    le_Z.in[1] <== 90+1;

    component ge_A = GreaterThan(8);
    ge_A.in[0] <== in;
    ge_A.in[1] <== 65-1;

    signal range_AZ <== ge_A.out * le_Z.out;
    signal sum_AZ <== range_AZ * (in - 65);

    // ['a', 'z']
    component le_z = LessThan(8);
    le_z.in[0] <== in;
    le_z.in[1] <== 122+1;

    component ge_a = GreaterThan(8);
    ge_a.in[0] <== in;
    ge_a.in[1] <== 97-1;

    signal range_az <== ge_a.out * le_z.out;
    signal sum_az <== sum_AZ + range_az * (in - 71);

    // ['0', '9']
    component le_9 = LessThan(8);
    le_9.in[0] <== in;
    le_9.in[1] <== 57+1;

    component ge_0 = GreaterThan(8);
    ge_0.in[0] <== in;
    ge_0.in[1] <== 48-1;

    signal range_09 <== ge_0.out * le_9.out;
    signal sum_09 <== sum_az + range_09 * (in + 4);

    // '+'
    component equal_plus = IsZero();
    equal_plus.in <== in - 43;
    signal sum_plus <== sum_09 + equal_plus.out * (in + 19);

    // '/'
    component equal_slash = IsZero();
    equal_slash.in <== in - 47;
    signal sum_slash <== sum_plus + equal_slash.out * (in + 16);

    out <== sum_slash;

    // '='
    component equal_eqsign = IsZero();
    equal_eqsign.in <== in - 61;

    1 === range_AZ + range_az + range_09 + equal_plus.out + equal_slash.out + equal_eqsign.out;
}



---
File: /@zk-email/circuits/lib/bigint-func.circom
---

pragma circom 2.1.6;


function div_ceil(m, n) {
    var ret = 0;
    if (m % n == 0) {
        ret = m \ n;
    } else {
        ret = m \ n + 1;
    }
    return ret;
}

function log_ceil(n) {
   var n_temp = n;
   for (var i = 0; i < 254; i++) {
       if (n_temp == 0) {
          return i;
       }
       n_temp = n_temp \ 2;
   }
   return 254;
}

// m bits per overflowed register (values are potentially negative)
// n bits per properly-sized register
// in has k registers
// out has k + ceil(m/n) - 1 + 1 registers. highest-order potentially negative,
// all others are positive
// - 1 since the last register is included in the last ceil(m/n) array
// + 1 since the carries from previous registers could push you over
function getProperRepresentation(m, n, k, in) {
    var ceilMN = div_ceil(m, n);

    var out[100]; // should be out[k + ceilMN]
    assert(k + ceilMN < 100);
    for (var i = 0; i < k; i++) {
        out[i] = in[i];
    }
    for (var i = k; i < 100; i++) {
        out[i] = 0;
    }
    assert(n <= m);
    for (var i = 0; i+1 < k + ceilMN; i++) {
        assert((1 << m) >= out[i] && out[i] >= -(1 << m));
        var shifted_val = out[i] + (1 << m);
        assert(0 <= shifted_val && shifted_val <= (1 << (m+1)));
        out[i] = shifted_val & ((1 << n) - 1);
        out[i+1] += (shifted_val >> n) - (1 << (m - n));
    }

    return out;
}

// Evaluate polynomial a at point x
function poly_eval(len, a, x) {
    var v = 0;
    for (var i = 0; i < len; i++) {
        v += a[i] * (x ** i);
    }
    return v;
}

// Interpolate a degree len-1 polynomial given its evaluations at 0..len-1
function poly_interp(len, v) {
    assert(len <= 200);
    var out[200];
    for (var i = 0; i < len; i++) {
        out[i] = 0;
    }

    // Product_{i=0..len-1} (x-i)
    var full_poly[201];
    full_poly[0] = 1;
    for (var i = 0; i < len; i++) {
        full_poly[i+1] = 0;
        for (var j = i; j >= 0; j--) {
            full_poly[j+1] += full_poly[j];
            full_poly[j] *= -i;
        }
    }

    for (var i = 0; i < len; i++) {
        var cur_v = 1;
        for (var j = 0; j < len; j++) {
            if (i == j) {
                // do nothing
            } else {
                cur_v *= i-j;
            }
        }
        cur_v = v[i] / cur_v;

        var cur_rem = full_poly[len];
        for (var j = len-1; j >= 0; j--) {
            out[j] += cur_v * cur_rem;
            cur_rem = full_poly[j] + i * cur_rem;
        }
        assert(cur_rem == 0);
    }

    return out;
}

// 1 if true, 0 if false
function long_gt(n, k, a, b) {
    for (var i = k - 1; i >= 0; i--) {
        if (a[i] > b[i]) {
            return 1;
        }
        if (a[i] < b[i]) {
            return 0;
        }
    }
    return 0;
}

// n bits per register
// a has k registers
// b has k registers
// a >= b
function long_sub(n, k, a, b) {
    var diff[100];
    var borrow[100];
    for (var i = 0; i < k; i++) {
        if (i == 0) {
           if (a[i] >= b[i]) {
               diff[i] = a[i] - b[i];
               borrow[i] = 0;
            } else {
               diff[i] = a[i] - b[i] + (1 << n);
               borrow[i] = 1;
            }
        } else {
            if (a[i] >= b[i] + borrow[i - 1]) {
               diff[i] = a[i] - b[i] - borrow[i - 1];
               borrow[i] = 0;
            } else {
               diff[i] = (1 << n) + a[i] - b[i] - borrow[i - 1];
               borrow[i] = 1;
            }
        }
    }
    return diff;
}

// a is a n-bit scalar
// b has k registers
function long_scalar_mult(n, k, a, b) {
    var out[100];
    for (var i = 0; i < 100; i++) {
        out[i] = 0;
    }
    for (var i = 0; i < k; i++) {
        var temp = out[i] + (a * b[i]);
        out[i] = temp % (1 << n);
        out[i + 1] = out[i + 1] + temp \ (1 << n);
    }
    return out;
}


// n bits per register
// a has k + m registers
// b has k registers
// out[0] has length m + 1 -- quotient
// out[1] has length k -- remainder
// implements algorithm of https://people.eecs.berkeley.edu/~fateman/282/F%20Wright%20notes/week4.pdf
function long_div(n, k, m, a, b){
    var out[2][100];
    m += k;
    while (b[k-1] == 0) {
        out[1][k] = 0;
        k--;
        assert(k > 0);
    }
    m -= k;

    var remainder[100];
    for (var i = 0; i < m + k; i++) {
        remainder[i] = a[i];
    }

    var mult[200];
    var dividend[200];
    for (var i = m; i >= 0; i--) {
        if (i == m) {
            dividend[k] = 0;
            for (var j = k - 1; j >= 0; j--) {
                dividend[j] = remainder[j + m];
            }
        } else {
            for (var j = k; j >= 0; j--) {
                dividend[j] = remainder[j + i];
            }
        }

        out[0][i] = short_div(n, k, dividend, b);

        var mult_shift[100] = long_scalar_mult(n, k, out[0][i], b);
        var subtrahend[200];
        for (var j = 0; j < m + k; j++) {
            subtrahend[j] = 0;
        }
        for (var j = 0; j <= k; j++) {
            if (i + j < m + k) {
               subtrahend[i + j] = mult_shift[j];
            }
        }
        remainder = long_sub(n, m + k, remainder, subtrahend);
    }
    for (var i = 0; i < k; i++) {
        out[1][i] = remainder[i];
    }
    out[1][k] = 0;

    return out;
}

// n bits per register
// a has k + 1 registers
// b has k registers
// assumes leading digit of b is at least 2 ** (n - 1)
// 0 <= a < (2**n) * b
function short_div_norm(n, k, a, b) {
   var qhat = (a[k] * (1 << n) + a[k - 1]) \ b[k - 1];
   if (qhat > (1 << n) - 1) {
      qhat = (1 << n) - 1;
   }

   var mult[100] = long_scalar_mult(n, k, qhat, b);
   if (long_gt(n, k + 1, mult, a) == 1) {
      mult = long_sub(n, k + 1, mult, b);
      if (long_gt(n, k + 1, mult, a) == 1) {
         return qhat - 2;
      } else {
         return qhat - 1;
      }
   } else {
       return qhat;
   }
}

// n bits per register
// a has k + 1 registers
// b has k registers
// assumes leading digit of b is non-zero
// 0 <= a < (2**n) * b
function short_div(n, k, a, b) {
   var scale = (1 << n) \ (1 + b[k - 1]);

   // k + 2 registers now
   var norm_a[100] = long_scalar_mult(n, k + 1, scale, a);
   // k + 1 registers now
   var norm_b[100] = long_scalar_mult(n, k, scale, b);

   var ret;
   if (norm_b[k] != 0) {
       ret = short_div_norm(n, k + 1, norm_a, norm_b);
   } else {
       ret = short_div_norm(n, k, norm_a, norm_b);
   }
   return ret;
}



---
File: /@zk-email/circuits/lib/bigint.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/comparators.circom";
include "circomlib/circuits/bitify.circom";
include "circomlib/circuits/gates.circom";
include "./bigint-func.circom";


/// @template BigLessThan
/// @notice Less than comparison for big integers
/// @param n The number of bits in each chunk
/// @param k The number of chunks
/// @param a The first bigint; assumes to consist of `k` chunks, each of which must fit in `n` bits
/// @param b The second bigint; assumes to consist of `k` chunks, each of which must fit in `n` bits
/// @param out The output of the comparison
template BigLessThan(n, k){
    signal input a[k];
    signal input b[k];
    signal output out;

    component lt[k];
    component eq[k];
    for (var i = 0; i < k; i++) {
        lt[i] = LessThan(n);
        lt[i].in[0] <== a[i];
        lt[i].in[1] <== b[i];
        eq[i] = IsEqual();
        eq[i].in[0] <== a[i];
        eq[i].in[1] <== b[i];
    }

    // ors[i] holds (lt[k - 1] || (eq[k - 1] && lt[k - 2]) .. || (eq[k - 1] && .. && lt[i]))
    // ands[i] holds (eq[k - 1] && .. && lt[i])
    // eq_ands[i] holds (eq[k - 1] && .. && eq[i])
    component ors[k - 1];
    component ands[k - 1];
    component eq_ands[k - 1];
    for (var i = k - 2; i >= 0; i--) {
        ands[i] = AND();
        eq_ands[i] = AND();
        ors[i] = OR();

        if (i == k - 2) {
           ands[i].a <== eq[k - 1].out;
           ands[i].b <== lt[k - 2].out;
           eq_ands[i].a <== eq[k - 1].out;
           eq_ands[i].b <== eq[k - 2].out;
           ors[i].a <== lt[k - 1].out;
           ors[i].b <== ands[i].out;
        } else {
           ands[i].a <== eq_ands[i + 1].out;
           ands[i].b <== lt[i].out;
           eq_ands[i].a <== eq_ands[i + 1].out;
           eq_ands[i].b <== eq[i].out;
           ors[i].a <== ors[i + 1].out;
           ors[i].b <== ands[i].out;
        }
     }
     out <== ors[0].out;
}


/// @template CheckCarryToZero
/// @notice Check that in[] as a big integer is zero
/// @param n The number of bits in each chunk
/// @param m 
/// @param k The number of chunks
/// @input in The input big integer; assumes elements to be in the range -2^(m-1) to 2^(m-1)
template CheckCarryToZero(n, m, k) {
    assert(k >= 2);

    var EPSILON = 3;

    assert(m + EPSILON <= 253);

    signal input in[k];

    signal carry[k];
    component carryRangeChecks[k];
    for (var i = 0; i < k-1; i++){
        carryRangeChecks[i] = Num2Bits(m + EPSILON - n);
        if( i == 0 ){
            carry[i] <-- in[i] / (1<<n);
            in[i] === carry[i] * (1<<n);
        }
        else{
            carry[i] <-- (in[i]+carry[i-1]) / (1<<n);
            in[i] + carry[i-1] === carry[i] * (1<<n);
        }
        // checking carry is in the range of - 2^(m-n-1+eps), 2^(m+-n-1+eps)
        carryRangeChecks[i].in <== carry[i] + ( 1<< (m + EPSILON - n - 1));
    }
    in[k-1] + carry[k-2] === 0;
}



---
File: /@zk-email/circuits/lib/fp.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/bitify.circom";
include "circomlib/circuits/comparators.circom";
include "circomlib/circuits/sign.circom";
include "./bigint.circom";
include "./bigint-func.circom";


/// @title FpMul
/// @notice Multiple two numbers in Fp
/// @param a Input 1 to FpMul; assumes to consist of `k` chunks, each of which must fit in `n` bits
/// @param b Input 2 to FpMul; assumes to consist of `k` chunks, each of which must fit in `n` bits
/// @param p The modulus; assumes to consist of `k` chunks, each of which must fit in `n` bits
/// @output out The result of the FpMul; asserted to be less than `p`  
template FpMul(n, k) {
    assert(n + n + log_ceil(k) + 2 <= 252);

    signal input a[k];
    signal input b[k];
    signal input p[k];

    signal output out[k];

    signal v_ab[2*k-1];
    for (var x = 0; x < 2*k-1; x++) {
        var v_a = poly_eval(k, a, x);
        var v_b = poly_eval(k, b, x);
        v_ab[x] <== v_a * v_b;
    }

    var ab[200] = poly_interp(2*k-1, v_ab);
    // ab_proper has length 2*k
    var ab_proper[100] = getProperRepresentation(n + n + log_ceil(k), n, 2*k-1, ab);

    var long_div_out[2][100] = long_div(n, k, k, ab_proper, p);

    // Since we're only computing a*b, we know that q < p will suffice, so we
    // know it fits into k chunks and can do size n range checks.
    signal q[k];
    component q_range_check[k];
    signal r[k];
    component r_range_check[k];
    component r_p_lt_check = BigLessThan(n,k);
    for (var i = 0; i < k; i++) {
        q[i] <-- long_div_out[0][i];
        q_range_check[i] = Num2Bits(n);
        q_range_check[i].in <== q[i];

        r[i] <-- long_div_out[1][i];
        r_range_check[i] = Num2Bits(n);
        r_range_check[i].in <== r[i];

        r_p_lt_check.a[i] <== r[i];
        r_p_lt_check.b[i] <== p[i];
    }
    r_p_lt_check.out === 1;

    signal v_pq_r[2*k-1];
    for (var x = 0; x < 2*k-1; x++) {
        var v_p = poly_eval(k, p, x);
        var v_q = poly_eval(k, q, x);
        var v_r = poly_eval(k, r, x);
        v_pq_r[x] <== v_p * v_q + v_r;
    }

    signal v_t[2*k-1];
    for (var x = 0; x < 2*k-1; x++) {
        v_t[x] <== v_ab[x] - v_pq_r[x];
    }

    var t[200] = poly_interp(2*k-1, v_t);
    component tCheck = CheckCarryToZero(n, n + n + log_ceil(k) + 2, 2*k-1);
    for (var i = 0; i < 2*k-1; i++) {
        tCheck.in[i] <== t[i];
    }

    for (var i = 0; i < k; i++) {
        out[i] <== r[i];
    }
}



---
File: /@zk-email/circuits/lib/rsa.circom
---

pragma circom 2.1.6;

include "./fp.circom";


/// @title RSAVerifier65537 
/// @notice Verifies an RSA signature with exponent 65537.
/// @param n Number of bits per chunk the modulus is split into. Recommended to be 121.
/// @param k Number of chunks the modulus is split into. Recommended to be 17.
/// @input message[k] The message that was signed; assumes to consist of `k` chunks that fit in `n` bits (also constrained implicitly).
/// @input signature[k] The signature to verify; assumes to consist of `k` chunks that fit in `n` bits (also constrained implicitly).
/// @input modulus[k] The modulus of the RSA key (pubkey); assumes to consist of `k` chunks that fit in `n` bits (also constrained implicitly).
template RSAVerifier65537(n, k) {
    signal input message[k];
    signal input signature[k];
    signal input modulus[k];

    component padder = RSAPad(n, k);
    for (var i = 0; i < k; i++) {
        padder.modulus[i] <== modulus[i];
        padder.message[i] <== message[i];
    }

    // Check that the signature is in proper form and reduced mod modulus.
    component signatureRangeCheck[k];
    component bigLessThan = BigLessThan(n, k);
    for (var i = 0; i < k; i++) {
        signatureRangeCheck[i] = Num2Bits(n);
        signatureRangeCheck[i].in <== signature[i];
        bigLessThan.a[i] <== signature[i];
        bigLessThan.b[i] <== modulus[i];
    }
    bigLessThan.out === 1;

    component bigPow = FpPow65537Mod(n, k);
    for (var i = 0; i < k; i++) {
        bigPow.base[i] <== signature[i];
        bigPow.modulus[i] <== modulus[i];
    }

    // By construction of the padding, the padded message is necessarily
    // smaller than the modulus. Thus, we don't have to check that bigPow is fully reduced.
    for (var i = 0; i < k; i++) {
        bigPow.out[i] === padder.out[i];
    }
}


/// @title FpPow65537Mod
/// @notice Computes base^65537 mod modulus
/// @dev Does not necessarily reduce fully mod modulus (the answer could be too big by a multiple of modulus)
/// @param n Number of bits per chunk the modulus is split into.
/// @param k Number of chunks the modulus is split into.
/// @input base The base to exponentiate; assumes to consist of `k` chunks, each of which must fit in `n` bits
/// @input modulus The modulus; assumes to consist of `k` chunks, each of which must fit in `n` bits
/// @output out The result of the exponentiation.
template FpPow65537Mod(n, k) {
    signal input base[k];
    signal input modulus[k];

    signal output out[k];

    component doublers[16];
    component adder = FpMul(n, k);
    for (var i = 0; i < 16; i++) {
        doublers[i] = FpMul(n, k);
    }

    for (var j = 0; j < k; j++) {
        adder.p[j] <== modulus[j];
        for (var i = 0; i < 16; i++) {
            doublers[i].p[j] <== modulus[j];
        }
    }
    for (var j = 0; j < k; j++) {
        doublers[0].a[j] <== base[j];
        doublers[0].b[j] <== base[j];
    }
    for (var i = 0; i + 1 < 16; i++) {
        for (var j = 0; j < k; j++) {
            doublers[i + 1].a[j] <== doublers[i].out[j];
            doublers[i + 1].b[j] <== doublers[i].out[j];
        }
    }
    for (var j = 0; j < k; j++) {
        adder.a[j] <== base[j];
        adder.b[j] <== doublers[15].out[j];
    }
    for (var j = 0; j < k; j++) {
        out[j] <== adder.out[j];
    }
}

/// @title RSAPad
/// @notice Pads a message for RSA signing.
/// @param n Number of bits per chunk the modulus is split into.
/// @param k Number of chunks the modulus is split into.
/// @input modulus The modulus of the RSA key (pubkey).
/// @input message The message to pad.
/// @output out The padded message.
template RSAPad(n, k) {
    signal input modulus[k];
    signal input message[k];
    signal output out[k];

    // The extra 152 bits comes from 0x3031300d060960864801650304020105000420
    // This is due to padding from the RSASSA-PKCS1-v1_5 standard
    var baseLen = 408;
    var msgLen = 256;

    signal paddedMessageBits[n*k];

    component modulusN2B[k];
    component messageN2B[k];
    signal modulusBits[n*k];
    signal messageBits[n*k];
    for (var i = 0; i < k; i++) {
        messageN2B[i] = Num2Bits(n);
        messageN2B[i].in <== message[i];
        for (var j = 0; j < n; j++) {
            messageBits[i*n+j] <== messageN2B[i].out[j];
        }
        modulusN2B[i] = Num2Bits(n);
        modulusN2B[i].in <== modulus[i];
        for (var j = 0; j < n; j++) {
            modulusBits[i*n+j] <== modulusN2B[i].out[j];
        }
    }

    for (var i = msgLen; i < n*k; i++) {
        messageBits[i] === 0;
    }

    for (var i = 0; i < msgLen; i++) {
        paddedMessageBits[i] <== messageBits[i];
    }

    for (var i = baseLen; i < baseLen + 8; i++) {
        paddedMessageBits[i] <== 0;
    }

    for (var i = msgLen; i < baseLen; i++) {
        paddedMessageBits[i] <== (0x3031300d060960864801650304020105000420 >> (i - msgLen)) & 1;
    }

    component modulusZero[(n*k + 7 - (baseLen + 8))\8];
    {
        var modulusPrefix = 0;
        for (var i = n*k - 1; i >= baseLen + 8; i--) {
            if (i+8 < n*k) {
                modulusPrefix += modulusBits[i+8];
                if (i % 8 == 0) {
                    var idx = (i - (baseLen + 8)) \ 8;
                    modulusZero[idx] = IsZero();
                    modulusZero[idx].in <== modulusPrefix;
                    paddedMessageBits[i] <== 1-modulusZero[idx].out;
                } else {
                    paddedMessageBits[i] <== paddedMessageBits[i+1];
                }
            } else {
                paddedMessageBits[i] <== 0;
            }
        }
    }

    // The RFC guarantees at least 8 octets of 0xff padding.
    assert(baseLen + 8 + 65 <= n * k);

    for (var i = baseLen + 8; i < baseLen + 8 + 65; i++) {
        paddedMessageBits[i] === 1;
    }

    component passedMessageB2N[k];
    for (var i = 0; i < k; i++) {
        passedMessageB2N[i] = Bits2Num(n);
        for (var j = 0; j < n; j++) {
            passedMessageB2N[i].in[j] <== paddedMessageBits[i*n+j];
        }
        out[i] <== passedMessageB2N[i].out;
    }
}



---
File: /@zk-email/circuits/lib/sha.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/bitify.circom";
include "circomlib/circuits/sha256/constants.circom";
include "circomlib/circuits/sha256/sha256compression.circom";
include "circomlib/circuits/comparators.circom";
include "./fp.circom";
include "../utils/array.circom";
include "../utils/functions.circom";


/// @title Sha256Bytes
/// @notice Computes the SHA256 hash of input bytes
/// @input paddedIn Message to hash, padded as per the SHA256 specification; assumes to consist of bytes
/// @input paddedInLength Length of the padded message; assumes to be in `ceil(log2(8 * maxByteLength))` bits
/// @output out The 256-bit hash of the input message
template Sha256Bytes(maxByteLength) {
    signal input paddedIn[maxByteLength];
    signal input paddedInLength;
    signal output out[256];

    var maxBits = maxByteLength * 8;
    component sha = Sha256General(maxBits);

    component bytes[maxByteLength];
    for (var i = 0; i < maxByteLength; i++) {
        bytes[i] = Num2Bits(8);
        bytes[i].in <== paddedIn[i];
        for (var j = 0; j < 8; j++) {
            sha.paddedIn[i*8+j] <== bytes[i].out[7-j];
        }
    }
    sha.paddedInLength <== paddedInLength * 8;

    for (var i = 0; i < 256; i++) {
        out[i] <== sha.out[i];
    }
}


/// @title Sha256BytesPartial
/// @notice Computes the SHA256 hash of input bytes with a precomputed state
/// @input paddedIn Message to hash padded as per the SHA256 specification; assumes to consist of bytes
/// @input paddedInLength Length of the padded message; assumes to be in `ceil(log2(8 * maxByteLength))` bits
/// @input preHash The precomputed state of the hash
/// @output out SHA hash the input message with the precomputed state
template Sha256BytesPartial(maxByteLength) {
    assert(maxByteLength % 32 == 0);

    signal input paddedIn[maxByteLength];
    signal input paddedInLength;
    signal input preHash[32];
    signal output out[256];

    var maxBits = maxByteLength * 8;
    component sha = Sha256Partial(maxBits);

    component bytes[maxByteLength];
    for (var i = 0; i < maxByteLength; i++) {
        bytes[i] = Num2Bits(8);
        bytes[i].in <== paddedIn[i];
        for (var j = 0; j < 8; j++) {
            sha.paddedIn[i*8+j] <== bytes[i].out[7-j];
        }
    }
    sha.paddedInLength <== paddedInLength * 8;

    component states[32];
    for (var i = 0; i < 32; i++) {
        states[i] = Num2Bits(8);
        states[i].in <== preHash[i];
        for (var j = 0; j < 8; j++) {
            sha.preHash[8*i+j] <== states[i].out[7-j];
        }
    }

    for (var i = 0; i < 256; i++) {
        out[i] <== sha.out[i];
    }
}


/// @title Sha256General
/// @notice A modified version of the SHA256 circuit that allows specified length messages up to a 
///         max to all work via array indexing on the SHA256 compression circuit.
/// @input paddedIn Message to hash padded as per the SHA256 specification; assumes to consist of bits
/// @input paddedInLength Length of the padded message; assumes to be in `ceil(log2(maxBitLength))` bits
/// @output out The 256-bit hash of the input message
template Sha256General(maxBitLength) {
    // maxBitLength must be a multiple of 512
    // the bit circuits in this file are limited to 15 so must be raised if the message is longer.
    assert(maxBitLength % 512 == 0);

    var maxBitsPaddedBits = log2Ceil(maxBitLength);

    // Note that maxBitLength = maxBits + 64
    signal input paddedIn[maxBitLength];
    signal input paddedInLength;
    
    signal output out[256];
    
    signal inBlockIndex;

    var i;
    var k;
    var j;
    var maxBlocks;
    var bitsLastBlock;
    maxBlocks = (maxBitLength\512);

    inBlockIndex <-- (paddedInLength >> 9);
    paddedInLength === inBlockIndex * 512;

    // These verify the unconstrained floor calculation is the uniquely correct integer that represents the floor
    // component floorVerifierUnder = LessEqThan(maxBitsPaddedBits); // todo verify the length passed in is less than nbits. note that maxBitsPaddedBits can likely be lowered or made it a fn of maxbits
    // floorVerifierUnder.in[0] <== (inBlockIndex)*512;
    // floorVerifierUnder.in[1] <== paddedInLength;
    // floorVerifierUnder.out === 1;

    // component floorVerifierOver = GreaterThan(maxBitsPaddedBits);
    // floorVerifierOver.in[0] <== (inBlockIndex+1)*512;
    // floorVerifierOver.in[1] <== paddedInLength;
    // floorVerifierOver.out === 1;

    // These verify we pass in a valid number of bits to the SHA256 compression circuit.
    component bitLengthVerifier = LessEqThan(maxBitsPaddedBits); // todo verify the length passed in is less than nbits. note that maxBitsPaddedBits can likely be lowered or made it a fn of maxbits
    bitLengthVerifier.in[0] <== paddedInLength;
    bitLengthVerifier.in[1] <== maxBitLength;
    bitLengthVerifier.out === 1;

    // Note that we can no longer do padded verification efficiently inside the SHA because it requires non deterministic array indexing.
    // We can do it if we add a constraint, but since guessing a valid SHA2 preimage is hard anyways, we'll just do it outside the circuit.

    // signal paddedIn[maxBlocks*512];
    // for (k=0; k<maxBits; k++) {
    //     paddedIn[k] <== in[k];
    // }
    // paddedIn[maxBits] <== 1;
    // for (k=maxBits+1; k<maxBlocks*512-64; k++) {
    //     paddedIn[k] <== 0;
    // }
    // for (k = 0; k< 64; k++) {
    //     paddedIn[maxBlocks*512 - k -1] <== (maxBits >> k)&1;
    // }

    component ha0 = H(0);
    component hb0 = H(1);
    component hc0 = H(2);
    component hd0 = H(3);
    component he0 = H(4);
    component hf0 = H(5);
    component hg0 = H(6);
    component hh0 = H(7);

    component sha256compression[maxBlocks];

    for (i=0; i<maxBlocks; i++) {
        sha256compression[i] = Sha256compression() ;

        if (i==0) {
            for (k=0; k<32; k++ ) {
                sha256compression[i].hin[0*32+k] <== ha0.out[k];
                sha256compression[i].hin[1*32+k] <== hb0.out[k];
                sha256compression[i].hin[2*32+k] <== hc0.out[k];
                sha256compression[i].hin[3*32+k] <== hd0.out[k];
                sha256compression[i].hin[4*32+k] <== he0.out[k];
                sha256compression[i].hin[5*32+k] <== hf0.out[k];
                sha256compression[i].hin[6*32+k] <== hg0.out[k];
                sha256compression[i].hin[7*32+k] <== hh0.out[k];
            }
        } else {
            for (k=0; k<32; k++ ) {
                sha256compression[i].hin[32*0+k] <== sha256compression[i-1].out[32*0+31-k];
                sha256compression[i].hin[32*1+k] <== sha256compression[i-1].out[32*1+31-k];
                sha256compression[i].hin[32*2+k] <== sha256compression[i-1].out[32*2+31-k];
                sha256compression[i].hin[32*3+k] <== sha256compression[i-1].out[32*3+31-k];
                sha256compression[i].hin[32*4+k] <== sha256compression[i-1].out[32*4+31-k];
                sha256compression[i].hin[32*5+k] <== sha256compression[i-1].out[32*5+31-k];
                sha256compression[i].hin[32*6+k] <== sha256compression[i-1].out[32*6+31-k];
                sha256compression[i].hin[32*7+k] <== sha256compression[i-1].out[32*7+31-k];
            }
        }

        for (k=0; k<512; k++) {
            sha256compression[i].inp[k] <== paddedIn[i*512+k];
        }
    }

    // Select the correct compression output for the given length, instead of just the last one.
    component arraySelectors[256];
    for (k=0; k<256; k++) {
        arraySelectors[k] = ItemAtIndex(maxBlocks);
        for (j=0; j<maxBlocks; j++) {
            arraySelectors[k].in[j] <== sha256compression[j].out[k];
        }
        arraySelectors[k].index <== inBlockIndex - 1; // The index is 0 indexed and the block numbers are 1 indexed.
        out[k] <== arraySelectors[k].out;
    }

    // for (k=0; k<256; k++) {
    //     out[k] <== sha256compression[maxBlocks-1].out[k];
    // }
}


/// @title Sha256Partial
/// @notice Calculates the SHA256 hash of a message with a precomputed state
/// @input paddedIn Message to hash padded as per the SHA256 specification; assumes to consist of bits
/// @input paddedInLength Length of the padded message; assumes to be in `ceil(log2(maxBitLength))` bits
/// @input preHash The precomputed state of the hash; assumes to consist of bits
/// @output out The 256-bit hash of the input message
template Sha256Partial(maxBitLength) {
    // maxBitLength must be a multiple of 512
    // the bit circuits in this file are limited to 15 so must be raised if the message is longer.
    assert(maxBitLength % 512 == 0);

    var maxBitsPaddedBits = log2Ceil(maxBitLength);

    // Note that maxBitLength = maxBits + 64
    signal input paddedIn[maxBitLength];
    signal input paddedInLength; 
    signal input preHash[256];

    signal output out[256];

    signal inBlockIndex;

    var i;
    var k;
    var j;
    var maxBlocks;
    var bitsLastBlock;
    maxBlocks = (maxBitLength\512);

    inBlockIndex <-- (paddedInLength >> 9);
    paddedInLength === inBlockIndex * 512;

    // These verify we pass in a valid number of bits to the SHA256 compression circuit.
    component bitLengthVerifier = LessEqThan(maxBitsPaddedBits); // todo verify the length passed in is less than nbits. note that maxBitsPaddedBits can likely be lowered or made it a fn of maxbits
    bitLengthVerifier.in[0] <== paddedInLength;
    bitLengthVerifier.in[1] <== maxBitLength;
    bitLengthVerifier.out === 1;

    component sha256compression[maxBlocks];

    for (i=0; i<maxBlocks; i++) {
        sha256compression[i] = Sha256compression() ;

        if (i==0) {
            for (k=0; k<32; k++ ) {
                sha256compression[i].hin[32*0+k] <== preHash[32*0+31-k];
                sha256compression[i].hin[32*1+k] <== preHash[32*1+31-k];
                sha256compression[i].hin[32*2+k] <== preHash[32*2+31-k];
                sha256compression[i].hin[32*3+k] <== preHash[32*3+31-k];
                sha256compression[i].hin[32*4+k] <== preHash[32*4+31-k];
                sha256compression[i].hin[32*5+k] <== preHash[32*5+31-k];
                sha256compression[i].hin[32*6+k] <== preHash[32*6+31-k];
                sha256compression[i].hin[32*7+k] <== preHash[32*7+31-k];
            }
        } else {
            for (k=0; k<32; k++ ) {
                sha256compression[i].hin[32*0+k] <== sha256compression[i-1].out[32*0+31-k];
                sha256compression[i].hin[32*1+k] <== sha256compression[i-1].out[32*1+31-k];
                sha256compression[i].hin[32*2+k] <== sha256compression[i-1].out[32*2+31-k];
                sha256compression[i].hin[32*3+k] <== sha256compression[i-1].out[32*3+31-k];
                sha256compression[i].hin[32*4+k] <== sha256compression[i-1].out[32*4+31-k];
                sha256compression[i].hin[32*5+k] <== sha256compression[i-1].out[32*5+31-k];
                sha256compression[i].hin[32*6+k] <== sha256compression[i-1].out[32*6+31-k];
                sha256compression[i].hin[32*7+k] <== sha256compression[i-1].out[32*7+31-k];
            }
        }

        for (k=0; k<512; k++) {
            sha256compression[i].inp[k] <== paddedIn[i*512+k];
        }
    }

    // Select the correct compression output for the given length, instead of just the last one.
    component arraySelectors[256];
    for (k=0; k<256; k++) {
        arraySelectors[k] = ItemAtIndex(maxBlocks);
        for (j=0; j<maxBlocks; j++) {
            arraySelectors[k].in[j] <== sha256compression[j].out[k];
        }
        arraySelectors[k].index <== inBlockIndex - 1; // The index is 0 indexed and the block numbers are 1 indexed.
        out[k] <== arraySelectors[k].out;
    }

    // for (k=0; k<256; k++) {
    //     out[k] <== sha256compression[maxBlocks-1].out[k];
    // }
}



---
File: /@zk-email/circuits/utils/array.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/comparators.circom";
include "circomlib/circuits/bitify.circom";
include "./functions.circom";


/// @title ItemAtIndex
/// @notice Select item at given index from the input array
/// @notice This template that the index is valid
/// @notice This is a modified version of QuinSelector from MACI https://github.com/privacy-scaling-explorations/maci/
/// @param maxArrayLen The number of elements in the array
/// @input in The input array
/// @input index The index of the element to select
/// @output out The selected element
template ItemAtIndex(maxArrayLen) {
    signal input in[maxArrayLen];
    signal input index;

    signal output out;

    component calcTotalValue = CalculateTotal(maxArrayLen);
    component calcTotalIndex = CalculateTotal(maxArrayLen);
    component eqs[maxArrayLen];

    // For each item, check whether its index equals the input index.
    for (var i = 0; i < maxArrayLen; i ++) {
        eqs[i] = IsEqual();
        eqs[i].in[0] <== i;
        eqs[i].in[1] <== index;

        // eqs[i].out is 1 if the index matches - so calcTotal is sum of 0s + 1 * valueAtIndex
        calcTotalValue.nums[i] <== eqs[i].out * in[i];

        // Take the sum of all eqs[i].out and assert that it is at most 1.
        calcTotalIndex.nums[i] <== eqs[i].out;
    }

    // Assert that the sum of eqs[i].out is 1. This is to ensure the index passed is valid.
    calcTotalIndex.sum === 1;

    out <== calcTotalValue.sum;
}


/// @title CalculateTotal
/// @notice Calculate the sum of an array
/// @param n The number of elements in the array
/// @input nums The input array; assumes elements are small enough that their sum does not overflow the field
/// @output sum The sum of the input array
template CalculateTotal(n) {
    signal input nums[n];

    signal output sum;

    signal sums[n];
    sums[0] <== nums[0];

    for (var i=1; i < n; i++) {
        sums[i] <== sums[i - 1] + nums[i];
    }

    sum <== sums[n - 1];
}


/// @title SelectSubArray
/// @notice Select sub array from an array given a `startIndex` and `length`
/// @notice This is same as `VarShiftLeft` but with elements after `length` set to zero
/// @notice This is not used in core ZK-Email circuits at the moment
/// @param maxArrayLen: the maximum number of bytes in the input array
/// @param maxSubArrayLen: the maximum number of integers in the output array
/// @input in: the input array
/// @input startIndex: the start index of the sub array; assumes a valid index
/// @input length: the length of the sub array; assumes to fit in `ceil(log2(maxArrayLen))` bits
/// @output out: array of `maxSubArrayLen` size, items starting from `startIndex`, and items after `length` set to zero
template SelectSubArray(maxArrayLen, maxSubArrayLen) {
    assert(maxSubArrayLen < maxArrayLen);

    signal input in[maxArrayLen];
    signal input startIndex;
    signal input length;

    signal output out[maxSubArrayLen];

    component shifter = VarShiftLeft(maxArrayLen, maxSubArrayLen);
    shifter.in <== in;
    shifter.shift <== startIndex;

    // Set value after length to zero
    component gts[maxSubArrayLen];
    for (var i = 0; i < maxSubArrayLen; i++) {
        gts[i] = GreaterThan(log2Ceil(maxSubArrayLen));
        gts[i].in[0] <== length;
        gts[i].in[1] <== i;

        out[i] <== gts[i].out * shifter.out[i];
    }
}


/// @title VarShiftLeft
/// @notice Shift input array by `shift` indices to the left
/// @notice Output array length can be reduced by setting `maxOutArrayLen` 
/// @notice Based on https://demo.hedgedoc.org/s/Le0R3xUhB
/// @param maxArrayLen The maximum length of the input array
/// @param maxOutArrayLen The maximum length of the output array
/// @input in The input array
/// @input shift The number of indices to shift the array to the left
/// @output out hifted subarray
template VarShiftLeft(maxArrayLen, maxOutArrayLen) {
    assert(maxOutArrayLen <= maxArrayLen);

    var bitLength = log2Ceil(maxArrayLen);

    signal input in[maxArrayLen];
    signal input shift;

    signal output out[maxOutArrayLen];

    component n2b = Num2Bits(bitLength);
    n2b.in <== shift;

    signal tmp[bitLength][maxArrayLen];
    for (var j = 0; j < bitLength; j++) {
        for (var i = 0; i < maxArrayLen; i++) {
            var offset = (i + (1 << j)) % maxArrayLen;
            // Shift left by 2^j indices if bit is 1
            if (j == 0) {
                tmp[j][i] <== n2b.out[j] * (in[offset] - in[i]) + in[i];
            } else {
                tmp[j][i] <== n2b.out[j] * (tmp[j-1][offset] - tmp[j-1][i]) + tmp[j-1][i];
            }
        }
    }

    // Return last row
    for (var i = 0; i < maxOutArrayLen; i++) {
        out[i] <== tmp[bitLength - 1][i];
    }
}


/// @title AssertZeroPadding
/// @notice Assert that the input array is zero-padded from the given `startIndex`
/// @param maxArrayLen The maximum number of elements in the input array
/// @input in The input array;
/// @input startIndex The index from which the elements should be 0; assumes `startIndex - 1` to fit in `ceil(log2(maxArrayLen))` bits
template AssertZeroPadding(maxArrayLen) {
    var bitLength = log2Ceil(maxArrayLen);
    
    signal input in[maxArrayLen];
    signal input startIndex;

    component lessThans[maxArrayLen];

    for (var i = 0; i < maxArrayLen; i++) {
        lessThans[i] = LessThan(bitLength);
        lessThans[i].in[0] <== startIndex - 1;
        lessThans[i].in[1] <== i;

        lessThans[i].out * in[i] === 0;
    }
}

/// @title Slice
/// @notice Extract a fixed portion of an array
/// @dev Unlike SelectSubArray, Slice uses compile-time known indices and doesn't pad the output
/// @dev Slice is more efficient for fixed ranges, while SelectSubArray offers runtime flexibility
/// @param n The length of the input array
/// @param start The starting index of the slice (inclusive)
/// @param end The ending index of the slice (exclusive)
/// @input in The input array of length n
/// @output out The sliced array of length (end - start)
template Slice(n, start, end) {
    assert(n >= end);
    assert(start >= 0);
    assert(end >= start);

    signal input in[n];
    signal output out[end - start];    

    for (var i = start; i < end; i++) {
        out[i - start] <== in[i];
    }
}

/// @title CheckSubstringMatch
/// @notice Check if a substring matches the input array
/// @param maxSubstringLen The maximum length of the substring
/// @input input The portion of the input array to check
/// @input substring The substring pattern to match
/// @output isMatch 1 if the substring matches, 0 otherwise
template CheckSubstringMatch(maxSubstringLen) {
    signal input in[maxSubstringLen];
    signal input substring[maxSubstringLen];
    signal output isMatch;

    // Ensure the first element of the pattern is non-zero
    signal firstElementNonZero;
    firstElementNonZero <== IsZero()(substring[0]);
    firstElementNonZero === 0;

    signal matchAccumulator[maxSubstringLen + 1];
    signal difference[maxSubstringLen];
    signal isZeroDifference[maxSubstringLen];

    matchAccumulator[0] <== 1;

    for (var i = 0; i < maxSubstringLen; i++) {
        difference[i] <== (in[i] - substring[i]) * substring[i];
        isZeroDifference[i] <== IsZero()(difference[i]);
        matchAccumulator[i + 1] <== matchAccumulator[i] * isZeroDifference[i];
    }

    isMatch <== matchAccumulator[maxSubstringLen];
}

/// @title CountSubstringOccurrences
/// @notice Count the number of times a substring occurs in the input array
/// @param maxLen The maximum length of the input array
/// @param maxSubstringLen The maximum length of the substring
/// @input in The input array to search in
/// @input substring The substring to search for
/// @output count The number of occurrences of the substring in the input
template CountSubstringOccurrences(maxLen, maxSubstringLen) {
    assert(maxLen >= maxSubstringLen);

    signal input in[maxLen];
    signal input substring[maxSubstringLen];
    signal output count;

    // Check for matches at each possible starting position
    component matches[maxLen];
    for (var i = 0; i < maxLen; i++) {
        matches[i] = CheckSubstringMatch(maxSubstringLen);
        for (var j = 0; j < maxSubstringLen; j++) {
            if (i + j < maxLen) {
                matches[i].in[j] <== in[i + j];
            } else {
                matches[i].in[j] <== 0;
            }
        }
        matches[i].substring <== substring;
    }

    // Sum up all matches to get the total count
    component summer = CalculateTotal(maxLen);
    for (var i = 0; i < maxLen; i++) {
        summer.nums[i] <== matches[i].isMatch;
    }

    count <== summer.sum;
}


---
File: /@zk-email/circuits/utils/bytes.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/bitify.circom";
include "circomlib/circuits/comparators.circom";
include "./array.circom";
include "./constants.circom";
include "./functions.circom";


function computeIntChunkLength(byteLength) {
    var packSize = MAX_BYTES_IN_FIELD();

    var remain = byteLength % packSize;
    var numChunks = (byteLength - remain) / packSize;
    if (remain > 0) {
        numChunks += 1;
    }

    return numChunks;
}


/// @title PackBytes
/// @notice Pack an array of bytes to numbers that fit in the field
/// @param maxBytes the maximum number of bytes in the input array
/// @input in the input byte array; assumes elements to be bytes
/// @output out the output integer array
template PackBytes(maxBytes) {
    var packSize = MAX_BYTES_IN_FIELD();
    var maxInts = computeIntChunkLength(maxBytes);

    signal input in[maxBytes];
    signal output out[maxInts];

    signal intSums[maxInts][packSize];

    for (var i = 0; i < maxInts; i++) {
        for(var j=0; j < packSize; j++) {
            var idx = packSize * i + j;

            // Copy the previous value if we are out of bounds - we take last item as final result
            if(idx >= maxBytes) {
                intSums[i][j] <== intSums[i][j-1];
            } 
            // First item of each chunk is the byte itself
            else if (j == 0){
                intSums[i][j] <== in[idx];
            }
            // Every other item is 256^j * byte
            else {
                intSums[i][j] <== intSums[i][j-1] + (1 << (8*j)) * in[idx];
            }
        }
    }
    
    // Last item of each chunk is the final sum
    for (var i = 0; i < maxInts; i++) {
        out[i] <== intSums[i][packSize-1];
    }
}


/// @title PackByteSubArray
/// @notice Select sub array from the input array and pack it to numbers that fit in the field
/// @notice This is not used in ZK-Email circuits anywhere
/// @param maxArrayLen the maximum number of elements in the input array
/// @param maxSubArrayLen the maximum number of elements in the sub array
/// @input in the input byte array; assumes elements to be bytes
/// @input startIndex the start index of the sub array; assumes to be a valid index
/// @input length the length of the sub array; assumes to fit in `ceil(log2(maxSubArrayLen))` bits
/// @output out the output integer array
template PackByteSubArray(maxArrayLen, maxSubArrayLen) {
    assert(maxSubArrayLen < maxArrayLen);
    var chunkLength = computeIntChunkLength(maxSubArrayLen);

    signal input in[maxArrayLen];
    signal input startIndex;
    signal input length;

    signal output out[chunkLength];

    component SelectSubArray = SelectSubArray(maxArrayLen, maxSubArrayLen);
    SelectSubArray.in <== in;
    SelectSubArray.startIndex <== startIndex;
    SelectSubArray.length <== length;

    component packer = PackBytes(maxSubArrayLen);
    packer.in <== SelectSubArray.out;

    out <== packer.out;
}


/// @title DigitBytesToInt
/// @notice Converts a byte array representing digits to an integer
/// @notice Assumes the output number fits in the field
/// @param n The number of bytes in the input array
/// @input in The input byte array; assumes elements are between 48 and 57 (ASCII numbers)
/// @output out The output integer; assumes to fit in the field
template DigitBytesToInt(n) {
    signal input in[n];

    signal output out;

    signal sums[n+1];
    sums[0] <== 0;

    for(var i = 0; i < n; i++) {
        sums[i + 1] <== 10 * sums[i] + (in[i] - 48);
    }

    out <== sums[n];
}


// NOTE: this circuit is unaudited and should not be used in production
/// @title SplitBytesToWords
/// @notice split an array of bytes into an array of words
/// @notice useful for casting a message or modulus before RSA verification
/// @param l: number of bytes in the input array
/// @param n: number of bits in a word
/// @param k: number of words
/// @input in: array of bytes
/// @output out: array of words
template SplitBytesToWords (l,n,k) {
    signal input in[l];
    signal output out[k];

    component num2bits[l];
    for (var i = 0 ; i < l ; i++){
        num2bits[i] = Num2Bits(8);
        num2bits[i].in <== in[i];
    }
    component bits2num[k];
    for (var i = 0 ; i < k ; i++){
        bits2num[i] = Bits2Num(n);
        for(var j = 0 ; j < n ; j++){
            if(i*n + j >=  8 * l){
                bits2num[i].in[j] <==  0;
            }
            else{
                bits2num[i].in[j] <== num2bits[l - (( i * n + j) \ 8) - 1].out[ ((i * n + j) % 8)];
            }
        }
    }
    for( var i = 0 ; i< k ; i++){
    out[i] <== bits2num[i].out;
    }
}

// Asserts that a given input is binary.
//
// Inputs:
// - in: an input signal, expected to be 0 or 1.
template AssertBit() {
    signal input in;
    in * (in - 1) === 0;
}

// The ByteMask template masks an input array using a binary mask array.
// Each element in the input array is multiplied by the corresponding element in the mask array.
// The mask array is validated to ensure all elements are binary (0 or 1).
//
// Parameters:
// - maxLength: The maximum length of the input and mask arrays.
//
// Inputs:
// - body: An array of signals representing the body to be masked.
// - mask: An array of signals representing the binary mask.
//
// Outputs:
// - out: An array of signals representing the masked input.
template ByteMask(maxLength) {
    signal input in[maxLength];
    signal input mask[maxLength];
    signal output out[maxLength];

    component bit_check[maxLength];

    for (var i = 0; i < maxLength; i++) {
        bit_check[i] = AssertBit();
        bit_check[i].in <== mask[i];
        out[i] <== in[i] * mask[i];
    }
}


---
File: /@zk-email/circuits/utils/constants.circom
---

pragma circom 2.1.6;


function EMAIL_ADDR_MAX_BYTES() {
    return 256;
}

function DOMAIN_MAX_BYTES() {
    return 255;
}

// Field support maximum of ~253 bit
function MAX_BYTES_IN_FIELD() {
    return 31;
}



---
File: /@zk-email/circuits/utils/functions.circom
---

pragma circom 2.1.6;

/// @function log2Ceil
/// @notice Calculate log2 of a number and round it up
/// @param a The input value
/// @return The result of the log2Ceil
function log2Ceil(a) {
    var n = a - 1;
    var r = 0;

    while (n > 0) {
        r++;
        n \= 2;
    }

    return r;
}



---
File: /@zk-email/circuits/utils/hash.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/poseidon.circom";
include "./array.circom";

/// @title PoseidonLarge
/// @notice Circuit to calculate Poseidon hash of inputs more than 16
/// @notice Merges two consecutive chunks to bring size < 16 assuming ints are chunks of a large number (a + bitsPerChunk * b)
/// @notice Assumes merging of two ints fit in field
/// @notice Can be made more generic by taking hash with any size inputs with nesting
/// @param bitsPerChunk Number of bits in each chunk
/// @param chunkSize Number of chunks in input
/// @input in: Array of chunkSize elements; assumes elements to fit in `bitsPerChunk` bits
/// @output out: Poseidon hash of input where consecutive elements are merged
template PoseidonLarge(bitsPerChunk, chunkSize) {
    assert(chunkSize > 16); // Can use regular Poseidon for smaller chunks
    assert(chunkSize <= 32); // We only support up to 32 chunks. i.e half should be less than 16
    assert(bitsPerChunk * 2 < 251);
  
    var halfChunkSize = chunkSize >> 1;
    if (chunkSize % 2 == 1) {
        halfChunkSize += 1;
    }

    signal input in[chunkSize];
    signal output out;

    signal poseidonInput[halfChunkSize];

    for(var i = 0; i < halfChunkSize; i++) {
        if (i == halfChunkSize - 1 && chunkSize % 2 == 1) {
            poseidonInput[i] <== in[2 * i];
        } else {
            poseidonInput[i] <== in[2 * i] + (1 << bitsPerChunk) * in[2 * i + 1];
        }
    }

    out <== Poseidon(halfChunkSize)(poseidonInput);
}

/// @title PoseidonModular
/// @notice Circuit to calculate Poseidon hash of an arbitrary number of inputs
/// @notice Splits input into chunks of 16 elements (or less for the last chunk) and hashes them separately
/// @notice Then combines the chunk hashes using a binary tree structure
/// @notice This is a modified version from: https://github.com/burnt-labs/email-wallet/blob/b6601fed6fc1bf119739dce6a49e69d69144c5fa/circuits/utils/commit.circom#L24
/// @param numElements Number of elements in the input array
/// @input in: Array of numElements to be hashed
/// @output out: Poseidon hash of the input array
template PoseidonModular(numElements) {
    signal input in[numElements];
    signal output out; 

    var chunks = numElements \ 16;
    var last_chunk_size = numElements % 16;
    if (last_chunk_size != 0) {
        chunks += 1;
    }

    var _out;
    
    for (var i = 0; i < chunks; i++) {
        var start = i * 16;
        var end = start + 16;
        var chunk_hash;

        if (end > numElements) { // last chunk
            end = numElements;
            var last_chunk[last_chunk_size] = Slice(numElements, start, end)(in);
            chunk_hash = Poseidon(last_chunk_size)(last_chunk);
        } else {
            var chunk[16] = Slice(numElements, start, end)(in);
            chunk_hash = Poseidon(16)(chunk);
        }

        if (i == 0) {
            _out = chunk_hash;
        } else {
            _out = Poseidon(2)([_out, chunk_hash]);
        }
    }

    out <== _out;
}


---
File: /@zk-email/circuits/utils/regex.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/comparators.circom";
include "circomlib/circuits/bitify.circom";
include "./bytes.circom";

/// @title SelectRegexReveal
/// @notice Returns reveal bytes of a regex match from the input
/// @notice Verifies data before and after (maxRevealLen) reveal part is zero
/// @notice Assumes that there is only one consecutive sequence of non-zero bytes in `in`.
/// @param maxArrayLen Maximum length of the input array
/// @param maxRevealLen Maximum length of the reveal part
/// @input in Input array; assumes elements to be bytes
/// @input startIndex The index from which reveal part starts; assumes a valid index, 
///                   and `startIndex + maxRevealLen - 1` fits in `ceil(log2((maxArrayLen + maxRevealLen - 1))` bits.
/// @output out Revealed data array
template SelectRegexReveal(maxArrayLen, maxRevealLen) {
    signal input in[maxArrayLen];
    signal input startIndex;

    signal output out[maxRevealLen];

    var bitLength = log2Ceil(maxArrayLen + maxRevealLen - 1);

    signal isStartIndex[maxArrayLen];
    signal isZero[maxArrayLen];
    signal isPreviousZero[maxArrayLen];
    signal isAboveMaxRevealLen[maxArrayLen];

    isPreviousZero[0] <== 1;
    for(var i = 0; i < maxArrayLen; i++) {
        isStartIndex[i] <== IsEqual()([i, startIndex]);
        isZero[i] <== IsZero()(in[i]);
        if(i > 0) {
            isPreviousZero[i] <== IsZero()(in[i - 1]);
        }
        isAboveMaxRevealLen[i] <== GreaterThan(bitLength)([i, startIndex + maxRevealLen - 1]);

        // Assert startIndex is not zero
        isStartIndex[i] * isZero[i] === 0;

        // Assert value before startIndex is zero
        // ZK-Regex circuit contstrains that every byte before the reveal part is zero
        // This is assuming matched data doesn't contain 0 (null) byte
        isStartIndex[i] * (1 - isPreviousZero[i]) === 0;

        // Assert all values after startIndex + maxRevealLen are zero (for extra safety)
        isAboveMaxRevealLen[i] * (1 - isZero[i]) === 0;
    }

    out <== VarShiftLeft(maxArrayLen, maxRevealLen)(in, startIndex);
}


/// @title PackRegexReveal
/// @notice Packs reveal data from a regex match into int[]
/// @param maxArrayLen Maximum length of the input array
/// @param maxRevealLen Maximum length of the reveal part
/// @input in Input array; assumes elements to be bytes
/// @input startIndex Index of the start of the reveal part; assumes a valid index
/// @output out Packed int array
template PackRegexReveal(maxArrayLen, maxRevealLen) {
    var chunkSize = computeIntChunkLength(maxRevealLen);

    signal input in[maxArrayLen];
    signal input startIndex;
    
    signal output out[chunkSize];

    component extractor = SelectRegexReveal(maxArrayLen, maxRevealLen);
    extractor.in <== in;
    extractor.startIndex <== startIndex;

    // Items after reveal part and before maxRevealLen are already asserted to zero
    // So we can safely pack without an additional `length` input
    component packer = PackBytes(maxRevealLen);
    packer.in <== extractor.out;
    out <== packer.out;
}



---
File: /@zk-email/circuits/email-verifier.circom
---

pragma circom 2.1.6;

include "circomlib/circuits/bitify.circom";
include "circomlib/circuits/poseidon.circom";
include "@zk-email/zk-regex-circom/circuits/common/body_hash_regex.circom";
include "./lib/base64.circom";
include "./lib/rsa.circom";
include "./lib/sha.circom";
include "./utils/array.circom";
include "./utils/regex.circom";
include "./utils/hash.circom";
include "./utils/bytes.circom";
include "./helpers/remove-soft-line-breaks.circom";


/// @title EmailVerifier
/// @notice Circuit to verify email signature as per DKIM standard.
/// @notice Verifies the signature is valid for the given header and pubkey, and the hash of the body matches the hash in the header.
/// @notice This cicuit only verifies signature as per `rsa-sha256` algorithm.
/// @param maxHeadersLength Maximum length for the email header.
/// @param maxBodyLength Maximum length for the email body.
/// @param n Number of bits per chunk the RSA key is split into. Recommended to be 121.
/// @param k Number of chunks the RSA key is split into. Recommended to be 17.
/// @param ignoreBodyHashCheck Set 1 to skip body hash check in case data to prove/extract is only in the headers.
/// @param enableHeaderMasking Set 1 to turn on header masking.
/// @param enableBodyMasking Set 1 to turn on body masking.
/// @param removeSoftLineBreaks Set 1 to remove soft line breaks from the email body.
/// @input emailHeader[maxHeadersLength] Email headers that are signed (ones in `DKIM-Signature` header) as ASCII int[], padded as per SHA-256 block size.
/// @input emailHeaderLength Length of the email header including the SHA-256 padding.
/// @input pubkey[k] RSA public key split into k chunks of n bits each.
/// @input signature[k] RSA signature split into k chunks of n bits each.
/// @input emailBody[maxBodyLength] Email body after the precomputed SHA as ASCII int[], padded as per SHA-256 block size.
/// @input emailBodyLength Length of the email body including the SHA-256 padding.
/// @input bodyHashIndex Index of the body hash `bh` in the emailHeader.
/// @input precomputedSHA[32] Precomputed SHA-256 hash of the email body till the bodyHashIndex.
/// @input decodedEmailBodyIn[maxBodyLength] Decoded email body without soft line breaks.
/// @input mask[maxBodyLength] Mask for the email body.
/// @output pubkeyHash Poseidon hash of the pubkey - Poseidon(n/2)(n/2 chunks of pubkey with k*2 bits per chunk).
/// @output decodedEmailBodyOut[maxBodyLength] Decoded email body with soft line breaks removed.
/// @output maskedHeader[maxHeadersLength] Masked email header.
/// @output maskedBody[maxBodyLength] Masked email body.
template EmailVerifier(maxHeadersLength, maxBodyLength, n, k, ignoreBodyHashCheck, enableHeaderMasking, enableBodyMasking, removeSoftLineBreaks) {
    assert(maxHeadersLength % 64 == 0);
    assert(maxBodyLength % 64 == 0);
    assert(n * k > 2048); // to support 2048 bit RSA
    assert(n < (255 \ 2)); // for multiplication to fit in the field (255 bits)


    signal input emailHeader[maxHeadersLength];
    signal input emailHeaderLength;
    signal input pubkey[k];
    signal input signature[k];

    signal output pubkeyHash;
