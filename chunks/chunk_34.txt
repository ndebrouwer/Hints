
// from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
function str2ab(str: string) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

function importRsaKey(pem: string) {
  // fetch the part of the PEM string between header and footer
  const pemHeader = '-----BEGIN PUBLIC KEY-----';
  const pemFooter = '-----END PUBLIC KEY-----';
  const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);
  // base64 decode the string to get the binary data
  const binaryDerString = window.atob(pemContents);
  // convert from a binary string to an ArrayBuffer
  const binaryDer = str2ab(binaryDerString);

  return window.crypto.subtle.importKey(
    'spki',
    binaryDer,
    {
      name: 'RSA-OAEP',
      hash: 'SHA-256',
    },
    true,
    ['encrypt'],
  );
}

export const getPublicKey = async (
  type: string,
  name: string,
  minBitLength: number,
  resolver: (...args: [name: string, type: string]) => Promise<any>,
) => {
  minBitLength = minBitLength || 1024;

  let list = await resolver(name, 'TXT');
  let rr =
    list &&
    []
      .concat(list[0] || [])
      .join('')
      .replaceAll(/\s+/g, '')
      .replaceAll('"', '');

  if (rr) {
    // prefix value for parsing as there is no default value
    let entry = parseDkimHeaders('DNS: TXT;' + rr);

    const publicKeyValue = entry?.parsed?.p?.value;

    //'v=DKIM1;p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwe34ubzrMzM9sT0XVkcc3UXd7W+EHCyHoqn70l2AxXox52lAZzH/UnKwAoO+5qsuP7T9QOifIJ9ddNH9lEQ95Y/GdHBsPLGdgSJIs95mXNxscD6MSyejpenMGL9TPQAcxfqY5xPViZ+1wA1qcryjdZKRqf1f4fpMY+x3b8k7H5Qyf/Smz0sv4xFsx1r+THNIz0rzk2LO3GvE0f1ybp6P+5eAelYU4mGeZQqsKw/eB20I3jHWEyGrXuvzB67nt6ddI+N2eD5K38wg/aSytOsb5O+bUSEe7P0zx9ebRRVknCD6uuqG3gSmQmttlD5OrMWSXzrPIXe8eTBaaPd+e/jfxwIDAQAB'
    // v=DKIM1;p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwe34ubzrMzM9sT0XVkcc3UXd7W+EHCyHoqn70l2AxXox52lAZzH/UnKwAoO+5qsuP7T9QOifIJ9ddNH9lEQ95Y/GdHBsPLGdgSJIs95mXNxscD6MSyejpenMGL9TPQAcxfqY5xPViZ+1wA1qcr""yjdZKRqf1f4fpMY+x3b8k7H5Qyf/Smz0sv4xFsx1r+THNIz0rzk2LO3GvE0f1ybp6P+5eAelYU4mGeZQqsKw/eB20I3jHWEyGrXuvzB67nt6ddI+N2eD5K38wg/aSytOsb5O+bUSEe7P0zx9ebRRVknCD6uuqG3gSmQmttlD5OrMWSXzrPIXe8eTBaaPd+e/jfxwIDAQAB
    if (!publicKeyValue) {
      const err = new CustomError('Missing key value', 'EINVALIDVAL', rr);
      throw err;
    }

    /*let validation = base64Schema.validate(publicKeyValue);
        if (validation.error) {
            throw new Error('Invalid base64 format for public key');
            err.code = 'EINVALIDVAL';
            err.rr = rr;
            err.details = validation.error;
            throw err;
        }*/

    if (
      type === 'DKIM' &&
      entry?.parsed?.v &&
      (entry?.parsed?.v?.value || '').toString().toLowerCase().trim() !== 'dkim1'
    ) {
      const err = new CustomError('Unknown key version', 'EINVALIDVER', rr);
      throw err;
    }

    let paddingNeeded = publicKeyValue.length % 4 ? 4 - (publicKeyValue.length % 4) : 0;

    const publicKeyPem = Buffer.from(
      `-----BEGIN PUBLIC KEY-----\n${(publicKeyValue + '='.repeat(paddingNeeded)).replace(
        /.{64}/g,
        '$&\n',
      )}\n-----END PUBLIC KEY-----`,
    );
    let publicKeyObj;
    if (!IS_BROWSER) {
      publicKeyObj = crypto.createPublicKey({
        key: publicKeyPem,
        format: 'pem',
      });
    } else {
      publicKeyObj = await importRsaKey(publicKeyPem.toString());
    }

    let keyType;
    if (!IS_BROWSER) {
      keyType = (publicKeyObj as KeyObject).asymmetricKeyType;
    } else {
      keyType = (publicKeyObj as CryptoKey).algorithm.name.split('-')[0].toLowerCase();
    }

    if (
      !['rsa', 'ed25519'].includes(keyType ?? '') ||
      (entry?.parsed?.k && entry?.parsed?.k?.value?.toLowerCase() !== keyType)
    ) {
      throw new CustomError('Unknown key type (${keyType})', 'EINVALIDTYPE', rr);
    }

    let modulusLength;
    if ((publicKeyObj as CryptoKey).algorithm) {
      modulusLength = (publicKeyObj as CryptoKey & { algorithm: { modulusLength: number } }).algorithm?.modulusLength;
    } else {
      // fall back to node-forge
      const pubKeyData = pki.publicKeyFromPem(publicKeyPem.toString());
      // const pubKeyData = CryptoJS.parseKey(publicKeyPem.toString(), 'pem');
      modulusLength = pubKeyData.n.bitLength();
    }

    if (keyType === 'rsa' && modulusLength < 1024) {
      throw new CustomError('RSA key too short', 'ESHORTKEY', rr);
    }

    return {
      publicKey: publicKeyPem,
      rr,
      modulusLength,
    };
  }

  throw new CustomError('Missing key value', 'EINVALIDVAL', rr);
};

export const escapePropValue = (value: string) => {
  value = (value || '')
    .toString()
    .replace(/[\x00-\x1F]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  if (!/[\s\x00-\x1F\x7F-\uFFFF()<>,;:\\"/[\]?=]/.test(value)) {
    // return token value
    return value;
  }

  // return quoted string with escaped quotes
  return `"${value.replace(/["\\]/g, (c) => `\\${c}`)}"`;
};

export const escapeCommentValue = (value: string) => {
  value = (value || '')
    .toString()
    .replace(/[\x00-\x1F]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  return `${value.replace(/[\\)]/g, (c) => `\\${c}`)}`;
};

export const formatAuthHeaderRow = (method: string, status: Record<string, any>) => {
  status = status || {};
  let parts = [];

  parts.push(`${method}=${status.result || 'none'}`);

  if (status.comment) {
    parts.push(`(${escapeCommentValue(status.comment)})`);
  }

  for (let ptype of ['policy', 'smtp', 'body', 'header']) {
    if (!status[ptype] || typeof status[ptype] !== 'object') {
      continue;
    }

    for (let prop of Object.keys(status[ptype])) {
      if (status[ptype][prop]) {
        parts.push(`${ptype}.${prop}=${escapePropValue(status[ptype][prop])}`);
      }
    }
  }

  return parts.join(' ');
};

export const formatRelaxedLine = (line: Buffer | string, suffix?: string) => {
  let result =
    line
      ?.toString('binary')
      // unfold
      .replace(/\r?\n/g, '')
      // key to lowercase, trim around :
      .replace(/^([^:]*):\s*/, (m, k) => k.toLowerCase().trim() + ':')
      // single WSP
      .replace(/\s+/g, ' ')
      .trim() + (suffix ? suffix : '');

  return Buffer.from(result, 'binary');
};

export const formatDomain = (domain: string) => {
  domain = domain.toLowerCase().trim();
  try {
    domain = punycode.toASCII(domain).toLowerCase().trim();
  } catch (err) {
    // ignore punycode errors
  }
  return domain;
};

export const getAlignment = (fromDomain: string, domainList: string[], strict: boolean = false) => {
  domainList = ([] as string[]).concat(domainList || []);
  if (strict) {
    fromDomain = formatDomain(fromDomain);
    for (let domain of domainList) {
      domain = formatDomain(psl.get(domain) || domain);
      if (formatDomain(domain) === fromDomain) {
        return domain;
      }
    }
  }

  // match org domains
  fromDomain = formatDomain(psl.get(fromDomain) || fromDomain);
  for (let domain of domainList) {
    domain = formatDomain(psl.get(domain) || domain);
    if (domain === fromDomain) {
      return domain;
    }
  }

  return false;
};

export const validateAlgorithm = (algorithm: string, strict: boolean) => {
  try {
    if (!algorithm || !/^[^-]+-[^-]+$/.test(algorithm)) {
      throw new Error('Invalid algorithm format');
    }

    let [signAlgo, hashAlgo] = algorithm.toLowerCase().split('-');

    if (!['rsa', 'ed25519'].includes(signAlgo)) {
      throw new Error('Unknown signing algorithm: ' + signAlgo);
    }

    if (!['sha256'].concat(!strict ? 'sha1' : []).includes(hashAlgo)) {
      throw new Error('Unknown hashing algorithm: ' + hashAlgo);
    }
  } catch (err: unknown) {
    if (err !== null && typeof err === 'object' && Object.hasOwn(err, 'code')) {
      (err as { code: string }).code = 'EINVALIDALGO';
    }
    throw err;
  }
};

export class CustomError extends Error {
  code: string;
  rr: string;
  constructor(message: string, code: string, rr?: string) {
    super(message);
    this.code = code;
    this.rr = rr ?? '';
  }
}

export { parseDkimHeaders };



---
File: /@zk-email/helpers/src/lib/fast-sha256.ts
---

// This is modified version of https://github.com/dchest/fast-sha256-js/blob/master/src/sha256.ts
// One modification is adding `cacheState` to Hash class (for partial SHA)
// TODO: Fork the repo and make the changes; consider upstream to original repo

// SHA-256 (+ HMAC and PBKDF2) for JavaScript.
//
// Written in 2014-2016 by Dmitry Chestnykh.
// Public domain, no warranty.
//
// Functions (accept and return Uint8Arrays):
//
//   sha256(message) -> hash
//   sha256.hmac(key, message) -> mac
//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk
//
//  Classes:
//
//   new sha256.Hash()
//   new sha256.HMAC(key)
//
export const digestLength: number = 32;
export const blockSize: number = 64;

// SHA-256 constants
const K = new Uint32Array([
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98,
  0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
  0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8,
  0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
  0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
  0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,
  0xc67178f2,
]);

function hashBlocks(w: Int32Array, v: Int32Array, p: Uint8Array, pos: number, len: number): number {
  let a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    u: number,
    i: number,
    j: number,
    t1: number,
    t2: number;
  while (len >= 64) {
    a = v[0];
    b = v[1];
    c = v[2];
    d = v[3];
    e = v[4];
    f = v[5];
    g = v[6];
    h = v[7];

    for (i = 0; i < 16; i++) {
      j = pos + i * 4;
      w[i] = ((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) | ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff);
    }

    for (i = 16; i < 64; i++) {
      u = w[i - 2];
      t1 = ((u >>> 17) | (u << (32 - 17))) ^ ((u >>> 19) | (u << (32 - 19))) ^ (u >>> 10);

      u = w[i - 15];
      t2 = ((u >>> 7) | (u << (32 - 7))) ^ ((u >>> 18) | (u << (32 - 18))) ^ (u >>> 3);

      w[i] = ((t1 + w[i - 7]) | 0) + ((t2 + w[i - 16]) | 0);
    }

    for (i = 0; i < 64; i++) {
      t1 =
        ((((((e >>> 6) | (e << (32 - 6))) ^ ((e >>> 11) | (e << (32 - 11))) ^ ((e >>> 25) | (e << (32 - 25)))) +
          ((e & f) ^ (~e & g))) |
          0) +
          ((h + ((K[i] + w[i]) | 0)) | 0)) |
        0;

      t2 =
        ((((a >>> 2) | (a << (32 - 2))) ^ ((a >>> 13) | (a << (32 - 13))) ^ ((a >>> 22) | (a << (32 - 22)))) +
          ((a & b) ^ (a & c) ^ (b & c))) |
        0;

      h = g;
      g = f;
      f = e;
      e = (d + t1) | 0;
      d = c;
      c = b;
      b = a;
      a = (t1 + t2) | 0;
    }

    v[0] += a;
    v[1] += b;
    v[2] += c;
    v[3] += d;
    v[4] += e;
    v[5] += f;
    v[6] += g;
    v[7] += h;

    pos += 64;
    len -= 64;
  }
  return pos;
}

// Hash implements SHA256 hash algorithm.
export class Hash {
  digestLength: number = digestLength;
  blockSize: number = blockSize;

  // Note: Int32Array is used instead of Uint32Array for performance reasons.
  private state: Int32Array = new Int32Array(8); // hash state
  private temp: Int32Array = new Int32Array(64); // temporary state
  private buffer: Uint8Array = new Uint8Array(128); // buffer for data to hash
  private bufferLength: number = 0; // number of bytes in buffer
  private bytesHashed: number = 0; // number of total bytes hashed

  finished: boolean = false; // indicates whether the hash was finalized

  constructor() {
    this.reset();
  }

  // Resets hash state making it possible
  // to re-use this instance to hash other data.
  reset(): this {
    this.state[0] = 0x6a09e667;
    this.state[1] = 0xbb67ae85;
    this.state[2] = 0x3c6ef372;
    this.state[3] = 0xa54ff53a;
    this.state[4] = 0x510e527f;
    this.state[5] = 0x9b05688c;
    this.state[6] = 0x1f83d9ab;
    this.state[7] = 0x5be0cd19;
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
    return this;
  }

  // Cleans internal buffers and re-initializes hash state.
  clean() {
    for (let i = 0; i < this.buffer.length; i++) {
      this.buffer[i] = 0;
    }
    for (let i = 0; i < this.temp.length; i++) {
      this.temp[i] = 0;
    }
    this.reset();
  }

  // Updates hash state with the given data.
  //
  // Optionally, length of the data can be specified to hash
  // fewer bytes than data.length.
  //
  // Throws error when trying to update already finalized hash:
  // instance must be reset to use it again.
  update(data: Uint8Array, dataLength: number = data.length): this {
    if (this.finished) {
      throw new Error("SHA256: can't update because hash was finished.");
    }
    let dataPos = 0;
    this.bytesHashed += dataLength;
    if (this.bufferLength > 0) {
      while (this.bufferLength < 64 && dataLength > 0) {
        this.buffer[this.bufferLength++] = data[dataPos++];
        dataLength--;
      }
      if (this.bufferLength === 64) {
        hashBlocks(this.temp, this.state, this.buffer, 0, 64);
        this.bufferLength = 0;
      }
    }
    if (dataLength >= 64) {
      dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
      dataLength %= 64;
    }
    while (dataLength > 0) {
      this.buffer[this.bufferLength++] = data[dataPos++];
      dataLength--;
    }
    return this;
  }

  // Finalizes hash state and puts hash into out.
  //
  // If hash was already finalized, puts the same value.
  finish(out: Uint8Array): this {
    if (!this.finished) {
      const bytesHashed = this.bytesHashed;
      const left = this.bufferLength;
      const bitLenHi = (bytesHashed / 0x20000000) | 0;
      const bitLenLo = bytesHashed << 3;
      const padLength = bytesHashed % 64 < 56 ? 64 : 128;

      this.buffer[left] = 0x80;
      for (let i = left + 1; i < padLength - 8; i++) {
        this.buffer[i] = 0;
      }
      this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;
      this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;
      this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;
      this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;
      this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;
      this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;
      this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;
      this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;

      hashBlocks(this.temp, this.state, this.buffer, 0, padLength);

      this.finished = true;
    }

    for (let i = 0; i < 8; i++) {
      out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;
      out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
      out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
      out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    }

    return this;
  }

  // Returns the final hash digest.
  digest(): Uint8Array {
    const out = new Uint8Array(this.digestLength);
    this.finish(out);
    return out;
  }

  // Returns the current hash state.
  cacheState(): Uint8Array {
    const out32 = new Uint32Array(this.state.length);
    this._saveState(out32);
    const out = new Uint8Array(this.state.length * 4);
    for (let i = 0; i < 8; i++) {
      out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;
      out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
      out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
      out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    }
    return out;
  }

  // Internal function for use in HMAC for optimization.
  _saveState(out: Uint32Array) {
    for (let i = 0; i < this.state.length; i++) {
      out[i] = this.state[i];
    }
  }

  // Internal function for use in HMAC for optimization.
  _restoreState(from: Uint32Array, bytesHashed: number) {
    for (let i = 0; i < this.state.length; i++) {
      this.state[i] = from[i];
    }
    this.bytesHashed = bytesHashed;
    this.finished = false;
    this.bufferLength = 0;
  }
}

// HMAC implements HMAC-SHA256 message authentication algorithm.
export class HMAC {
  private inner: Hash = new Hash();
  private outer: Hash = new Hash();

  blockSize: number = this.inner.blockSize;
  digestLength: number = this.inner.digestLength;

  // Copies of hash states after keying.
  // Need for quick reset without hashing they key again.
  private istate: Uint32Array;
  private ostate: Uint32Array;

  constructor(key: Uint8Array) {
    const pad = new Uint8Array(this.blockSize);
    if (key.length > this.blockSize) {
      new Hash().update(key).finish(pad).clean();
    } else {
      for (let i = 0; i < key.length; i++) {
        pad[i] = key[i];
      }
    }
    for (let i = 0; i < pad.length; i++) {
      pad[i] ^= 0x36;
    }
    this.inner.update(pad);

    for (let i = 0; i < pad.length; i++) {
      pad[i] ^= 0x36 ^ 0x5c;
    }
    this.outer.update(pad);

    this.istate = new Uint32Array(8);
    this.ostate = new Uint32Array(8);

    this.inner._saveState(this.istate);
    this.outer._saveState(this.ostate);

    for (let i = 0; i < pad.length; i++) {
      pad[i] = 0;
    }
  }

  // Returns HMAC state to the state initialized with key
  // to make it possible to run HMAC over the other data with the same
  // key without creating a new instance.
  reset(): this {
    this.inner._restoreState(this.istate, this.inner.blockSize);
    this.outer._restoreState(this.ostate, this.outer.blockSize);
    return this;
  }

  // Cleans HMAC state.
  clean() {
    for (let i = 0; i < this.istate.length; i++) {
      this.ostate[i] = this.istate[i] = 0;
    }
    this.inner.clean();
    this.outer.clean();
  }

  // Updates state with provided data.
  update(data: Uint8Array): this {
    this.inner.update(data);
    return this;
  }

  // Finalizes HMAC and puts the result in out.
  finish(out: Uint8Array): this {
    if (this.outer.finished) {
      this.outer.finish(out);
    } else {
      this.inner.finish(out);
      this.outer.update(out, this.digestLength).finish(out);
    }
    return this;
  }

  // Returns message authentication code.
  digest(): Uint8Array {
    const out = new Uint8Array(this.digestLength);
    this.finish(out);
    return out;
  }
}

// Returns SHA256 hash of data.
export function hash(data: Uint8Array): Uint8Array {
  const h = new Hash().update(data);
  const digest = h.digest();
  h.clean();
  return digest;
}

// Function hash is both available as module.hash and as default export.
export default hash;

// Returns HMAC-SHA256 of data under the key.
export function hmac(key: Uint8Array, data: Uint8Array) {
  const h = new HMAC(key).update(data);
  const digest = h.digest();
  h.clean();
  return digest;
}

// Fills hkdf buffer like this:
// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)
function fillBuffer(buffer: Uint8Array, hmac: HMAC, info: Uint8Array | undefined, counter: Uint8Array) {
  // Counter is a byte value: check if it overflowed.
  const num = counter[0];

  if (num === 0) {
    throw new Error('hkdf: cannot expand more');
  }

  // Prepare HMAC instance for new data with old key.
  hmac.reset();

  // Hash in previous output if it was generated
  // (i.e. counter is greater than 1).
  if (num > 1) {
    hmac.update(buffer);
  }

  // Hash in info if it exists.
  if (info) {
    hmac.update(info);
  }

  // Hash in the counter.
  hmac.update(counter);

  // Output result to buffer and clean HMAC instance.
  hmac.finish(buffer);

  // Increment counter inside typed array, this works properly.
  counter[0]++;
}

const hkdfSalt = new Uint8Array(digestLength); // Filled with zeroes.
export function hkdf(key: Uint8Array, salt: Uint8Array = hkdfSalt, info?: Uint8Array, length: number = 32) {
  const counter = new Uint8Array([1]);

  // HKDF-Extract uses salt as HMAC key, and key as data.
  const okm = hmac(salt, key);

  // Initialize HMAC for expanding with extracted key.
  // Ensure no collisions with `hmac` function.
  const hmac_ = new HMAC(okm);

  // Allocate buffer.
  const buffer = new Uint8Array(hmac_.digestLength);
  let bufpos = buffer.length;

  const out = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    if (bufpos === buffer.length) {
      fillBuffer(buffer, hmac_, info, counter);
      bufpos = 0;
    }
    out[i] = buffer[bufpos++];
  }

  hmac_.clean();
  buffer.fill(0);
  counter.fill(0);
  return out;
}

// Derives a key from password and salt using PBKDF2-HMAC-SHA256
// with the given number of iterations.
//
// The number of bytes returned is equal to dkLen.
//
// (For better security, avoid dkLen greater than hash length - 32 bytes).
export function pbkdf2(password: Uint8Array, salt: Uint8Array, iterations: number, dkLen: number) {
  const prf = new HMAC(password);
  const len = prf.digestLength;
  const ctr = new Uint8Array(4);
  const t = new Uint8Array(len);
  const u = new Uint8Array(len);
  const dk = new Uint8Array(dkLen);

  for (let i = 0; i * len < dkLen; i++) {
    let c = i + 1;
    ctr[0] = (c >>> 24) & 0xff;
    ctr[1] = (c >>> 16) & 0xff;
    ctr[2] = (c >>> 8) & 0xff;
    ctr[3] = (c >>> 0) & 0xff;
    prf.reset();
    prf.update(salt);
    prf.update(ctr);
    prf.finish(u);
    for (let j = 0; j < len; j++) {
      t[j] = u[j];
    }
    for (let j = 2; j <= iterations; j++) {
      prf.reset();
      prf.update(u).finish(u);
      for (let k = 0; k < len; k++) {
        t[k] ^= u[k];
      }
    }
    for (let j = 0; j < len && i * len + j < dkLen; j++) {
      dk[i * len + j] = t[j];
    }
  }
  for (let i = 0; i < len; i++) {
    t[i] = u[i] = 0;
  }
  for (let i = 0; i < 4; i++) {
    ctr[i] = 0;
  }
  prf.clean();
  return dk;
}



---
File: /@zk-email/helpers/src/binary-format.ts
---

import { CIRCOM_BIGINT_N, CIRCOM_BIGINT_K } from './constants';

export function bytesToString(bytes: Uint8Array): string {
  return new TextDecoder().decode(bytes);
}

// stringToUint8Array
export function stringToBytes(str: string) {
  // const encodedText = new TextEncoder().encode(str);
  const toReturn = Uint8Array.from(str, (x) => x.charCodeAt(0));
  //   const buf = Buffer.from(str, "utf8");
  return toReturn;
  // TODO: Check encoding mismatch if the proof doesnt work
  // Note that our custom encoding function maps (239, 191, 189) -> (253)
  // Note that our custom encoding function maps (207, 181) -> (245)
  // throw Error(
  //   "TextEncoder does not match string2bytes function" +
  //     "\n" +
  //     str +
  //     "\n" +
  //     buf +
  //     "\n" +
  //     Uint8Array.from(buf) +
  //     "\n" +
  //     JSON.stringify(encodedText) +
  //     "\n" +
  //     JSON.stringify(toReturn)
  // );
}

export function bufferToUint8Array(buf: Buffer): Uint8Array {
  const ab = new ArrayBuffer(buf.length);
  const view = new Uint8Array(ab);
  for (let i = 0; i < buf.length; ++i) {
    view[i] = buf[i];
  }
  return Uint8Array.from(view);
}

export function bufferToHex(buf: Buffer): String {
  return buf.toString('hex');
}

export function Uint8ArrayToCharArray(a: Uint8Array): string[] {
  return Array.from(a).map((x) => x.toString());
}

export async function Uint8ArrayToString(a: Uint8Array): Promise<string> {
  return Array.from(a)
    .map((x) => x.toString())
    .join(';');
}

export async function Uint8ArrayToHex(a: Uint8Array): Promise<string> {
  return Buffer.from(a).toString('hex');
}

export function bufferToString(buf: Buffer): String {
  const intermediate = bufferToUint8Array(buf);
  return bytesToString(intermediate);
}

export function bytesToBigInt(bytes: Uint8Array) {
  let res = 0n;
  for (let i = 0; i < bytes.length; ++i) {
    res = (res << 8n) + BigInt(bytes[i]);
  }
  return res;
}

export function bigIntToChunkedBytes(num: BigInt | bigint, bytesPerChunk: number, numChunks: number) {
  const res = [];
  const bigintNum: bigint = typeof num === 'bigint' ? num : num.valueOf();
  const msk = (1n << BigInt(bytesPerChunk)) - 1n;
  for (let i = 0; i < numChunks; ++i) {
    res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());
  }
  return res;
}

export function toCircomBigIntBytes(num: BigInt | bigint) {
  return bigIntToChunkedBytes(num, CIRCOM_BIGINT_N, CIRCOM_BIGINT_K);
}

// https://stackoverflow.com/a/69585881
const HEX_STRINGS = '0123456789abcdef';
const MAP_HEX = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
} as const;

// Fast Uint8Array to hex
export function toHex(bytes: Uint8Array): string {
  return Array.from(bytes || [])
    .map((b) => HEX_STRINGS[b >> 4] + HEX_STRINGS[b & 15])
    .join('');
}

// Mimics Buffer.from(x, 'hex') logic
// Stops on first non-hex string and returns
// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261
export function fromHex(hexString: string): Uint8Array {
  let hexStringTrimmed: string = hexString;
  if (hexString[0] === '0' && hexString[1] === 'x') {
    hexStringTrimmed = hexString.slice(2);
  }
  const bytes = new Uint8Array(Math.floor((hexStringTrimmed || '').length / 2));
  let i;
  for (i = 0; i < bytes.length; i++) {
    const a = MAP_HEX[hexStringTrimmed[i * 2] as keyof typeof MAP_HEX];
    const b = MAP_HEX[hexStringTrimmed[i * 2 + 1] as keyof typeof MAP_HEX];
    if (a === undefined || b === undefined) {
      break;
    }
    bytes[i] = (a << 4) | b;
  }
  return i === bytes.length ? bytes : bytes.slice(0, i);
}

// Works only on 32 bit sha text lengths
export function int64toBytes(num: number): Uint8Array {
  const arr = new ArrayBuffer(8); // an Int32 takes 4 bytes
  const view = new DataView(arr);
  view.setInt32(4, num, false); // byteOffset = 0; litteEndian = false
  return new Uint8Array(arr);
}

// Works only on 32 bit sha text lengths
export function int8toBytes(num: number): Uint8Array {
  const arr = new ArrayBuffer(1); // an Int8 takes 4 bytes
  const view = new DataView(arr);
  view.setUint8(0, num); // byteOffset = 0; litteEndian = false
  return new Uint8Array(arr);
}

export function bitsToUint8(bits: string[]): Uint8Array {
  const bytes = new Uint8Array(bits.length);
  for (let i = 0; i < bits.length; i += 1) {
    bytes[i] = parseInt(bits[i], 2);
  }
  return bytes;
}

export function uint8ToBits(uint8: Uint8Array): string {
  return uint8.reduce((acc, byte) => acc + byte.toString(2).padStart(8, '0'), '');
}

export function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {
  // sum of individual array lengths
  const mergedArray = new Uint8Array(a1.length + a2.length);
  mergedArray.set(a1);
  mergedArray.set(a2, a1.length);
  return mergedArray;
}

export function assert(cond: boolean, errorMessage: string) {
  if (!cond) {
    throw new Error(errorMessage);
  }
}

export function packedNBytesToString(packedBytes: bigint[], n: number = 31): string {
  const chars: number[] = [];
  for (let i = 0; i < packedBytes.length; i++) {
    for (let k = 0n; k < n; k++) {
      chars.push(Number((packedBytes[i] >> (k * 8n)) % 256n));
    }
  }
  return bytesToString(Uint8Array.from(chars));
}

export function packBytesIntoNBytes(messagePaddedRaw: Uint8Array | string, n = 7): Array<bigint> {
  const messagePadded: Uint8Array =
    typeof messagePaddedRaw === 'string' ? stringToBytes(messagePaddedRaw) : messagePaddedRaw;
  const output: Array<bigint> = [];
  for (let i = 0; i < messagePadded.length; i++) {
    if (i % n === 0) {
      output.push(0n);
    }
    const j = (i / n) | 0;
    console.assert(
      j === output.length - 1,
      'Not editing the index of the last element -- packing loop invariants bug!',
    );
    output[j] += BigInt(messagePadded[i]) << BigInt((i % n) * 8);
  }
  return output;
}
// Usage: let in_padded_n_bytes = packBytesIntoNBytes(messagePadded, 7).map((x) => x.toString()); // Packed into 7 byte signals

// console.log(packedNBytesToString([30680772461461504n, 129074054722665n, 30794022159122432n, 30803244232763745n]));



---
File: /@zk-email/helpers/src/chunked-zkey.ts
---

import localforage from 'localforage';
// @ts-ignore
import pako from 'pako';
// @ts-ignore
import * as snarkjs from 'snarkjs';

const zkeyExtension = '.gz';
const zkeyExtensionRegEx = new RegExp(`\\b${zkeyExtension}$\\b`, 'i'); // = /.gz$/i
const zkeySuffix = ['b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'];

// uncompresses single .gz file.
// returns the contents as an ArrayBuffer
export const uncompressGz = async (arrayBuffer: ArrayBuffer): Promise<ArrayBuffer> => {
  const output = pako.ungzip(arrayBuffer);
  const buff = output.buffer;
  return buff;
};

// We can use this function to ensure the type stored in localforage is correct.
async function storeArrayBuffer(keyname: string, buffer: ArrayBuffer) {
  return localforage.setItem(keyname, buffer);
}

async function downloadWithRetries(link: string, downloadAttempts: number) {
  for (let i = 1; i <= downloadAttempts; i++) {
    console.log(`download attempt ${i} for ${link}`);
    const response = await fetch(link, { method: 'GET' });
    if (response.status === 200) {
      return response;
    }
  }
  throw new Error(`Error downloading ${link} after ${downloadAttempts} retries`);
}

// GET the compressed file from the remote server, then store it with localforage
// Note that it must be stored as an uncompressed ArrayBuffer
// and named such that filename===`${name}.zkey${a}` in order for it to be found by snarkjs.
export async function downloadFromFilename(baseUrl: string, filename: string, compressed = false) {
  const link = baseUrl + filename;

  const zkeyResp = await downloadWithRetries(link, 3);

  const zkeyBuff = await zkeyResp.arrayBuffer();
  if (!compressed) {
    await storeArrayBuffer(filename, zkeyBuff);
  } else {
    // uncompress the data
    const zkeyUncompressed = await uncompressGz(zkeyBuff);
    const rawFilename = filename.replace(zkeyExtensionRegEx, ''); // replace .gz with ""
    // store the uncompressed data
    console.log('storing file in localforage', rawFilename);
    await storeArrayBuffer(rawFilename, zkeyUncompressed);
    console.log('stored file in localforage', rawFilename);
    // await localforage.setItem(filename, zkeyBuff);
  }
  console.log(`Storage of ${filename} successful!`);
}

export async function downloadProofFiles(baseUrl: string, circuitName: string, onFileDownloaded: () => void) {
  const filePromises = [];
  for (const c of zkeySuffix) {
    const targzFilename = `${circuitName}.zkey${c}${zkeyExtension}`;
    // const itemCompressed = await localforage.getItem(targzFilename);
    const item = await localforage.getItem(`${circuitName}.zkey${c}`);
    if (item) {
      console.log(`${circuitName}.zkey${c}${item ? '' : zkeyExtension} already found in localforage!`);
      onFileDownloaded();
      continue;
    }
    filePromises.push(downloadFromFilename(baseUrl, targzFilename, true).then(() => onFileDownloaded()));
  }
  console.log(filePromises);
  await Promise.all(filePromises);
}

export async function generateProof(input: any, baseUrl: string, circuitName: string) {
  // TODO: figure out how to generate this s.t. it passes build
  console.log('generating proof for input');
  console.log(input);
  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    input,
    `${baseUrl}${circuitName}.wasm`,
    `${circuitName}.zkey`,
  );
  console.log(`Generated proof ${JSON.stringify(proof)}`);

  return {
    proof,
    publicSignals,
  };
}

export async function verifyProof(proof: any, publicSignals: any, baseUrl: string, circuitName: string) {
  console.log('PROOF', proof);
  console.log('PUBLIC SIGNALS', publicSignals);

  const response = await downloadWithRetries(`${baseUrl}${circuitName}.vkey.json`, 3);
  const vkey = await response.json();
  console.log('vkey', vkey);

  const proofVerified = await snarkjs.groth16.verify(vkey, publicSignals, proof);
  console.log('proofV', proofVerified);

  return proofVerified;
}

function bigIntToArray(n: number, k: number, x: bigint) {
  let divisor = 1n;
  for (let idx = 0; idx < n; idx++) {
    divisor *= 2n;
  }

  const ret = [];
  let temp = BigInt(x);
  for (let idx = 0; idx < k; idx++) {
    ret.push(temp % divisor);
    temp /= divisor;
  }
  return ret;
}

// taken from generation code in dizkus-circuits tests
function pubkeyToXYArrays(pk: string) {
  const XArr = bigIntToArray(64, 4, BigInt(`0x${pk.slice(4, 4 + 64)}`)).map((el) => el.toString());
  const YArr = bigIntToArray(64, 4, BigInt(`0x${pk.slice(68, 68 + 64)}`)).map((el) => el.toString());

  return [XArr, YArr];
}

// taken from generation code in dizkus-circuits tests
function sigToRSArrays(sig: string) {
  const rArr = bigIntToArray(64, 4, BigInt(`0x${sig.slice(2, 2 + 64)}`)).map((el) => el.toString());
  const sArr = bigIntToArray(64, 4, BigInt(`0x${sig.slice(66, 66 + 64)}`)).map((el) => el.toString());

  return [rArr, sArr];
}

export function buildInput(pubkey: string, msghash: string, sig: string) {
  const [r, s] = sigToRSArrays(sig);

  return {
    r,
    s,
    msghash: bigIntToArray(64, 4, BigInt(msghash)),
    pubkey: pubkeyToXYArrays(pubkey),
  };
}



---
File: /@zk-email/helpers/src/constants.ts
---

export const CIRCOM_FIELD_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
export const MAX_HEADER_PADDED_BYTES = 1024; // Default value for max size to be used in circuit
export const MAX_BODY_PADDED_BYTES = 1536; // Default value for max size to be used in circuit

export const CIRCOM_BIGINT_N = 121;
export const CIRCOM_BIGINT_K = 17;
export const CIRCOM_LEVELS = 30;



---
File: /@zk-email/helpers/src/hash.ts
---

import { buildPoseidon } from 'circomlibjs';
import { bigIntToChunkedBytes } from './binary-format';

export async function poseidonLarge(input: bigint, numChunks: number, bitsPerChunk: number) {
  const poseidon = await buildPoseidon();
  const pubkeyChunked = bigIntToChunkedBytes(input, bitsPerChunk, numChunks);
  const hash = poseidon(pubkeyChunked);

  return poseidon.F.toObject(hash) as Promise<bigint>;
}



---
File: /@zk-email/helpers/src/index.ts
---

export * from './binary-format';
export * from './constants';
export * from './input-generators';
export * from './sha-utils';



---
File: /@zk-email/helpers/src/input-generators.ts
---

import { Uint8ArrayToCharArray, toCircomBigIntBytes } from './binary-format';
import { MAX_BODY_PADDED_BYTES, MAX_HEADER_PADDED_BYTES } from './constants';
import { DKIMVerificationResult, verifyDKIMSignature } from './dkim';
import { generatePartialSHA, sha256Pad } from './sha-utils';

type CircuitInput = {
  emailHeader: string[];
  emailHeaderLength: string;
  pubkey: string[];
  signature: string[];
  emailBody?: string[];
  emailBodyLength?: string;
  precomputedSHA?: string[];
  bodyHashIndex?: string;
  decodedEmailBodyIn?: string[];
  headerMask?: number[];
  bodyMask?: number[];
};

type InputGenerationArgs = {
  ignoreBodyHashCheck?: boolean;
  enableHeaderMasking?: boolean;
  enableBodyMasking?: boolean;
  shaPrecomputeSelector?: string;
  maxHeadersLength?: number; // Max length of the email header including padding
  maxBodyLength?: number; // Max length of the email body after shaPrecomputeSelector including padding
  removeSoftLineBreaks?: boolean;
  headerMask?: number[];
  bodyMask?: number[];
};

type DKIMVerificationArgs = {
  domain?: string;
  enableSanitization?: boolean;
  fallbackToZKEmailDNSArchive?: boolean;
};

function removeSoftLineBreaks(body: string[]): string[] {
  const result = [];
  let i = 0;
  while (i < body.length) {
    if (
      i + 2 < body.length &&
      body[i] === '61' && // '=' character
      body[i + 1] === '13' && // '\r' character
      body[i + 2] === '10'
    ) {
      // '\n' character
      // Skip the soft line break sequence
      i += 3; // Move past the soft line break
    } else {
      result.push(body[i]);
      i++;
    }
  }
  // Pad the result with zeros to make it the same length as the body
  while (result.length < body.length) {
    result.push('0');
  }
  return result;
}

/**
 *
 * @description Generate circuit inputs for the EmailVerifier circuit from raw email content
 * @param rawEmail Full email content as a buffer or string
 * @param inputParams Arguments to control the input generation
 * @param dkimVerificationArgs Arguments to control the DKIM verification
 * @returns Circuit inputs for the EmailVerifier circuit
 */
export async function generateEmailVerifierInputs(
  rawEmail: Buffer | string,
  inputParams: InputGenerationArgs = {},
  dkimVerificationArgs: DKIMVerificationArgs = {},
) {
  const dkimResult = await verifyDKIMSignature(
    rawEmail,
    dkimVerificationArgs.domain,
    dkimVerificationArgs.enableSanitization,
    dkimVerificationArgs.fallbackToZKEmailDNSArchive,
  );

  return generateEmailVerifierInputsFromDKIMResult(dkimResult, inputParams);
}

/**
 *
 * @description Generate circuit inputs for the EmailVerifier circuit from DKIMVerification result
 * @param dkimResult DKIMVerificationResult containing email data and verification result
 * @param params Arguments to control the input generation
 * @returns Circuit inputs for the EmailVerifier circuit
 */
export function generateEmailVerifierInputsFromDKIMResult(
  dkimResult: DKIMVerificationResult,
  params: InputGenerationArgs = {},
): CircuitInput {
  const { headers, body, bodyHash, publicKey, signature } = dkimResult;

  // SHA add padding
  const [messagePadded, messagePaddedLen] = sha256Pad(headers, params.maxHeadersLength || MAX_HEADER_PADDED_BYTES);

  const circuitInputs: CircuitInput = {
    emailHeader: Uint8ArrayToCharArray(messagePadded), // Packed into 1 byte signals
    emailHeaderLength: messagePaddedLen.toString(),
    pubkey: toCircomBigIntBytes(publicKey),
    signature: toCircomBigIntBytes(signature),
  };

  if (params.enableHeaderMasking) {
    circuitInputs.headerMask = params.headerMask;
  }

  if (!params.ignoreBodyHashCheck) {
    if (!body || !bodyHash) {
      throw new Error('body and bodyHash are required when ignoreBodyHashCheck is false');
    }

    const bodyHashIndex = headers.toString().indexOf(bodyHash);
    const maxBodyLength = params.maxBodyLength || MAX_BODY_PADDED_BYTES;

    // 65 comes from the 64 at the end and the 1 bit in the start, then 63 comes from the formula to round it up to the nearest 64.
    // see sha256algorithm.com for a more full explanation of padding length
    const bodySHALength = Math.floor((body.length + 63 + 65) / 64) * 64;
    const [bodyPadded, bodyPaddedLen] = sha256Pad(body, Math.max(maxBodyLength, bodySHALength));

    const { precomputedSha, bodyRemaining, bodyRemainingLength } = generatePartialSHA({
      body: bodyPadded,
      bodyLength: bodyPaddedLen,
      selectorString: params.shaPrecomputeSelector,
      maxRemainingBodyLength: maxBodyLength,
    });

    circuitInputs.emailBodyLength = bodyRemainingLength.toString();
    circuitInputs.precomputedSHA = Uint8ArrayToCharArray(precomputedSha);
    circuitInputs.bodyHashIndex = bodyHashIndex.toString();
    circuitInputs.emailBody = Uint8ArrayToCharArray(bodyRemaining);

    if (params.removeSoftLineBreaks) {
      circuitInputs.decodedEmailBodyIn = removeSoftLineBreaks(circuitInputs.emailBody);
    }

    if (params.enableBodyMasking) {
      circuitInputs.bodyMask = params.bodyMask;
    }
  }

  return circuitInputs;
}



---
File: /@zk-email/helpers/src/sha-utils.ts
---

import * as CryptoJS from 'crypto';
import { assert, int64toBytes, int8toBytes, mergeUInt8Arrays } from './binary-format';
import { Hash } from './lib/fast-sha256';

export function findIndexInUint8Array(array: Uint8Array, selector: Uint8Array): number {
  let i = 0;
  let j = 0;
  while (i < array.length) {
    if (array[i] === selector[j]) {
      j++;
      if (j === selector.length) {
        return i - j + 1;
      }
    } else {
      j = 0;
    }
    i++;
  }
  return -1;
}

export function padUint8ArrayWithZeros(array: Uint8Array, length: number) {
  while (array.length < length) {
    // eslint-disable-next-line no-param-reassign
    array = mergeUInt8Arrays(array, int8toBytes(0));
  }
  return array;
}

export function generatePartialSHA({
  body,
  bodyLength,
  selectorString, // String to split the body
  maxRemainingBodyLength, // Maximum allowed length of the body after the selector
}: {
  body: Uint8Array;
  bodyLength: number;
  selectorString?: string;
  maxRemainingBodyLength: number;
}) {
  let selectorIndex = 0;

  if (selectorString) {
    const selector = new TextEncoder().encode(selectorString);
    selectorIndex = findIndexInUint8Array(body, selector);

    if (selectorIndex === -1) {
      throw new Error(`SHA precompute selector "${selectorString}" not found in the body`);
    }
  }

  const shaCutoffIndex = Math.floor(selectorIndex / 64) * 64;
  const precomputeText = body.slice(0, shaCutoffIndex);
  let bodyRemaining = body.slice(shaCutoffIndex);

  const bodyRemainingLength = bodyLength - precomputeText.length;

  if (bodyRemainingLength > maxRemainingBodyLength) {
    throw new Error(
      `Remaining body ${bodyRemainingLength} after the selector is longer than max (${maxRemainingBodyLength})`,
    );
  }

  if (bodyRemaining.length % 64 !== 0) {
    throw new Error('Remaining body was not padded correctly with int64s');
  }

  bodyRemaining = padUint8ArrayWithZeros(bodyRemaining, maxRemainingBodyLength);
  const precomputedSha = partialSha(precomputeText, shaCutoffIndex);

  return {
    precomputedSha,
    bodyRemaining,
    bodyRemainingLength,
  };
}

export function shaHash(str: Uint8Array) {
  return CryptoJS.createHash('sha256').update(str).digest();
}

export function partialSha(msg: Uint8Array, msgLen: number): Uint8Array {
  const shaGadget = new Hash();
  return shaGadget.update(msg, msgLen).cacheState();
}

// Puts an end selector, a bunch of 0s, then the length, then fill the rest with 0s.
export function sha256Pad(message: Uint8Array, maxShaBytes: number): [Uint8Array, number] {
  const msgLen = message.length * 8; // bytes to bits
  const msgLenBytes = int64toBytes(msgLen);

  let res = mergeUInt8Arrays(message, int8toBytes(2 ** 7)); // Add the 1 on the end, length 505
  // while ((prehash_prepad_m.length * 8 + length_in_bytes.length * 8) % 512 !== 0) {
  while ((res.length * 8 + msgLenBytes.length * 8) % 512 !== 0) {
    res = mergeUInt8Arrays(res, int8toBytes(0));
  }

  res = mergeUInt8Arrays(res, msgLenBytes);
  assert((res.length * 8) % 512 === 0, 'Padding did not complete properly!');
  const messageLen = res.length;
  while (res.length < maxShaBytes) {
    res = mergeUInt8Arrays(res, int64toBytes(0));
  }

  assert(
    res.length === maxShaBytes,
    `Padding to max length did not complete properly! Your padded message is ${res.length} long but max is ${maxShaBytes}!`,
  );

  return [res, messageLen];
}



---
File: /@zk-email/relayer-utils/relayer_utils_bg.js
---

let wasm;
export function __wbg_set_wasm(val) {
    wasm = val;
}


const lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;

let cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

let WASM_VECTOR_LEN = 0;

const lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;

let cachedTextEncoder = new lTextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

const CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(state => {
    wasm.__wbindgen_export_3.get(state.dtor)(state.a, state.b)
});

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_3.get(state.dtor)(a, state.b);
                CLOSURE_DTORS.unregister(state);
            } else {
                state.a = a;
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}
function __wbg_adapter_54(arg0, arg1, arg2) {
    wasm.closure461_externref_shim(arg0, arg1, arg2);
}

/**
 * Parses a raw email string into a structured `ParsedEmail` object.
 *
 * This function utilizes the `ParsedEmail::new_from_raw_email` method to parse the email,
 * and then serializes the result for JavaScript interoperability.
 *
 * # Arguments
 *
 * * `raw_email` - A `String` representing the raw email to be parsed.
 *
 * # Returns
 *
 * A `Promise` that resolves with the serialized `ParsedEmail` or rejects with an error message.
 * @param {string} raw_email
 * @returns {Promise<Promise<any>>}
 */
export function parseEmail(raw_email) {
    const ptr0 = passStringToWasm0(raw_email, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.parseEmail(ptr0, len0);
    return ret;
}

/**
 * Generates a new `AccountCode` using a secure random number generator.
 *
 * This function creates a new `AccountCode` and serializes it for JavaScript interoperability.
 *
 * # Returns
 *
 * A `Promise` that resolves with the serialized `AccountCode` or rejects with an error message.
 * @returns {Promise<Promise<any>>}
 */
export function generateAccountCode() {
    const ret = wasm.generateAccountCode();
    return ret;
}

/**
 * Generates an `AccountSalt` using a padded email address and an account code.
 *
 * This function converts the email address to a padded format, parses the account code,
 * and generates an `AccountSalt`, which is then serialized for JavaScript interoperability.
 *
 * # Arguments
 *
 * * `email_addr` - A `String` representing the email address.
 * * `account_code` - A `String` representing the account code in hexadecimal format.
 *
 * # Returns
 *
 * A `Promise` that resolves with the serialized `AccountSalt` or rejects with an error message.
 * @param {string} email_addr
 * @param {string} account_code
 * @returns {Promise<Promise<any>>}
 */
export function generateAccountSalt(email_addr, account_code) {
    const ptr0 = passStringToWasm0(email_addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(account_code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.generateAccountSalt(ptr0, len0, ptr1, len1);
    return ret;
}

/**
 * Pads an email address to a fixed length format.
 *
 * This function converts the email address to a padded format and serializes it
 * for JavaScript interoperability.
 *
 * # Arguments
 *
 * * `email_addr` - A `String` representing the email address to be padded.
 *
 * # Returns
 *
 * A `Promise` that resolves with the serialized padded email address or rejects with an error message.
 * @param {string} email_addr
 * @returns {Promise<Promise<any>>}
 */
export function padEmailAddr(email_addr) {
    const ptr0 = passStringToWasm0(email_addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.padEmailAddr(ptr0, len0);
    return ret;
}

/**
 * @param {string} email_addr
 * @param {any} decomposed_regexes
 * @param {any} external_inputs
 * @param {any} params
 * @returns {Promise<Promise<any>>}
 */
export function generateCircuitInputsWithDecomposedRegexesAndExternalInputs(email_addr, decomposed_regexes, external_inputs, params) {
    const ptr0 = passStringToWasm0(email_addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.generateCircuitInputsWithDecomposedRegexesAndExternalInputs(ptr0, len0, decomposed_regexes, external_inputs, params);
    return ret;
}

/**
 * Pads data for SHA-256 and extends it to a specified maximum length.
 *
 * This function pads the input data according to SHA-256 specifications and extends
 * it to a given maximum length. It returns both the padded data and the original
 * message length.
 *
 * # Arguments
 *
 * * `data` - A `Uint8Array` containing the data to be padded.
 * * `max_sha_bytes` - The maximum length in bytes to which the data should be extended.
 *
 * # Returns
 *
 * A `Promise` that resolves with an object containing the padded data and message length,
 * or rejects with an error message.
 * @param {any} data
 * @param {number} max_sha_bytes
 * @returns {Promise<Promise<any>>}
 */
export function sha256Pad(data, max_sha_bytes) {
    const ret = wasm.sha256Pad(data, max_sha_bytes);
    return ret;
}

/**
 * Computes the Poseidon hash of a public key.
 *
 * # Arguments
 *
 * * `public_key_n` - A `Uint8Array` containing the public key in little endian format.
 *
 * # Returns
 *
 * A `Promise` that resolves with the hexadecimal string representation of the hash,
 * or rejects with an error message.
 * @param {any} public_key_n
 * @returns {Promise<Promise<any>>}
 */
export function publicKeyHash(public_key_n) {
    const ret = wasm.publicKeyHash(public_key_n);
    return ret;
}

/**
 * Generates the circuit inputs for email verification circuits using the given email data, account code, and optional parameters.
 *
 * # Arguments
 *
 * * `email` - A `String` representing the raw email data to be verified.
 * * `account_code` - A `String` representing the account code in hexadecimal format.
 * * `params` - An object representing the optional parameters for the circuit.
 *
 * # Returns
 *
 * A `Promise` that resolves with the serialized `CircuitInputs` or rejects with an error message.
 * @param {string} email
 * @param {string} account_code
 * @param {any} params
 * @returns {Promise<Promise<any>>}
 */
export function generateEmailCircuitInput(email, account_code, params) {
    const ptr0 = passStringToWasm0(email, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(account_code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.generateEmailCircuitInput(ptr0, len0, ptr1, len1, params);
    return ret;
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
 * Extracts the randomness from a given signature in the same manner as circuits.
 *
 * # Arguments
 *
 * * `signature` - A `Uint8Array` containing the signature data.
 *
 * # Returns
 *
 * A `Promise` that resolves with the extracted randomness as a hexadecimal string, or rejects with an error message.
 * @param {Uint8Array} signautre
 * @returns {Promise<Promise<any>>}
 */
export function extractRandFromSignature(signautre) {
    const ptr0 = passArray8ToWasm0(signautre, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractRandFromSignature(ptr0, len0);
    return ret;
}

/**
 * Commits an email address using a given signature as the randomness.
 *
 * # Arguments
 *
 * * `email_addr` - A `String` representing the email address to be committed.
 * * `signature` - A `Uint8Array` containing the signature data to be used as randomness.
 *
 * # Returns
 *
 * A `Promise` that resolves with the commitment as a hexadecimal string, or rejects with an error message.
 * @param {string} email_addr
 * @param {Uint8Array} signautre
 * @returns {Promise<Promise<any>>}
 */
export function emailAddrCommitWithSignature(email_addr, signautre) {
    const ptr0 = passStringToWasm0(email_addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArray8ToWasm0(signautre, wasm.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.emailAddrCommitWithSignature(ptr0, len0, ptr1, len1);
    return ret;
}

/**
 * Converts a byte array to a list of field elements.
 *
 * # Arguments
 *
 * * `bytes` - A `Uint8Array` containing the byte array to convert.
 *
 * # Returns
 *
 * A `Promise` that resolves with a list of field elements as hexadecimal strings, or rejects with an error message.
 * @param {any} bytes
 * @returns {Promise<Promise<any>>}
 */
export function bytesToFields(bytes) {
    const ret = wasm.bytesToFields(bytes);
    return ret;
}

/**
 * Computes the nullifier for an email address using a given signature.
 *
 * # Arguments
 *
 * * `signature` - A `Uint8Array` containing the signature data to be used for the nullifier.
 *
 * # Returns
 *
 * A `Promise` that resolves with the email nullifier as a hexadecimal string, or rejects with an error message.
 * @param {Uint8Array} signautre
 * @returns {Promise<Promise<any>>}
 */
export function emailNullifier(signautre) {
    const ptr0 = passArray8ToWasm0(signautre, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.emailNullifier(ptr0, len0);
    return ret;
}

function takeFromExternrefTable0(idx) {
    const value = wasm.__wbindgen_export_2.get(idx);
    wasm.__externref_table_dealloc(idx);
    return value;
}
/**
 * Extracts the indices of the invitation code in the given input string.
 *
 * # Arguments
 *
 * * `inputStr` - A `String` representing the input string to extract the invitation code indices from.
 *
 * # Returns
 *
 * A `Promise` that resolves with an array of arrays containing the start and end indices of the invitation code substrings,
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractInvitationCodeIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractInvitationCodeIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * Extracts the indices of the invitation code with prefix in the given input string.
 *
 * # Arguments
 *
 * * `inputStr` - A `String` representing the input string to extract the invitation code indices from.
 *
 * # Returns
 *
 * A `Promise` that resolves with an array of arrays containing the start and end indices of the invitation code substrings,
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractInvitationCodeWithPrefixIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractInvitationCodeWithPrefixIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

function notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; }

function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_2.set(idx, obj);
    return idx;
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        const idx = addToExternrefTable0(e);
        wasm.__wbindgen_exn_store(idx);
    }
}
/**
 * @param {string} str
 * @param {number} paddedBytesSize
 * @returns {Array<any>}
 */
export function padString(str, paddedBytesSize) {
    const ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.padString(ptr0, len0, paddedBytesSize);
    return ret;
}

/**
 * @param {string} inputStr
 * @param {any} regexConfig
 * @param {boolean} reveal_private
 * @returns {Array<any>}
 */
export function extractSubstrIdxes(inputStr, regexConfig, reveal_private) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractSubstrIdxes(ptr0, len0, regexConfig, reveal_private);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @param {any} regexConfig
 * @param {boolean} reveal_private
 * @returns {Array<any>}
 */
export function extractSubstr(inputStr, regexConfig, reveal_private) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractSubstr(ptr0, len0, regexConfig, reveal_private);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractEmailAddrIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractEmailAddrIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractEmailDomainIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractEmailDomainIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractFromAllIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractFromAllIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractFromAddrIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractFromAddrIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractToAllIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractToAllIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractToAddrIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractToAddrIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractSubjectAllIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractSubjectAllIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractBodyHashIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractBodyHashIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractTimestampIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractTimestampIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

/**
 * @param {string} inputStr
 * @returns {Array<any>}
 */
export function extractMessageIdIdxes(inputStr) {
    const ptr0 = passStringToWasm0(inputStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.extractMessageIdIdxes(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
}

function __wbg_adapter_190(arg0, arg1, arg2, arg3) {
    wasm.closure652_externref_shim(arg0, arg1, arg2, arg3);
}

const __wbindgen_enum_BinaryType = ["blob", "arraybuffer"];

const __wbindgen_enum_RequestCredentials = ["omit", "same-origin", "include"];

const __wbindgen_enum_RequestMode = ["same-origin", "no-cors", "cors", "navigate"];

export function __wbindgen_string_new(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
};

export function __wbindgen_is_null(arg0) {
    const ret = arg0 === null;
    return ret;
};

export function __wbindgen_cb_drop(arg0) {
    const obj = arg0.original;
    if (obj.cnt-- == 1) {
        obj.a = 0;
        return true;
    }
    const ret = false;
    return ret;
};

export function __wbindgen_is_bigint(arg0) {
    const ret = typeof(arg0) === 'bigint';
    return ret;
};

export function __wbindgen_bigint_from_u64(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return ret;
};

export function __wbindgen_jsval_eq(arg0, arg1) {
    const ret = arg0 === arg1;
    return ret;
};

export function __wbindgen_error_new(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return ret;
};

export function __wbindgen_boolean_get(arg0) {
    const v = arg0;
    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
    return ret;
};

export function __wbindgen_string_get(arg0, arg1) {
    const obj = arg1;
    const ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
};

export function __wbindgen_is_object(arg0) {
    const val = arg0;
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
};

export function __wbindgen_is_undefined(arg0) {
    const ret = arg0 === undefined;
    return ret;
};

export function __wbindgen_in(arg0, arg1) {
    const ret = arg0 in arg1;
    return ret;
};

export function __wbindgen_is_string(arg0) {
    const ret = typeof(arg0) === 'string';
    return ret;
};

export function __wbindgen_as_number(arg0) {
    const ret = +arg0;
    return ret;
};

export function __wbg_new_abda76e883ba8a5f() {
    const ret = new Error();
    return ret;
};

export function __wbg_stack_658279fe44541cf6(arg0, arg1) {
    const ret = arg1.stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
};

export function __wbg_error_f851667af71bcfc6(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
    }
};

export const __wbg_fetch_bc7c8e27076a5c84 = typeof fetch == 'function' ? fetch : notDefined('fetch');

export function __wbg_queueMicrotask_848aa4969108a57e(arg0) {
    const ret = arg0.queueMicrotask;
    return ret;
};

export function __wbindgen_is_function(arg0) {
    const ret = typeof(arg0) === 'function';
    return ret;
};

export const __wbg_queueMicrotask_c5419c06eab41e73 = typeof queueMicrotask == 'function' ? queueMicrotask : notDefined('queueMicrotask');

export function __wbg_fetch_1fdc4448ed9eec00(arg0, arg1) {
    const ret = arg0.fetch(arg1);
    return ret;
};

export function __wbg_newwithstrandinit_4b92c89af0a8e383() { return handleError(function (arg0, arg1, arg2) {
    const ret = new Request(getStringFromWasm0(arg0, arg1), arg2);
    return ret;
}, arguments) };

export function __wbg_setbody_aa8b691bec428bf4(arg0, arg1) {
    arg0.body = arg1;
};

export function __wbg_setcredentials_a4e661320cdb9738(arg0, arg1) {
    arg0.credentials = __wbindgen_enum_RequestCredentials[arg1];
};

export function __wbg_setheaders_f5205d36e423a544(arg0, arg1) {
    arg0.headers = arg1;
};

export function __wbg_setmethod_ce2da76000b02f6a(arg0, arg1, arg2) {
    arg0.method = getStringFromWasm0(arg1, arg2);
};

export function __wbg_setmode_4919fd636102c586(arg0, arg1) {
    arg0.mode = __wbindgen_enum_RequestMode[arg1];
};

export function __wbg_setsignal_812ccb8269a7fd90(arg0, arg1) {
    arg0.signal = arg1;
};

export function __wbg_signal_9acfcec9e7dffc22(arg0) {
    const ret = arg0.signal;
    return ret;
};

export function __wbg_new_75169ae5a9683c55() { return handleError(function () {
    const ret = new AbortController();
    return ret;
}, arguments) };

export function __wbg_abort_c57daab47a6c1215(arg0) {
    arg0.abort();
};

export function __wbg_new_a9ae04a5200606a5() { return handleError(function () {
    const ret = new Headers();
    return ret;
}, arguments) };

export function __wbg_append_8b3e7f74a47ea7d5() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
    arg0.append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
}, arguments) };

export function __wbg_instanceof_Response_3c0e210a57ff751d(arg0) {
    let result;
    try {
        result = arg0 instanceof Response;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

export function __wbg_url_58af972663531d16(arg0, arg1) {
    const ret = arg1.url;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
};

export function __wbg_status_5f4e900d22140a18(arg0) {
    const ret = arg0.status;
    return ret;
};

export function __wbg_headers_1b9bf90c73fae600(arg0) {
    const ret = arg0.headers;
    return ret;
};

export function __wbg_arrayBuffer_144729e09879650e() { return handleError(function (arg0) {
    const ret = arg0.arrayBuffer();
    return ret;
}, arguments) };

export function __wbg_crypto_1d1f22824a6a080c(arg0) {
    const ret = arg0.crypto;
    return ret;
};

export function __wbg_process_4a72847cc503995b(arg0) {
    const ret = arg0.process;
    return ret;
};

export function __wbg_versions_f686565e586dd935(arg0) {
    const ret = arg0.versions;
    return ret;
};

export function __wbg_node_104a2ff8d6ea03a2(arg0) {
    const ret = arg0.node;
    return ret;
};

export function __wbg_require_cca90b1a94a0255b() { return handleError(function () {
    const ret = module.require;
    return ret;
}, arguments) };

export function __wbg_msCrypto_eb05e62b530a1508(arg0) {
    const ret = arg0.msCrypto;
    return ret;
};

export function __wbg_randomFillSync_5c9c955aa56b6049() { return handleError(function (arg0, arg1) {
    arg0.randomFillSync(arg1);
}, arguments) };

export function __wbg_getRandomValues_3aa56aa6edec874c() { return handleError(function (arg0, arg1) {
    arg0.getRandomValues(arg1);
}, arguments) };

export function __wbindgen_number_new(arg0) {
    const ret = arg0;
    return ret;
};

export function __wbindgen_jsval_loose_eq(arg0, arg1) {
    const ret = arg0 == arg1;
    return ret;
};

export function __wbindgen_number_get(arg0, arg1) {
    const obj = arg1;
    const ret = typeof(obj) === 'number' ? obj : undefined;
    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
};

export function __wbg_String_b9412f8799faab3e(arg0, arg1) {
    const ret = String(arg1);
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
};

export function __wbindgen_bigint_from_i64(arg0) {
    const ret = arg0;
    return ret;
};

export function __wbg_getwithrefkey_edc2c8960f0f1191(arg0, arg1) {
    const ret = arg0[arg1];
    return ret;
};

export function __wbg_set_f975102236d3c502(arg0, arg1, arg2) {
    arg0[arg1] = arg2;
};

export function __wbg_get_5419cf6b954aa11d(arg0, arg1) {
    const ret = arg0[arg1 >>> 0];
    return ret;
};

export function __wbg_length_f217bbbf7e8e4df4(arg0) {
    const ret = arg0.length;
    return ret;
};

export function __wbg_new_034f913e7636e987() {
    const ret = new Array();
    return ret;
};

export function __wbg_newnoargs_1ede4bf2ebbaaf43(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return ret;
};

export function __wbg_new_7a87a0376e40533b() {
    const ret = new Map();
    return ret;
};

export function __wbg_next_13b477da1eaa3897(arg0) {
    const ret = arg0.next;
    return ret;
};

export function __wbg_next_b06e115d1b01e10b() { return handleError(function (arg0) {
    const ret = arg0.next();
    return ret;
}, arguments) };

export function __wbg_done_983b5ffcaec8c583(arg0) {
    const ret = arg0.done;
