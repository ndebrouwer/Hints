

---
File: /@zk-email/helpers/node_modules/snarkjs/config/rollup.cjs.config.js
---

import fs from "fs";
import { builtinModules as builtin } from "module";

const pkg = JSON.parse(fs.readFileSync("./package.json"));

export default {
    input: "main.js",
    output: {
        file: "build/main.cjs",
        format: "cjs",
    },
    external: [
        ...Object.keys(pkg.dependencies),
        ...builtin,
    ]
};



---
File: /@zk-email/helpers/node_modules/snarkjs/config/rollup.cli.config.js
---

import fs from "fs";
import { builtinModules as builtin } from "module";

const pkg = JSON.parse(fs.readFileSync("./package.json"));

export default {
    input: "cli.js",
    output: {
        file: "build/cli.cjs",
        format: "cjs",
        banner: "#! /usr/bin/env node\n",
    },
    external: [
        ...Object.keys(pkg.dependencies),
        ...builtin,
    ]
};



---
File: /@zk-email/helpers/node_modules/snarkjs/config/rollup.iife_min.config.js
---

import config from './rollup.iife.config';
import { terser } from "rollup-plugin-terser";

export default {
    ...config,
    output: {
        ...config.output,
        file: "build/snarkjs.min.js",
        sourcemap: false,
    },
    plugins: [
        ...config.plugins,
        terser(),
    ]
};



---
File: /@zk-email/helpers/node_modules/snarkjs/config/rollup.iife.config.js
---

import { nodeResolve } from "@rollup/plugin-node-resolve";
import commonJS from "@rollup/plugin-commonjs";
import virtual from "@rollup/plugin-virtual";
import replace from "@rollup/plugin-replace";
import visualizer from "rollup-plugin-visualizer";
// Needed by fastfile
import { O_TRUNC, O_CREAT, O_RDWR, O_EXCL, O_RDONLY } from "constants";

const empty = "export default {}";
// We create a stub with these constants instead of including the entire constants definition
const constants = `
export const O_TRUNC = ${O_TRUNC};
export const O_CREAT = ${O_CREAT};
export const O_RDWR = ${O_RDWR};
export const O_EXCL = ${O_EXCL};
export const O_RDONLY = ${O_RDONLY}
`;

export default {
    input: "main.js",
    output: {
        file: "build/snarkjs.js",
        format: "iife",
        sourcemap: "inline",
        globals: {
            os: "null"
        },
        name: "snarkjs"
    },
    plugins: [
        virtual({
            fs: empty,
            os: empty,
            crypto: empty,
            readline: empty,
            ejs: empty,
            constants: constants,
        }),
        nodeResolve({
            browser: true,
            preferBuiltins: false,
            exportConditions: ["browser", "default", "module", "require"]
        }),
        commonJS(),
        replace({
            // The current default is false, but they are changing it next version
            preventAssignment: false,
            "process.browser": !!process.env.BROWSER
        }),
        visualizer(),
    ]
};



---
File: /@zk-email/helpers/node_modules/snarkjs/scripts/lagrange_fftext.js
---



import {getCurveFromName} from "../src/curves.js";



async function run() {

    const curve = await getCurveFromName("bn128");

    const Fr = curve.Fr;

    Fr.s = 2;

    const powers = [];
    let t;
    let inc = Fr.e(2);

    t = Fr.e(1);
    for (let i=0; i<8; i++) {
        powers[i] = t;
        t = Fr.mul(t, inc);
    }

    printArr("powers", powers);

    const shift_to_small_m = Fr.exp(Fr.shift, 4);
    const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));

    const t0=[];
    const t1=[];
    let sInvAcc = Fr.one;
    for (let i=0; i<4; i++) {
        t0[i] =
            Fr.mul(
                Fr.sub(
                    powers[i+4],
                    Fr.mul(shift_to_small_m, powers[i])
                ),
                Fr.neg(one_over_denom)
            );
        t1[i] =
            Fr.mul(
                Fr.mul(
                    Fr.sub(powers[i+4], powers[i]),
                    sInvAcc
                ),
                one_over_denom
            );

        sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);
    }

    printArr("t0", t0);
    printArr("t1", t1);

    const T0 = await Fr.ifft(t0);
    const T1 = await Fr.ifft(t1);

    printArr("T0", T0);
    printArr("T1", T1);

    const lEvs = [];
    for (let i=0; i<4; i++) {
        lEvs[i] = T0[i];
        lEvs[i+4] =T1[i];
    }

    printArr("LEvs", lEvs);



    const p = [Fr.e(10), Fr.e(22), Fr.e(324), Fr.e(46), Fr.e(35), Fr.e(56), Fr.e(557), Fr.e(18)];

    const pt = lc(p, powers);
    console.log( "p[t]: " + Fr.toString(pt) );

    const P = await Fr.fft(p);


    const Pt = lc(P, lEvs);

    console.log( "P[t]: " + Fr.toString(Pt) );

    function printArr(s, a) {
        console.log(s+": [");
        for (let i=0; i<a.length; i++) {
            console.log("    "+ Fr.toString(a[i]));
        }
        console.log("]");
    }

    function lc(a, b) {
        let acc = Fr.e(0);
        for (let i=0; i<a.length; i++) {
            acc = Fr.add(acc, Fr.mul(a[i], b[i]));
        }
        return acc;
    }

}

run().then( () => {
    process.exit(0);
});



---
File: /@zk-email/helpers/node_modules/snarkjs/scripts/prover_fftext.js
---



import {getCurveFromName} from "../src/curves.js";



async function run() {

    const curve = await getCurveFromName("bn128");

    const Fr = curve.Fr;

    Fr.s = 2;




    const p = [Fr.e(1), Fr.e(2), Fr.e(3), Fr.e(4), Fr.e(-1), Fr.e(-2), Fr.e(-3), Fr.e(-4)];

    printArr("p", p);

    const P = await Fr.fft(p);

    printArr("P", P);

    const pOdd = [];

    let accShift;
    const shift_to_small_m = Fr.exp(Fr.shift, 4);
    // accShift = Fr.e(-1);
    accShift = Fr.sub(Fr.one, shift_to_small_m);
    for (let i=0; i<4; i++) {
        pOdd[i] = Fr.mul(p[i], accShift);
        accShift = Fr.mul(accShift, Fr.shift);
    }

    printArr("pOdd", pOdd);

    const POdd = await Fr.fft(pOdd);

    printArr("POdd", POdd);

    function printArr(s, a) {
        console.log(s+": [");
        for (let i=0; i<a.length; i++) {
            console.log("    "+ Fr.toString(a[i]));
        }
        console.log("]");
    }

    function lc(a, b) {
        let acc = Fr.e(0);
        for (let i=0; i<a.length; i++) {
            acc = Fr.add(acc, Fr.mul(a[i], b[i]));
        }
        return acc;
    }

}

run().then( () => {
    process.exit(0);
});



---
File: /@zk-email/helpers/node_modules/snarkjs/scripts/prover2_fftext.js
---



import {getCurveFromName} from "../src/curves.js";



async function run() {

    const curve = await getCurveFromName("bn128");

    const Fr = curve.Fr;

    Fr.s = 2;

    const P = [Fr.e(1), Fr.e(2), Fr.e(3), Fr.e(4)];

    printArr("P", P);

    const p = await Fr.ifft(P);

    printArr("p", p);

    const p2 = [];

    for (let i=0; i<4; i++) {
        p2[i] = p[i];
        p2[i+4] = Fr.zero;
    }

    printArr("p2", p2);

    const P2 = await Fr.fft(p2);
    printArr("P2", P2);

    const pOdd = [];

    let accShift;
    const shift_to_small_m = Fr.exp(Fr.shift, 4);
    // accShift = Fr.e(-1);
    // accShift = Fr.sub(Fr.one, shift_to_small_m);
    accShift = Fr.one;
    for (let i=0; i<4; i++) {
        pOdd[i] = Fr.mul(p[i], accShift);
        accShift = Fr.mul(accShift, Fr.shift);
    }

    printArr("pOdd", pOdd);

    const POdd = await Fr.fft(pOdd);

    printArr("POdd", POdd);

    function printArr(s, a) {
        console.log(s+": [");
        for (let i=0; i<a.length; i++) {
            console.log("    "+ Fr.toString(a[i]));
        }
        console.log("]");
    }

    function lc(a, b) {
        let acc = Fr.e(0);
        for (let i=0; i<a.length; i++) {
            acc = Fr.add(acc, Fr.mul(a[i], b[i]));
        }
        return acc;
    }

}

run().then( () => {
    process.exit(0);
});



---
File: /@zk-email/helpers/node_modules/snarkjs/scripts/verify_fftext.js
---



import {getCurveFromName} from "../src/curves.js";



async function run() {

    const curve = await getCurveFromName("bn128");

    const Fr = curve.Fr;

    Fr.s = 2;

    const p = [Fr.e(1), Fr.e(2), Fr.e(3), Fr.e(4)];
    printArr("p", p);

    const pz = [];

    for (let i=0; i<4; i++) {
        pz[i] = Fr.neg(p[i]);
        pz[i+4] = p[i];
    }
    printArr("pz", pz);

    const PZ = await Fr.fft(pz);
    printArr("PZ", PZ);

    const pOdd = [];

    let accShift;
    const shift_to_small_m = Fr.exp(Fr.shift, 4);
    // accShift = Fr.e(-1);
    accShift = Fr.sub(shift_to_small_m, Fr.one);
    for (let i=0; i<4; i++) {
        pOdd[i] = Fr.mul(p[i], accShift);
        accShift = Fr.mul(accShift, Fr.shift);
    }

    printArr("pOdd", pOdd);

    const POdd = await Fr.fft(pOdd);

    printArr("POdd", POdd);

    function printArr(s, a) {
        console.log(s+": [");
        for (let i=0; i<a.length; i++) {
            console.log("    "+ Fr.toString(a[i]));
        }
        console.log("]");
    }

    function lc(a, b) {
        let acc = Fr.e(0);
        for (let i=0; i<a.length; i++) {
            acc = Fr.add(acc, Fr.mul(a[i], b[i]));
        }
        return acc;
    }

}

run().then( () => {
    process.exit(0);
});



---
File: /@zk-email/helpers/node_modules/snarkjs/src/bigarray.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

const SUBARRAY_SIZE = 0x40000;

const BigArrayHandler = {
    get: function(obj, prop) {
        if (!isNaN(prop)) {
            return obj.getElement(prop);
        } else return obj[prop];
    },
    set: function(obj, prop, value) {
        if (!isNaN(prop)) {
            return obj.setElement(prop, value);
        } else {
            obj[prop] = value;
            return true;
        }
    }
};

class _BigArray {
    constructor (initSize) {
        this.length = initSize || 0;
        this.arr = new Array(SUBARRAY_SIZE);

        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {
            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));
        }
        return this;
    }
    push () {
        for (let i=0; i<arguments.length; i++) {
            this.setElement (this.length, arguments[i]);
        }
    }

    slice (f, t) {
        const arr = new Array(t-f);
        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);
        return arr;
    }
    getElement(idx) {
        idx = parseInt(idx);
        const idx1 = Math.floor(idx / SUBARRAY_SIZE);
        const idx2 = idx % SUBARRAY_SIZE;
        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;
    }
    setElement(idx, value) {
        idx = parseInt(idx);
        const idx1 = Math.floor(idx / SUBARRAY_SIZE);
        if (!this.arr[idx1]) {
            this.arr[idx1] = new Array(SUBARRAY_SIZE);
        }
        const idx2 = idx % SUBARRAY_SIZE;
        this.arr[idx1][idx2] = value;
        if (idx >= this.length) this.length = idx+1;
        return true;
    }
    getKeys() {
        const newA = new BigArray();
        for (let i=0; i<this.arr.length; i++) {
            if (this.arr[i]) {
                for (let j=0; j<this.arr[i].length; j++) {
                    if (typeof this.arr[i][j] !== "undefined") {
                        newA.push(i*SUBARRAY_SIZE+j);
                    }
                }
            }
        }
        return newA;
    }
}

class BigArray {
    constructor( initSize ) {
        const obj = new _BigArray(initSize);
        const extObj = new Proxy(obj, BigArrayHandler);
        return extObj;
    }
}

export default BigArray;



---
File: /@zk-email/helpers/node_modules/snarkjs/src/chunk_utils.js
---

import fs from "fs";
import * as binFileUtils from "@iden3/binfileutils";
import * as fastFile from "fastfile";
import { BigBuffer } from "ffjavascript";
import localforage from "localforage";

// Each section is its own file.

function sectionName(sectionId) {
    return String.fromCharCode('a'.charCodeAt(0) + sectionId);
}

export async function startWriteSectionFile(zkeyName, sectionId) {
	const fd = await binFileUtils.createBinFile(zkeyName + sectionName(sectionId), "zky" + sectionName(sectionId), 1, 1, 1<<22, 1<<24);

	fd.writingSection = {
        pSectionSize: fd.pos
    };
	await fd.writeULE64(0); // Temporally set to 0 length
	return fd;
}

export async function endWriteSectionFile(fd) {
    if (typeof fd.writingSection === "undefined") throw new Error("Not writing a section");

    const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;
    const oldPos = fd.pos;
    fd.pos = fd.writingSection.pSectionSize;
    await fd.writeULE64(sectionSize);
    fd.pos = oldPos;
    await fd.close();
    delete fd.writingSection;
}

export async function startReadSectionFile(zkeyName, sectionId, maxVersion) {
	const fileName = zkeyName + sectionName(sectionId);
	const type = "zky" + sectionName(sectionId);
    const item = await localforage.getItem(
      fileName
    );
    const fd = await fastFile.readExisting(new Uint8Array(item));

    const b = await fd.read(4);
    let readedType = "";
    for (let i=0; i<4; i++) readedType += String.fromCharCode(b[i]);

    if (readedType != type) throw new Error(fileName + ": Invalid File format");

    let v = await fd.readULE32();

    if (v>maxVersion) throw new Error("Version not supported");

    let nSections = await fd.readULE32();
    if (nSections != 1) throw new Error("More than one section found");

    let size = await fd.readULE64();
    fd.readingSection = {
    	size: size,
    	p: fd.pos,
    }
    return fd;
}

export async function endReadSectionFile(fd, noCheck) {
    if (typeof fd.readingSection === "undefined") throw new Error("Not reading a section");
    if (!noCheck) {
        if (fd.pos-fd.readingSection.p !=  fd.readingSection.size) throw new Error("Invalid section size reading");
    }
    await fd.close();
    delete fd.readingSection;
}

export async function readSectionFile(zkeyName, sectionId, maxVersion) {
	const fd = await startReadSectionFile(zkeyName, sectionId, maxVersion);
    let buff;
    if (fd.readingSection.size < (1 << 30) ) {
        buff = new Uint8Array(fd.readingSection.size);
    } else {
        buff = new BigBuffer(fd.readingSection.size);
    }

    await fd.readToBuffer(buff, 0, fd.readingSection.size, fd.pos);
    await endReadSectionFile(fd);
    return buff;
}

export async function copySectionFile(zkeyNameOld, zkeyNameNew, sectionId) {
    await fs.copyFile(zkeyNameOld + sectionName(sectionId), zkeyNameNew + sectionName(sectionId), (err) => {
        if (err) throw err;
    });
}

export async function sectionFileIsEqual(zkeyNameOld, zkeyNameNew, sectionId, maxVersion) {
    const fdOld = await startReadSectionFile(zkeyNameOld, sectionId, maxVersion);
    const fdNew = await startReadSectionFile(zkeyNameNew, sectionId, maxVersion);

    const MAX_BUFF_SIZE = fdOld.pageSize * 16;
    if (fdOld.readingSection.size != fdNew.readingSection.size) return false;
    const totalBytes=fdOld.readingSection.size;
    for (let i=0; i<totalBytes; i+= MAX_BUFF_SIZE) {
        const n = Math.min(totalBytes-i, MAX_BUFF_SIZE);
        const buff1 = await fdOld.read(n);
        const buff2 = await fdNew.read(n);
        for (let j=0; j<n; j++) if (buff1[j] != buff2[j]) return false;
    }
    await endReadSectionFile(fdOld);
    await endReadSectionFile(fdNew);
    return true;
}



---
File: /@zk-email/helpers/node_modules/snarkjs/src/clprocessor.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

/*
import pkg from "../package.json";
const version = pkg.version;
*/


import path from "path";
import fs from "fs";
import url from "url";

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));

let pkgS;
try {
    pkgS = fs.readFileSync(path.join(__dirname, "package.json"));
} catch (err) {
    pkgS = fs.readFileSync(path.join(__dirname, "..","package.json"));
}

const pkg = JSON.parse(pkgS);
const version = pkg.version;
let selectedCommand = null;

export default async function clProcessor(commands) {
    const cl = [];
    const argv = {};
    for (let i=2; i<process.argv.length; i++) {
        if (process.argv[i][0] == "-") {
            let S = process.argv[i];
            while (S[0] == "-") S = S.slice(1);
            const arr = S.split("=");
            if (arr.length > 1) {
                argv[arr[0]] = arr.slice(1).join("=");
            } else {
                argv[arr[0]] = true;
            }
        } else {
            cl.push(process.argv[i]);
        }
    }
    for (let i=0; i<commands.length; i++) {
        const cmd = commands[i];
        const m = calculateMatch(commands[i], cl);
        let res;
        if (m) {
            if ((argv.h) || (argv.help)) {
                helpCmd(cmd);
                return;
            }
            if (areParamsValid(cmd.cmd, m)) {
                if (cmd.options) {
                    const options = getOptions(cmd.options);
                    res = await cmd.action(m, options);
                } else {
                    res = await cmd.action(m, {});
                }
            } else {
                if (m.length>0) console.log("Invalid number of parameters");
                helpCmd(cmd);
                return 99;
            }
            return res;
        }
    }
    if (cl.length>0) console.log("Invalid command");
    helpAll();
    return 99;

    function calculateMatch(cmd, cl) {
        const alias = [];
        const m = parseLine(cmd.cmd);
        alias.push(m);
        if (cmd.alias) {
            if (Array.isArray(cmd.alias)) {
                for (let i=0; i<cmd.alias.length; i++) {
                    const a = parseLine(cmd.alias[i]);
                    alias.push({
                        cmd: a.cmd,
                        params: m.params
                    });
                }
            } else {
                const a = parseLine(cmd.alias);
                alias.push({
                    cmd: a.cmd,
                    params: m.params
                });
            }
        }
        for (let i=0; i<cl.length; i++) {
            for (let j=0; j<alias.length; j++) {
                const w = alias[j].cmd.shift();
                if (cl[i].toUpperCase() == w.toUpperCase()) {
                    if (alias[j].cmd.length == 0) {
                        return buildRemaining(alias[j].params, cl.slice(i+1));
                    }
                } else {
                    alias.splice(j, 1);
                    j--;
                }
            }
        }
        return null;


        function buildRemaining(defParams, cl) {
            const res = [];
            let p=0;
            for (let i=0; i<defParams.length; i++) {
                if (defParams[i][0]=="-") {
                    res.push(getOption(defParams[i]).val);
                } else {
                    if (p<cl.length) {
                        res.push(cl[p++]);
                    } else {
                        res.push(null);
                    }
                }
            }
            while (p<cl.length) {
                res.push(cl[p++]);
            }
            return res;
        }
    }

    function parseLine(l) {
        const words = l.match(/(\S+)/g);
        for (let i=0; i<words.length; i++) {
            if  (   (words[i][0] == "<")
                 || (words[i][0] == "[")
                 || (words[i][0] == "-"))
            {
                return {
                    cmd: words.slice(0,i),
                    params: words.slice(i)
                };
            }
        }
        return {
            cmd: words,
            params: []
        };
    }


    function getOption(o) {
        const arr1 = o.slice(1).split(":");
        const arr2 = arr1[0].split("|");
        for (let i = 0; i<arr2.length; i++) {
            if (argv[arr2[i]]) return {
                key: arr2[0],
                val: argv[arr2[i]]
            };
        }
        return {
            key: arr2[0],
            val: (arr1.length >1) ? arr1[1] : null
        };
    }


    function areParamsValid(cmd, params) {
        while ((params.length)&&(!params[params.length-1])) params.pop();
        const pl = parseLine(cmd);
        if (params.length > pl.params.length) return false;
        let minParams = pl.params.length;
        while ((minParams>0)&&(pl.params[minParams-1][0] == "[")) minParams --;
        if (params.length < minParams) return false;

        for (let i=0; (i< pl.params.length)&&(pl.params[i][0]=="<"); i++) {
            if (typeof params[i] == "undefined") return false;
        }
        return true;
    }

    function getOptions(options) {
        const res = {};
        const opts = options.match(/(\S+)/g);
        for (let i=0; i<opts.length; i++) {
            const o = getOption(opts[i]);
            res[o.key] = o.val;
        }
        return res;
    }

    function printVersion() {
        console.log("snarkjs@"+version);
    }

    function epilog() {
        console.log(`        Copyright (C) 2018  0kims association
        This program comes with ABSOLUTELY NO WARRANTY;
        This is free software, and you are welcome to redistribute it
        under certain conditions; see the COPYING file in the official
        repo directory at  https://github.com/iden3/snarkjs `);
    }

    function helpAll() {
        printVersion();
        epilog();
        console.log("");
        console.log("Usage:");
        console.log("        snarkjs <full command> ...  <options>");
        console.log("   or   snarkjs <shorcut> ...  <options>");
        console.log("");
        console.log("Type snarkjs <command> --help to get more information for that command");
        console.log("");
        console.log("Full Command                  Description");
        console.log("============                  =================");
        for (let i=0; i<commands.length; i++) {
            const cmd = commands[i];
            let S = "";
            const pl = parseLine(cmd.cmd);
            S += pl.cmd.join(" ");
            while (S.length<30) S = S+" ";
            S += cmd.description;
            console.log(S);
            S = "     Usage:  snarkjs ";
            if (cmd.alias) {
                if (Array.isArray(cmd.alias)) {
                    S += cmd.alias[0];
                } else {
                    S += cmd.alias;
                }
            } else {
                S += pl.cmd.join(" ");
            }
            S += " " + pl.params.join(" ");
            console.log(S);
        }
    }

    function helpCmd(cmd) {
        if (typeof cmd == "undefined") cmd = selectedCommand;
        if (typeof cmd == "undefined") return helpAll();
        printVersion();
        epilog();
        console.log("");
        if (cmd.longDescription) {
            console.log(cmd.longDescription);
        } else {
            console.log(cmd.description);
        }
        console.log("Usage: ");
        console.log("        snarkjs "+ cmd.cmd);
        const pl = parseLine(cmd.cmd);
        let S = "   or   snarkjs ";
        if (cmd.alias) {
            if (Array.isArray(cmd.alias)) {
                S += cmd.alias[0];
            } else {
                S += cmd.alias;
            }
        } else {
            S += pl.cmd.join(" ");
        }
        S += " " + pl.params.join(" ");
        console.log(S);



        console.log("");
    }
}




---
File: /@zk-email/helpers/node_modules/snarkjs/src/curves.js
---

import { Scalar, buildBn128, buildBls12381} from "ffjavascript";

const bls12381r = Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
const bn128r = Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");

const bls12381q = Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
const bn128q = Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");

export async function getCurveFromR(r) {
    let curve;
    if (Scalar.eq(r, bn128r)) {
        curve = await buildBn128();
    } else if (Scalar.eq(r, bls12381r)) {
        curve = await buildBls12381();
    } else {
        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);
    }
    return curve;
}

export async function getCurveFromQ(q) {
    let curve;
    if (Scalar.eq(q, bn128q)) {
        curve = await buildBn128(true);
    } else if (Scalar.eq(q, bls12381q)) {
        curve = await buildBls12381();
    } else {
        throw new Error(`Curve not supported: ${Scalar.toString(q)}`);
    }
    return curve;
}

export async function getCurveFromName(name) {
    let curve;
    const normName = normalizeName(name);
    if (["BN128", "BN254", "ALTBN128"].indexOf(normName) >= 0) {
        curve = await buildBn128();
    } else if (["BLS12381"].indexOf(normName) >= 0) {
        curve = await buildBls12381();
    } else {
        throw new Error(`Curve not supported: ${name}`);
    }
    return curve;

    function normalizeName(n) {
        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join("");
    }

}




---
File: /@zk-email/helpers/node_modules/snarkjs/src/groth16_exportsoliditycalldata.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/
import {  utils }   from "ffjavascript";
const { unstringifyBigInts} = utils;

function p256(n) {
    let nstr = n.toString(16);
    while (nstr.length < 64) nstr = "0"+nstr;
    nstr = `"0x${nstr}"`;
    return nstr;
}

export default async function groth16ExportSolidityCallData(_proof, _pub) {
    const proof = unstringifyBigInts(_proof);
    const pub = unstringifyBigInts(_pub);

    let inputs = "";
    for (let i=0; i<pub.length; i++) {
        if (inputs != "") inputs = inputs + ",";
        inputs = inputs + p256(pub[i]);
    }

    let S;
    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +
        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +
        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +
        `[${inputs}]`;

    return S;
}



---
File: /@zk-email/helpers/node_modules/snarkjs/src/groth16_fullprove.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

import groth16_prove from "./groth16_prove.js";
import wtns_calculate from "./wtns_calculate.js";
import {utils} from "ffjavascript";
const {unstringifyBigInts} = utils;

export default async function groth16FullProve(_input, wasmFile, zkeyFileName, logger) {
    const input = unstringifyBigInts(_input);

    const wtns= {
        type: "mem"
    };
    console.time("witness calculation");
    await wtns_calculate(input, wasmFile, wtns);
    console.timeEnd("witness calculation");

    console.time("groth16 prove");
    const proof = await groth16_prove(zkeyFileName, wtns, logger);
    console.timeEnd("groth16 prove");
    return proof;
}



---
File: /@zk-email/helpers/node_modules/snarkjs/src/groth16_prove.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

import * as binFileUtils from "@iden3/binfileutils";
import * as chunkFileUtils from "./chunk_utils.js";
import * as zkeyUtils from "./zkey_utils.js";
import * as wtnsUtils from "./wtns_utils.js";
import { getCurveFromQ as getCurve } from "./curves.js";
import { log2 } from "./misc.js";
import { Scalar, utils, BigBuffer } from "ffjavascript";
const {stringifyBigInts} = utils;

export default async function groth16Prove(zkeyFileName, witnessFileName, logger) {
    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils.readBinFile(witnessFileName, "wtns", 2, 1<<25, 1<<23);

    const wtns = await wtnsUtils.readHeader(fdWtns, sectionsWtns);

    const maxZKeyVersion = 2;

    const zkey = await zkeyUtils.readHeader(zkeyFileName, maxZKeyVersion);

    if (zkey.protocol != "groth16") {
        throw new Error("zkey file is not groth16");
    }

    if (!Scalar.eq(zkey.r,  wtns.q)) {
        throw new Error("Curve of the witness does not match the curve of the proving key");
    }

    if (wtns.nWitness != zkey.nVars) {
        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);
    }

    const curve = zkey.curve;
    const Fr = curve.Fr;
    const G1 = curve.G1;
    const G2 = curve.G2;

    const power = log2(zkey.domainSize);

    if (logger) logger.debug("Reading Wtns");
    const buffWitness = await binFileUtils.readSection(fdWtns, sectionsWtns, 2);
    if (logger) logger.debug("Reading Coeffs");
    const buffCoeffs = await chunkFileUtils.readSectionFile(zkeyFileName, 4, maxZKeyVersion);

    if (logger) logger.debug("Building ABC");
    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);

    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];

    const buffA = await Fr.ifft(buffA_T, "", "", logger, "IFFT_A");
    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);
    const buffAodd_T = await Fr.fft(buffAodd, "", "", logger, "FFT_A");

    const buffB = await Fr.ifft(buffB_T, "", "", logger, "IFFT_B");
    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);
    const buffBodd_T = await Fr.fft(buffBodd, "", "", logger, "FFT_B");

    const buffC = await Fr.ifft(buffC_T, "", "", logger, "IFFT_C");
    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);
    const buffCodd_T = await Fr.fft(buffCodd, "", "", logger, "FFT_C");

    if (logger) logger.debug("Join ABC");
    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);

    let proof = {};

    if (logger) logger.debug("Reading A Points");
    const buffBasesA = await chunkFileUtils.readSectionFile(zkeyFileName, 5, maxZKeyVersion);
    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, "multiexp A");

    if (logger) logger.debug("Reading B1 Points");
    const buffBasesB1 = await chunkFileUtils.readSectionFile(zkeyFileName, 6, maxZKeyVersion);
    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, "multiexp B1");

    if (logger) logger.debug("Reading B2 Points");
    const buffBasesB2 = await chunkFileUtils.readSectionFile(zkeyFileName, 7, maxZKeyVersion);
    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, "multiexp B2");

    if (logger) logger.debug("Reading C Points");
    const buffBasesC = await chunkFileUtils.readSectionFile(zkeyFileName, 8, maxZKeyVersion);
    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, "multiexp C");

    if (logger) logger.debug("Reading H Points");
    const buffBasesH = await chunkFileUtils.readSectionFile(zkeyFileName, 9, maxZKeyVersion);
    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, "multiexp H");

    const r = curve.Fr.random();
    const s = curve.Fr.random();

    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );
    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));

    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );
    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));

    pib1 = G1.add( pib1, zkey.vk_beta_1 );
    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));

    proof.pi_c = G1.add(proof.pi_c, resH);


    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));
    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));
    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));


    let publicSignals = [];

    for (let i=1; i<= zkey.nPublic; i++) {
        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);
        publicSignals.push(Scalar.fromRprLE(b));
    }

    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));
    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));
    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));

    proof.protocol = "groth16";
    proof.curve = curve.name;

    await fdWtns.close();

    proof = stringifyBigInts(proof);
    publicSignals = stringifyBigInts(publicSignals);

    await curve.terminate();

    return {proof, publicSignals};
}


async function buildABC1(curve, zkey, witness, coeffs, logger) {
    const n8 = curve.Fr.n8;
    const sCoef = 4*3 + zkey.n8r;
    const nCoef = (coeffs.byteLength-4) / sCoef;

    const outBuffA = new BigBuffer(zkey.domainSize * n8);
    const outBuffB = new BigBuffer(zkey.domainSize * n8);
    const outBuffC = new BigBuffer(zkey.domainSize * n8);

    const outBuf = [ outBuffA, outBuffB ];
    for (let i=0; i<nCoef; i++) {
        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);
        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);
        const buffCoefV = new DataView(buffCoef.buffer);
        const m= buffCoefV.getUint32(0, true);
        const c= buffCoefV.getUint32(4, true);
        const s= buffCoefV.getUint32(8, true);
        const coef = buffCoef.slice(12, 12+n8);
        outBuf[m].set(
            curve.Fr.add(
                outBuf[m].slice(c*n8, c*n8+n8),
                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))
            ),
            c*n8
        );
    }

    for (let i=0; i<zkey.domainSize; i++) {
        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);
        outBuffC.set(
            curve.Fr.mul(
                outBuffA.slice(i*n8, i*n8+n8),
                outBuffB.slice(i*n8, i*n8+n8),
            ),
            i*n8
        );
    }

    return [outBuffA, outBuffB, outBuffC];

}

/*
async function buldABC(curve, zkey, witness, coeffs, logger) {
    const concurrency = curve.tm.concurrency;
    const sCoef = 4*3 + zkey.n8r;

    let getUint32;

    if (coeffs instanceof BigBuffer) {
        const coeffsDV = [];
        const PAGE_LEN = coeffs.buffers[0].length;
        for (let i=0; i< coeffs.buffers.length; i++) {
            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));
        }
        getUint32 = function (pos) {
            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);
        };
    } else {
        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);
        getUint32 = function (pos) {
            return coeffsDV.getUint32(pos, true);
        };
    }

    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);
    const promises = [];

    const cutPoints = [];
    for (let i=0; i<concurrency; i++) {
        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));
    }
    cutPoints.push(coeffs.byteLength);

    const chunkSize = 2**26;
    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {
        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);
        const ns= Math.min(zkey.nVars-s, chunkSize );

        for (let i=0; i<concurrency; i++) {
            let n;
            if (i< concurrency-1) {
                n = elementsPerChunk;
            } else {
                n = zkey.domainSize - i*elementsPerChunk;
            }
            if (n==0) continue;

            const task = [];

            task.push({cmd: "ALLOCSET", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});
            task.push({cmd: "ALLOCSET", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});
            task.push({cmd: "ALLOC", var: 2, len: n*curve.Fr.n8});
            task.push({cmd: "ALLOC", var: 3, len: n*curve.Fr.n8});
            task.push({cmd: "ALLOC", var: 4, len: n*curve.Fr.n8});
            task.push({cmd: "CALL", fnName: "qap_buildABC", params:[
                {var: 0},
                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},
                {var: 1},
                {var: 2},
                {var: 3},
                {var: 4},
                {val: i*elementsPerChunk},
                {val: n},
                {val: s},
                {val: ns}
            ]});
            task.push({cmd: "GET", out: 0, var: 2, len: n*curve.Fr.n8});
            task.push({cmd: "GET", out: 1, var: 3, len: n*curve.Fr.n8});
            task.push({cmd: "GET", out: 2, var: 4, len: n*curve.Fr.n8});
            promises.push(curve.tm.queueAction(task));
        }
    }

    let result = await Promise.all(promises);

    const nGroups = result.length / concurrency;
    if (nGroups>1) {
        const promises2 = [];
        for (let i=0; i<concurrency; i++) {
            const task=[];
            task.push({cmd: "ALLOC", var: 0, len: result[i][0].byteLength});
            task.push({cmd: "ALLOC", var: 1, len: result[i][0].byteLength});
            for (let m=0; m<3; m++) {
                task.push({cmd: "SET", var: 0, buff: result[i][m]});
                for (let s=1; s<nGroups; s++) {
                    task.push({cmd: "SET", var: 1, buff: result[s*concurrency + i][m]});
                    task.push({cmd: "CALL", fnName: "qap_batchAdd", params:[
                        {var: 0},
                        {var: 1},
                        {val: result[i][m].length/curve.Fr.n8},
                        {var: 0}
                    ]});
                }
                task.push({cmd: "GET", out: m, var: 0, len: result[i][m].length});
            }
            promises2.push(curve.tm.queueAction(task));
        }
        result = await Promise.all(promises2);
    }

    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);
    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);
    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);
    let p=0;
    for (let i=0; i<result.length; i++) {
        outBuffA.set(result[i][0], p);
        outBuffB.set(result[i][1], p);
        outBuffC.set(result[i][2], p);
        p += result[i][0].byteLength;
    }

    return [outBuffA, outBuffB, outBuffC];

    function getCutPoint(v) {
        let m = 0;
        let n = getUint32(0);
        while (m < n) {
            var k = Math.floor((n + m) / 2);
            const va = getUint32(4 + k*sCoef + 4);
            if (va > v) {
                n = k - 1;
            } else if (va < v) {
                m = k + 1;
            } else {
                n = k;
            }
        }
        return 4 + m*sCoef;
    }
}
*/

async function joinABC(curve, zkey, a, b, c, logger) {
    const MAX_CHUNK_SIZE = 1 << 22;

    const n8 = curve.Fr.n8;
    const nElements = Math.floor(a.byteLength / curve.Fr.n8);

    const promises = [];

    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {
        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);
        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);

        const task = [];

        const aChunk = a.slice(i*n8, (i + n)*n8 );
        const bChunk = b.slice(i*n8, (i + n)*n8 );
        const cChunk = c.slice(i*n8, (i + n)*n8 );

        task.push({cmd: "ALLOCSET", var: 0, buff: aChunk});
        task.push({cmd: "ALLOCSET", var: 1, buff: bChunk});
        task.push({cmd: "ALLOCSET", var: 2, buff: cChunk});
        task.push({cmd: "ALLOC", var: 3, len: n*n8});
        task.push({cmd: "CALL", fnName: "qap_joinABC", params:[
            {var: 0},
            {var: 1},
            {var: 2},
            {val: n},
            {var: 3},
        ]});
        task.push({cmd: "CALL", fnName: "frm_batchFromMontgomery", params:[
            {var: 3},
            {val: n},
            {var: 3}
        ]});
        task.push({cmd: "GET", out: 0, var: 3, len: n*n8});
        promises.push(curve.tm.queueAction(task));
    }

    const result = await Promise.all(promises);

    let outBuff;
    if (a instanceof BigBuffer) {
        outBuff = new BigBuffer(a.byteLength);
    } else {
        outBuff = new Uint8Array(a.byteLength);
    }

    let p=0;
    for (let i=0; i<result.length; i++) {
        outBuff.set(result[i][0], p);
        p += result[i][0].byteLength;
    }

    return outBuff;
}




---
File: /@zk-email/helpers/node_modules/snarkjs/src/groth16_verify.js
---

/*
    Copyright 2018 0kims association.

    This file is part of snarkjs.

    snarkjs is a free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    snarkjs is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along with
    snarkjs. If not, see <https://www.gnu.org/licenses/>.
*/

/* Implementation of this paper: https://eprint.iacr.org/2016/260.pdf */
import { Scalar } from "ffjavascript";
import * as curves from "./curves.js";
import {  utils }   from "ffjavascript";
const {unstringifyBigInts} = utils;

export default async function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {
/*
    let cpub = vk_verifier.IC[0];
    for (let s= 0; s< vk_verifier.nPublic; s++) {
        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));
    }
*/

    const vk_verifier = unstringifyBigInts(_vk_verifier);
    const proof = unstringifyBigInts(_proof);
    const publicSignals = unstringifyBigInts(_publicSignals);

    const curve = await curves.getCurveFromName(vk_verifier.curve);

    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);
    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);
    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);

    for (let i=0; i<publicSignals.length; i++) {
        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);
        IC.set(buffP, i*curve.G1.F.n8*2);
        Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);
    }

    let cpub = await curve.G1.multiExpAffine(IC, w);
    cpub = curve.G1.add(cpub, IC0);

    const pi_a = curve.G1.fromObject(proof.pi_a);
    const pi_b = curve.G2.fromObject(proof.pi_b);
    const pi_c = curve.G1.fromObject(proof.pi_c);

    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);
    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);
    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);
    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);

    const res = await curve.pairingEq(
        curve.G1.neg(pi_a) , pi_b,
        cpub , vk_gamma_2,
        pi_c , vk_delta_2,

        vk_alpha_1, vk_beta_2
    );

    if (! res) {
        if (logger) logger.error("Invalid proof");
        return false;
    }

    if (logger) logger.info("OK!");
    return true;
}



---
File: /@zk-email/helpers/node_modules/snarkjs/src/groth16.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

export {default as fullProve} from "./groth16_fullprove.js";
export {default as prove} from "./groth16_prove.js";
export {default as verify} from "./groth16_verify.js";
export {default as exportSolidityCallData} from "./groth16_exportsoliditycalldata.js";



---
File: /@zk-email/helpers/node_modules/snarkjs/src/keypair.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

import blake2b from "blake2b-wasm";

import { ChaCha } from "ffjavascript";

export function hashToG2(curve, hash) {
    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);
    const seed = [];
    for (let i=0; i<8; i++) {
        seed[i] = hashV.getUint32(i*4);
    }

    const rng = new ChaCha(seed);

    const g2_sp = curve.G2.fromRng(rng);

    return g2_sp;
}

export function getG2sp(curve, persinalization, challenge, g1s, g1sx) {

    const h = blake2b(64);
    const b1 = new Uint8Array([persinalization]);
    h.update(b1);
    h.update(challenge);
    const b3 = curve.G1.toUncompressed(g1s);
    h.update( b3);
    const b4 = curve.G1.toUncompressed(g1sx);
    h.update( b4);
    const hash =h.digest();

    return hashToG2(curve, hash);
}

function calculatePubKey(k, curve, personalization, challengeHash, rng ) {
    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));
    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));
    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));
    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));
    return k;
}

export function createPTauKey(curve, challengeHash, rng) {
    const key = {
        tau: {},
        alpha: {},
        beta: {}
    };
    key.tau.prvKey = curve.Fr.fromRng(rng);
    key.alpha.prvKey = curve.Fr.fromRng(rng);
    key.beta.prvKey = curve.Fr.fromRng(rng);
    calculatePubKey(key.tau, curve, 0, challengeHash, rng);
    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);
    calculatePubKey(key.beta, curve, 2, challengeHash, rng);
    return key;
}

export function createDeltaKey(curve, transcript, rng) {
    const delta = {};
    delta.prvKey = curve.Fr.fromRng(rng);
    delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));
    delta.g1_sx = curve.G1.toAffine(curve.G1.timesScalar(delta.g1_s, delta.prvKey));
    delta.g2_sp = hashToG2(curve, transcript);
    delta.g2_spx = curve.G2.toAffine(curve.G2.timesScalar(delta.g2_sp, delta.prvKey));
    return delta;
}



---
File: /@zk-email/helpers/node_modules/snarkjs/src/loadsyms.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

import * as fastFile from "fastfile";

export default async function loadSymbols(symFileName) {
    const sym = {
        labelIdx2Name: [ "one" ],
        varIdx2Name: [ "one" ],
        componentIdx2Name: []
    };
    const fd = await fastFile.readExisting(symFileName);
    const buff = await fd.read(fd.totalSize);
    const symsStr = new TextDecoder("utf-8").decode(buff);
    const lines = symsStr.split("\n");
    for (let i=0; i<lines.length; i++) {
        const arr = lines[i].split(",");
        if (arr.length!=4) continue;
        if (sym.varIdx2Name[arr[1]]) {
            sym.varIdx2Name[arr[1]] += "|" + arr[3];
        } else {
            sym.varIdx2Name[arr[1]] = arr[3];
        }
        sym.labelIdx2Name[arr[0]] = arr[3];
        if (!sym.componentIdx2Name[arr[2]]) {
            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);
        }
    }

    await fd.close();

    return sym;

    function extractComponent(name) {
        const arr = name.split(".");
        arr.pop(); // Remove the lasr element
        return arr.join(".");
    }
}



---
File: /@zk-email/helpers/node_modules/snarkjs/src/misc.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

/* global window */
import Blake2b from "blake2b-wasm";
import readline from "readline";
import { ChaCha } from "ffjavascript";
import crypto from "crypto";

const _revTable = [];
for (let i=0; i<256; i++) {
    _revTable[i] = _revSlow(i, 8);
}

function _revSlow(idx, bits) {
    let res =0;
    let a = idx;
    for (let i=0; i<bits; i++) {
        res <<= 1;
        res = res | (a &1);
        a >>=1;
    }
    return res;
}

export function bitReverse(idx, bits) {
    return (
        _revTable[idx >>> 24] |
        (_revTable[(idx >>> 16) & 0xFF] << 8) |
        (_revTable[(idx >>> 8) & 0xFF] << 16) |
        (_revTable[idx & 0xFF] << 24)
    ) >>> (32-bits);
}


export function log2( V )
{
    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );
}


export function formatHash(b, title) {
    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);
    let S = "";
    for (let i=0; i<4; i++) {
        if (i>0) S += "\n";
        S += "\t\t";
        for (let j=0; j<4; j++) {
            if (j>0) S += " ";
            S += a.getUint32(i*16+j*4).toString(16).padStart(8, "0");
        }
    }
    if (title) S = title + "\n" + S;
    return S;
}

export function hashIsEqual(h1, h2) {
    if (h1.byteLength != h2.byteLength) return false;
    var dv1 = new Int8Array(h1);
    var dv2 = new Int8Array(h2);
    for (var i = 0 ; i != h1.byteLength ; i++)
    {
        if (dv1[i] != dv2[i]) return false;
    }
    return true;
}

export function cloneHasher(h) {
    const ph = h.getPartialHash();
    const res = Blake2b(64);
    res.setPartialHash(ph);
    return res;
}

export async function sameRatio(curve, g1s, g1sx, g2s, g2sx) {
    if (curve.G1.isZero(g1s)) return false;
    if (curve.G1.isZero(g1sx)) return false;
    if (curve.G2.isZero(g2s)) return false;
    if (curve.G2.isZero(g2sx)) return false;
    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));
    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);
    return res;
}


export function askEntropy() {
    if (process.browser) {
        return window.prompt("Enter a random text. (Entropy): ", "");
    } else {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        return new Promise((resolve) => {
            rl.question("Enter a random text. (Entropy): ", (input) => resolve(input) );
        });
    }
}

export async function getRandomRng(entropy) {
    // Generate a random Rng
    while (!entropy) {
        entropy = await askEntropy();
    }
    const hasher = Blake2b(64);
    hasher.update(crypto.randomBytes(64));
    const enc = new TextEncoder(); // always utf-8
    hasher.update(enc.encode(entropy));
    const hash = Buffer.from(hasher.digest());

    const seed = [];
    for (let i=0;i<8;i++) {
        seed[i] = hash.readUInt32BE(i*4);
    }
    const rng = new ChaCha(seed);
    return rng;
}

export function rngFromBeaconParams(beaconHash, numIterationsExp) {
    let nIterationsInner;
    let nIterationsOuter;
    if (numIterationsExp<32) {
        nIterationsInner = (1 << numIterationsExp) >>> 0;
        nIterationsOuter = 1;
    } else {
        nIterationsInner = 0x100000000;
        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;
    }

    let curHash = beaconHash;
    for (let i=0; i<nIterationsOuter; i++) {
        for (let j=0; j<nIterationsInner; j++) {
            curHash = crypto.createHash("sha256").update(curHash).digest();
        }
    }

    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);
    const seed = [];
    for (let i=0; i<8; i++) {
        seed[i] = curHashV.getUint32(i*4, false);
    }

    const rng = new ChaCha(seed);

    return rng;
}

export function hex2ByteArray(s) {
    if (s instanceof Uint8Array) return s;
    if (s.slice(0,2) == "0x") s= s.slice(2);
    return new Uint8Array(s.match(/[\da-f]{2}/gi).map(function (h) {
        return parseInt(h, 16);
    }));
}

export function byteArray2hex(byteArray) {
    return Array.prototype.map.call(byteArray, function(byte) {
        return ("0" + (byte & 0xFF).toString(16)).slice(-2);
    }).join("");
}

export function stringifyBigIntsWithField(Fr, o) {
    if (o instanceof Uint8Array)  {
        return Fr.toString(o);
    } else if (Array.isArray(o)) {
        return o.map(stringifyBigIntsWithField.bind(null, Fr));
    } else if (typeof o == "object") {
        const res = {};
        const keys = Object.keys(o);
        keys.forEach( (k) => {
            res[k] = stringifyBigIntsWithField(Fr, o[k]);
        });
        return res;
    } else if ((typeof(o) == "bigint") || o.eq !== undefined)  {
        return o.toString(10);
    } else {
        return o;
    }
}


---
File: /@zk-email/helpers/node_modules/snarkjs/src/mpc_applykey.js
---

/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

import * as binFileUtils from "@iden3/binfileutils";
import * as chunkFileUtils from "./chunk_utils.js";

/*
    This function creates a new section in the fdTo file with id idSection.
    It multiplies the pooints in fdFrom by first, first*inc, first*inc^2, ....
    nPoint Times.
    It also updates the newChallengeHasher with the new points
*/

export async function applyKeyToSection(zkeyFileNameOld, maxZKeyVersion, zkeyFileNameNew, idSection, curve, groupName, first, inc, sectionName, logger) {
    const MAX_CHUNK_SIZE = 1 << 16;
    const G = curve[groupName];
    const sG = G.F.n8*2;

    const fdOld = await chunkFileUtils.startReadSectionFile(zkeyFileNameOld, idSection, maxZKeyVersion);
    const fdNew = await chunkFileUtils.startWriteSectionFile(zkeyFileNameNew, idSection);

    const nPoints = fdOld.readingSection.size / sG;
    let t = first;
    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {
        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);
        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);
        let buff;
        buff = await fdOld.read(n*sG);
        buff = await G.batchApplyKey(buff, t, inc);
        await fdNew.write(buff);
        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));
    }

    await chunkFileUtils.endWriteSectionFile(fdNew);
    await chunkFileUtils.endReadSectionFile(fdOld);
}



export async function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {
    const G = curve[groupName];
    const sG = G.F.n8*2;
    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks
    let t = first;
    for (let i=0 ; i<nPoints ; i+= chunkSize) {
        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);
        const n= Math.min(nPoints-i, chunkSize );
        const buffInU = await fdOld.read(n * sG);
        const buffInLEM = await G.batchUtoLEM(buffInU);
        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);
        let buffOut;
        if (formatOut == "COMPRESSED") {
            buffOut = await G.batchLEMtoC(buffOutLEM);
        } else {
            buffOut = await G.batchLEMtoU(buffOutLEM);
        }

        if (responseHasher) responseHasher.update(buffOut);
        await fdNew.write(buffOut);
        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));
    }
}




---
File: /@zk-email/helpers/node_modules/snarkjs/src/plonk_exportsoliditycalldata.js
---

/*
    Copyright 2021 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

import { getCurveFromName } from "./curves.js";
import {  utils }   from "ffjavascript";
const { unstringifyBigInts} = utils;

function i2hex(i) {
    return ("0" + i.toString(16)).slice(-2);
}

function p256(n) {
    let nstr = n.toString(16);
    while (nstr.length < 64) nstr = "0"+nstr;
    nstr = `"0x${nstr}"`;
    return nstr;
}

export default async function plonkExportSolidityCallData(_proof, _pub) {
    const proof = unstringifyBigInts(_proof);
    const pub = unstringifyBigInts(_pub);

    const curve = await getCurveFromName(proof.curve);
    const G1 = curve.G1;
    const Fr = curve.Fr;

    let inputs = "";
    for (let i=0; i<pub.length; i++) {
        if (inputs != "") inputs = inputs + ",";
        inputs = inputs + p256(pub[i]);
    }

    const proofBuff = new Uint8Array(G1.F.n8*2*9 + Fr.n8*7);
    G1.toRprUncompressed(proofBuff, 0, G1.e(proof.A));
    G1.toRprUncompressed(proofBuff, G1.F.n8*2, G1.e(proof.B));
    G1.toRprUncompressed(proofBuff, G1.F.n8*4, G1.e(proof.C));
    G1.toRprUncompressed(proofBuff, G1.F.n8*6, G1.e(proof.Z));
    G1.toRprUncompressed(proofBuff, G1.F.n8*8, G1.e(proof.T1));
    G1.toRprUncompressed(proofBuff, G1.F.n8*10, G1.e(proof.T2));
    G1.toRprUncompressed(proofBuff, G1.F.n8*12, G1.e(proof.T3));
    G1.toRprUncompressed(proofBuff, G1.F.n8*14, G1.e(proof.Wxi));
    G1.toRprUncompressed(proofBuff, G1.F.n8*16, G1.e(proof.Wxiw));
    Fr.toRprBE(proofBuff, G1.F.n8*18 , Fr.e(proof.eval_a));
    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8, Fr.e(proof.eval_b));
    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*2, Fr.e(proof.eval_c));
    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*3, Fr.e(proof.eval_s1));
    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*4, Fr.e(proof.eval_s2));
    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*5, Fr.e(proof.eval_zw));
    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*6, Fr.e(proof.eval_r));

    const proofHex = Array.from(proofBuff).map(i2hex).join("");

    const S="0x"+proofHex+",["+inputs+"]";

    return S;
}



---
File: /@zk-email/helpers/node_modules/snarkjs/src/plonk_fullprove.js
---

/*
    Copyright 2021 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

import plonk_prove from "./plonk_prove.js";
import wtns_calculate from "./wtns_calculate.js";
import {utils} from 'ffjavascript';
const {unstringifyBigInts} = utils;

export default async function plonkFullProve(_input, wasmFile, zkeyFileName, logger) {
    const input = unstringifyBigInts(_input);

    const wtns= {
        type: "mem"
    };
    await wtns_calculate(input, wasmFile, wtns);
    return await plonk_prove(zkeyFileName, wtns, logger);
}



---
File: /@zk-email/helpers/node_modules/snarkjs/src/plonk_prove.js
---

/*
    Copyright 2021 0kims association.

    This file is part of snarkjs.

    snarkjs is a free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    snarkjs is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along with
    snarkjs. If not, see <https://www.gnu.org/licenses/>.
*/

/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf section 8.4 */

import * as binFileUtils from "@iden3/binfileutils";
import * as zkeyUtils from "./zkey_utils.js";
import * as wtnsUtils from "./wtns_utils.js";
import { getCurveFromQ as getCurve } from "./curves.js";
import { Scalar, utils, BigBuffer } from "ffjavascript";
const {stringifyBigInts} = utils;
import jsSha3 from "js-sha3";
const { keccak256 } = jsSha3;

export default async function plonk16Prove(zkeyFileName, witnessFileName, logger) {
    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils.readBinFile(witnessFileName, "wtns", 2, 1<<25, 1<<23);

    const wtns = await wtnsUtils.readHeader(fdWtns, sectionsWtns);

    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils.readBinFile(zkeyFileName, "zkey", 2, 1<<25, 1<<23);

    const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey);
    if (zkey.protocol != "plonk") {
        throw new Error("zkey file is not plonk");
    }

    if (!Scalar.eq(zkey.r,  wtns.q)) {
        throw new Error("Curve of the witness does not match the curve of the proving key");
    }

    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {
        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);
    }

    const curve = zkey.curve;
    const Fr = curve.Fr;
    const G1 = curve.G1;
    const n8r = curve.Fr.n8;

    if (logger) logger.debug("Reading Wtns");
    const buffWitness = await binFileUtils.readSection(fdWtns, sectionsWtns, 2);
    // First element in plonk is not used and can be any value. (But always the same).
    // We set it to zero to go faster in the exponentiations.
    buffWitness.set(Fr.zero, 0);
    const buffInternalWitness = new BigBuffer(n8r*zkey.nAdditions);

    await calculateAdditions();

    let A,B,C,Z;
    let A4, B4, C4, Z4;
    let pol_a,pol_b,pol_c, pol_z, pol_t, pol_r;
    let proof = {};

    const sigmaBuff = new BigBuffer(zkey.domainSize*n8r*4*3);
    let o = sectionsZKey[12][0].p + zkey.domainSize*n8r;
    await fdZKey.readToBuffer(sigmaBuff, 0 , zkey.domainSize*n8r*4, o);
    o += zkey.domainSize*n8r*5;
    await fdZKey.readToBuffer(sigmaBuff, zkey.domainSize*n8r*4 , zkey.domainSize*n8r*4, o);
    o += zkey.domainSize*n8r*5;
    await fdZKey.readToBuffer(sigmaBuff, zkey.domainSize*n8r*8 , zkey.domainSize*n8r*4, o);

    const pol_s1 = new BigBuffer(zkey.domainSize*n8r);
    await fdZKey.readToBuffer(pol_s1, 0 , zkey.domainSize*n8r, sectionsZKey[12][0].p);

    const pol_s2 = new BigBuffer(zkey.domainSize*n8r);
    await fdZKey.readToBuffer(pol_s2, 0 , zkey.domainSize*n8r, sectionsZKey[12][0].p + 5*zkey.domainSize*n8r);

    const PTau = await binFileUtils.readSection(fdZKey, sectionsZKey, 14);


    const ch = {};

    await round1();
    await round2();
    await round3();
    await round4();
    await round5();


    ///////////////////////
    // Final adjustments //
    ///////////////////////

    proof.protocol = "plonk";
    proof.curve = curve.name;

    await fdZKey.close();
    await fdWtns.close();

    let publicSignals = [];

    for (let i=1; i<= zkey.nPublic; i++) {
        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);
        publicSignals.push(Scalar.fromRprLE(pub));
    }

    proof.A = G1.toObject(proof.A);
    proof.B = G1.toObject(proof.B);
    proof.C = G1.toObject(proof.C);
    proof.Z = G1.toObject(proof.Z);

    proof.T1 = G1.toObject(proof.T1);
    proof.T2 = G1.toObject(proof.T2);
    proof.T3 = G1.toObject(proof.T3);

    proof.eval_a = Fr.toObject(proof.eval_a);
    proof.eval_b = Fr.toObject(proof.eval_b);
    proof.eval_c = Fr.toObject(proof.eval_c);
    proof.eval_s1 = Fr.toObject(proof.eval_s1);
    proof.eval_s2 = Fr.toObject(proof.eval_s2);
    proof.eval_zw = Fr.toObject(proof.eval_zw);
    proof.eval_t = Fr.toObject(proof.eval_t);
    proof.eval_r = Fr.toObject(proof.eval_r);

    proof.Wxi = G1.toObject(proof.Wxi);
    proof.Wxiw = G1.toObject(proof.Wxiw);

    delete proof.eval_t;

    proof = stringifyBigInts(proof);
    publicSignals = stringifyBigInts(publicSignals);

    return {proof, publicSignals};

    async function calculateAdditions() {
        const additionsBuff = await binFileUtils.readSection(fdZKey, sectionsZKey, 3);

        const sSum = 8+curve.Fr.n8*2;

        for (let i=0; i<zkey.nAdditions; i++) {
            const ai= readUInt32(additionsBuff, i*sSum);
            const bi= readUInt32(additionsBuff, i*sSum+4);
            const ac= additionsBuff.slice(i*sSum+8, i*sSum+8+n8r);
            const bc= additionsBuff.slice(i*sSum+8+n8r, i*sSum+8+n8r*2);
            const aw= getWitness(ai);
            const bw= getWitness(bi);

            const r = curve.Fr.add(
                curve.Fr.mul(ac, aw),
                curve.Fr.mul(bc, bw)
            );
            buffInternalWitness.set(r, n8r*i);
        }

    }

    async function buildABC() {
        let A = new BigBuffer(zkey.domainSize * n8r);
        let B = new BigBuffer(zkey.domainSize * n8r);
        let C = new BigBuffer(zkey.domainSize * n8r);

        const aMap = await binFileUtils.readSection(fdZKey, sectionsZKey, 4);
        const bMap = await binFileUtils.readSection(fdZKey, sectionsZKey, 5);
        const cMap = await binFileUtils.readSection(fdZKey, sectionsZKey, 6);

        for (let i=0; i<zkey.nConstrains; i++) {
            const iA = readUInt32(aMap, i*4);
            A.set(getWitness(iA), i*n8r);
            const iB = readUInt32(bMap, i*4);
            B.set(getWitness(iB), i*n8r);
            const iC = readUInt32(cMap, i*4);
            C.set(getWitness(iC), i*n8r);
        }

        A = await Fr.batchToMontgomery(A);
        B = await Fr.batchToMontgomery(B);
        C = await Fr.batchToMontgomery(C);

        return [A,B,C];
    }

    function readUInt32(b, o) {
        const buff = b.slice(o, o+4);
        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
        return buffV.getUint32(0, true);
    }

    function getWitness(idx) {
        if (idx < zkey.nVars-zkey.nAdditions) {
            return buffWitness.slice(idx*n8r, idx*n8r+n8r);
        } else if (idx < zkey.nVars) {
            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);
        } else {
            return curve.Fr.zero;
        }
    }

    async function round1() {
        ch.b = [];
        for (let i=1; i<=11; i++) {
            ch.b[i] = curve.Fr.random();
        }
    
        [A, B, C] = await buildABC();

        [pol_a, A4] = await to4T(A, [ch.b[2], ch.b[1]]);
        [pol_b, B4] = await to4T(B, [ch.b[4], ch.b[3]]);
        [pol_c, C4] = await to4T(C, [ch.b[6], ch.b[5]]);

                
        proof.A = await expTau(pol_a, "multiexp A");
        proof.B = await expTau(pol_b, "multiexp B");
        proof.C = await expTau(pol_c, "multiexp C");
    }

    async function round2() {

        const transcript1 = new Uint8Array(zkey.nPublic*n8r + G1.F.n8*2*3);
        for (let i=0; i<zkey.nPublic; i++) {
            Fr.toRprBE(transcript1, i*n8r, A.slice((i)*n8r, (i+1)*n8r));
        }
        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + 0, proof.A);
        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + G1.F.n8*2, proof.B);
        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + G1.F.n8*4, proof.C);

        ch.beta = hashToFr(transcript1);
        if (logger) logger.debug("beta: " + Fr.toString(ch.beta));
    
        const transcript2 = new Uint8Array(n8r);
        Fr.toRprBE(transcript2, 0, ch.beta);
        ch.gamma = hashToFr(transcript2);
        if (logger) logger.debug("gamma: " + Fr.toString(ch.gamma));
    
        let numArr = new BigBuffer(Fr.n8*zkey.domainSize);
        let denArr = new BigBuffer(Fr.n8*zkey.domainSize);

        numArr.set(Fr.one, 0);
        denArr.set(Fr.one, 0);

        let w = Fr.one;
        for (let i=0; i<zkey.domainSize; i++) {
            let n1 = A.slice(i*n8r, (i+1)*n8r);
            n1 = Fr.add( n1, Fr.mul(ch.beta, w) );
            n1 = Fr.add( n1, ch.gamma );

            let n2 = B.slice(i*n8r, (i+1)*n8r);
            n2 = Fr.add( n2, Fr.mul(zkey.k1, Fr.mul(ch.beta, w) ));
            n2 = Fr.add( n2, ch.gamma );

            let n3 = C.slice(i*n8r, (i+1)*n8r);
            n3 = Fr.add( n3, Fr.mul(zkey.k2, Fr.mul(ch.beta, w) ));
            n3 = Fr.add( n3, ch.gamma );

            const num = Fr.mul(n1, Fr.mul(n2, n3));

            let d1 = A.slice(i*n8r, (i+1)*n8r);
            d1 = Fr.add(d1, Fr.mul( sigmaBuff.slice(i*n8r*4, i*n8r*4 + n8r) , ch.beta));
            d1 = Fr.add(d1, ch.gamma);

            let d2 = B.slice(i*n8r, (i+1)*n8r);
            d2 = Fr.add(d2, Fr.mul( sigmaBuff.slice((zkey.domainSize + i)*4*n8r, (zkey.domainSize + i)*4*n8r+n8r) , ch.beta));
            d2 = Fr.add(d2, ch.gamma);

            let d3 = C.slice(i*n8r, (i+1)*n8r);
            d3 = Fr.add(d3, Fr.mul( sigmaBuff.slice((zkey.domainSize*2 + i)*4*n8r, (zkey.domainSize*2 + i)*4*n8r + n8r) , ch.beta));
            d3 = Fr.add(d3, ch.gamma);

            const den = Fr.mul(d1, Fr.mul(d2, d3));

            numArr.set(  
                Fr.mul( 
                    numArr.slice(i*n8r,(i+1)*n8r) , 
                    num
                ),
                ((i+1)%zkey.domainSize)*n8r
            );

            denArr.set(  
                Fr.mul( 
                    denArr.slice(i*n8r,(i+1)*n8r) , 
                    den
                ),
                ((i+1)%zkey.domainSize)*n8r
            );

            w = Fr.mul(w, Fr.w[zkey.power]);
        }

        denArr = await Fr.batchInverse(denArr);

        // TODO: Do it in assembly and in parallel
        for (let i=0; i<zkey.domainSize; i++) {
            numArr.set(   Fr.mul( numArr.slice(i*n8r, (i+1)*n8r), denArr.slice(i*n8r, (i+1)*n8r) )      ,i*n8r);
        }

        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {
            throw new Error("Copy constraints does not match");
