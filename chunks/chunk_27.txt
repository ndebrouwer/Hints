            c.call(f3mPrefix + "_add", AUX, AUX, AUX),
            c.call(f3mPrefix + "_sub", RY, AUX, RY),

            // Z3 = (Y1+Z1)^2-C-Z1^2
            c.call(f3mPrefix + "_add", Y , RZ, AUX),
            c.call(f3mPrefix + "_square", AUX, AUX),
            c.call(f3mPrefix + "_square", RZ, RZ),
            c.call(f3mPrefix + "_add", RZ, C, RZ),
            c.call(f3mPrefix + "_sub", AUX, RZ, RZ),

            // T3 = Z3^2
            c.call(f3mPrefix + "_square", RZ, RT),

            // H = (Z3+T1)^2-T3-A
            c.call(f3mPrefix + "_add", RZ, T, DC_H),
            c.call(f3mPrefix + "_square", DC_H, DC_H),
            c.call(f3mPrefix + "_sub", DC_H, RT, DC_H),
            c.call(f3mPrefix + "_sub", DC_H, A, DC_H),

            // fourC = 4*C
            c.call(f3mPrefix + "_add", C, C, DC_4C),
            c.call(f3mPrefix + "_add", DC_4C, DC_4C, DC_4C),

            // J = (F+T1)^2-G-A
            c.call(f3mPrefix + "_add", F, T, DC_J),
            c.call(f3mPrefix + "_square", DC_J, DC_J),
            c.call(f3mPrefix + "_sub", DC_J, G, DC_J),
            c.call(f3mPrefix + "_sub", DC_J, A, DC_J),

            // L = (F+X1)^2-G-B
            c.call(f3mPrefix + "_add", F, X, DC_L),
            c.call(f3mPrefix + "_square", DC_L, DC_L),
            c.call(f3mPrefix + "_sub", DC_L, G, DC_L),
            c.call(f3mPrefix + "_sub", DC_L, B, DC_L),
        );
    }

    function buildMillerLoop() {
        const f = module.addFunction(prefix+ "_millerLoop");
        f.addParam("ppreP", "i32");
        f.addParam("ppreQ", "i32");
        f.addParam("r", "i32");
        f.addLocal("pDbl", "i32");
        f.addLocal("pAdd", "i32");
        f.addLocal("i", "i32");

        const c = f.getCodeBuilder();

        const preP_PX = c.getLocal("ppreP");
        const preP_PX_twist = c.i32_add(c.getLocal("ppreP"), c.i32_const(f1size*2));
        const preP_PY_twist = c.i32_add(c.getLocal("ppreP"), c.i32_const(f1size*2 + f3size));

        const preQ_QX_twist = c.i32_add( c.getLocal("ppreQ"), c.i32_const(f3size*3));
        const preQ_QY_twist = c.i32_add( c.getLocal("ppreQ"), c.i32_const(f3size*4));

        const pL1Coef = module.alloc(f3size);
        const L1Coef = c.i32_const(pL1Coef);
        const L1Coef_0 = c.i32_const(pL1Coef);
        const L1Coef_1 = c.i32_const(pL1Coef+f1size);
        const L1Coef_2 = c.i32_const(pL1Coef+2*f1size);

        const pEV_at_P = module.alloc(ftsize);
        const EV_at_P = c.i32_const(pEV_at_P);
        const EV_at_P_0 = c.i32_const(pEV_at_P);
        const EV_at_P_1 = c.i32_const(pEV_at_P+f3size);

        const DC_H  = c.getLocal("pDbl");
        const DC_4C = c.i32_add(c.getLocal("pDbl"), c.i32_const(f3size));
        const DC_J  = c.i32_add(c.getLocal("pDbl"), c.i32_const(2*f3size));
        const DC_L  = c.i32_add(c.getLocal("pDbl"), c.i32_const(3*f3size));

        const AC_L1  = c.getLocal("pAdd");
        const AC_RZ = c.i32_add(c.getLocal("pAdd"), c.i32_const(f3size));

        const F = c.getLocal("r");

        const pAUX = module.alloc(f3size);
        const AUX = c.i32_const(pAUX);

        f.addCode(
            c.call(f1mPrefix + "_copy", preP_PX, L1Coef_0),
            c.call(f1mPrefix + "_zero", L1Coef_1),
            c.call(f1mPrefix + "_zero", L1Coef_2),

            c.call(f3mPrefix + "_sub", L1Coef, preQ_QX_twist, L1Coef),

            c.call(ftmPrefix + "_one", F),

            c.setLocal("pDbl", c.i32_add( c.getLocal("ppreQ"), c.i32_const(f3size*5))),
            c.setLocal("pAdd", c.i32_add( c.getLocal("pDbl"), c.i32_const(ateNDblCoefs*ateDblCoefSize))),

            c.setLocal("i", c.i32_const(ateLoopBitBytes.length-2)),
            c.block(c.loop(

                c.call(f3mPrefix + "_mul", DC_J, preP_PX_twist, EV_at_P_0),
                c.call(f3mPrefix + "_sub", DC_L, EV_at_P_0, EV_at_P_0),
                c.call(f3mPrefix + "_sub", EV_at_P_0, DC_4C, EV_at_P_0),

                c.call(f3mPrefix + "_mul", DC_H, preP_PY_twist, EV_at_P_1),

                c.call(ftmPrefix + "_square", F, F),
                c.call(ftmPrefix + "_mul", F, EV_at_P, F),

                c.setLocal("pDbl", c.i32_add(c.getLocal("pDbl"), c.i32_const(ateDblCoefSize))),

                c.if(
                    c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
                    [
                        ...c.call(f3mPrefix + "_mul", AC_RZ, preP_PY_twist, EV_at_P_0),

                        ...c.call(f3mPrefix + "_mul", AC_RZ, preQ_QY_twist, EV_at_P_1),
                        ...c.call(f3mPrefix + "_mul", L1Coef, AC_L1, AUX),
                        ...c.call(f3mPrefix + "_add", EV_at_P_1, AUX, EV_at_P_1),
                        ...c.call(f3mPrefix + "_neg", EV_at_P_1, EV_at_P_1),

                        ...c.call(ftmPrefix + "_mul", F, EV_at_P, F),

                        ...c.setLocal("pAdd", c.i32_add(c.getLocal("pAdd"), c.i32_const(ateAddCoefSize))),
                    ]
                ),
                c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
                c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            ))

        );

        if (isLoopNegative) {
            f.addCode(
                c.call(f3mPrefix + "_mul", AC_RZ, preP_PY_twist, EV_at_P_0),

                c.call(f3mPrefix + "_mul", AC_RZ, preQ_QY_twist, EV_at_P_1),
                c.call(f3mPrefix + "_mul", L1Coef, AC_L1, AUX),
                c.call(f3mPrefix + "_add", EV_at_P_1, AUX, EV_at_P_1),
                c.call(f3mPrefix + "_neg", EV_at_P_1, EV_at_P_1),

                c.call(ftmPrefix + "_mul", F, EV_at_P, F),

                /// Next line not needed because it's going to be the last one.
                // c.setLocal("pAdd", c.i32_add(c.getLocal("pAdd"), c.i32_const(ateAddCoefSize))),
            );
        }

    }

    function buildComputeLineFunctions() {
        const f = module.addFunction(prefix+ "_computeLineFunctions");
        f.addParam("ppreP", "i32");
        f.addParam("ppreQ", "i32");
        f.addParam("r", "i32");
        f.addLocal("pDbl", "i32");
        f.addLocal("pAdd", "i32");
        f.addLocal("i", "i32");

        const c = f.getCodeBuilder();

        const preP_PX = c.getLocal("ppreP");
        const preP_PX_twist = c.i32_add(c.getLocal("ppreP"), c.i32_const(f1size*2));
        const preP_PY_twist = c.i32_add(c.getLocal("ppreP"), c.i32_const(f1size*2 + f3size));

        const preQ_QX_twist = c.i32_add( c.getLocal("ppreQ"), c.i32_const(f3size*3));
        const preQ_QY_twist = c.i32_add( c.getLocal("ppreQ"), c.i32_const(f3size*4));

        const pL1Coef = module.alloc(f3size);
        const L1Coef = c.i32_const(pL1Coef);
        const L1Coef_0 = c.i32_const(pL1Coef);
        const L1Coef_1 = c.i32_const(pL1Coef+f1size);
        const L1Coef_2 = c.i32_const(pL1Coef+2*f1size);

        const pEV_at_P = module.alloc(ftsize);
        const EV_at_P = c.i32_const(pEV_at_P);
        const EV_at_P_0 = c.i32_const(pEV_at_P);
        const EV_at_P_1 = c.i32_const(pEV_at_P+f3size);

        const DC_H  = c.getLocal("pDbl");
        const DC_4C = c.i32_add(c.getLocal("pDbl"), c.i32_const(f3size));
        const DC_J  = c.i32_add(c.getLocal("pDbl"), c.i32_const(2*f3size));
        const DC_L  = c.i32_add(c.getLocal("pDbl"), c.i32_const(3*f3size));

        const AC_L1  = c.getLocal("pAdd");
        const AC_RZ = c.i32_add(c.getLocal("pAdd"), c.i32_const(f3size));

        const pRes = c.getLocal("r");

        const pAUX = module.alloc(f3size);
        const AUX = c.i32_const(pAUX);

        function getPResOffset() {
            return c.i32_add( pRes, c.i32_mul( c.getLocal("i"), c.i32_const(ftsize)));
        }

        f.addCode(
            c.call(f1mPrefix + "_copy", preP_PX, L1Coef_0),
            c.call(f1mPrefix + "_zero", L1Coef_1),
            c.call(f1mPrefix + "_zero", L1Coef_2),

            c.call(f3mPrefix + "_sub", L1Coef, preQ_QX_twist, L1Coef),

            c.setLocal("pDbl", c.i32_add( c.getLocal("ppreQ"), c.i32_const(f3size*5))),
            c.setLocal("pAdd", c.i32_add( c.getLocal("pDbl"), c.i32_const(ateNDblCoefs*ateDblCoefSize))),

            c.setLocal("i", c.i32_const(ateLoopBitBytes.length-2)),
            c.block(c.loop(

                c.call(f3mPrefix + "_mul", DC_J, preP_PX_twist, EV_at_P_0),
                c.call(f3mPrefix + "_sub", DC_L, EV_at_P_0, EV_at_P_0),
                c.call(f3mPrefix + "_sub", EV_at_P_0, DC_4C, EV_at_P_0),

                c.call(f3mPrefix + "_mul", DC_H, preP_PY_twist, EV_at_P_1),

                c.call(ftmPrefix + "_mul", getPResOffset(), EV_at_P, getPResOffset()),

                c.setLocal("pDbl", c.i32_add(c.getLocal("pDbl"), c.i32_const(ateDblCoefSize))),

                c.if(
                    c.i32_load8_s(c.getLocal("i"), pAteLoopBitBytes),
                    [
                        ...c.call(f3mPrefix + "_mul", AC_RZ, preP_PY_twist, EV_at_P_0),

                        ...c.call(f3mPrefix + "_mul", AC_RZ, preQ_QY_twist, EV_at_P_1),
                        ...c.call(f3mPrefix + "_mul", L1Coef, AC_L1, AUX),
                        ...c.call(f3mPrefix + "_add", EV_at_P_1, AUX, EV_at_P_1),
                        ...c.call(f3mPrefix + "_neg", EV_at_P_1, EV_at_P_1),

                        ...c.call(ftmPrefix + "_mul", getPResOffset(), EV_at_P, getPResOffset()),

                        ...c.setLocal("pAdd", c.i32_add(c.getLocal("pAdd"), c.i32_const(ateAddCoefSize))),
                    ]
                ),
                c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
                c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            ))

        );

        if (isLoopNegative) {
            f.addCode(
                c.setLocal("i", c.i32_const(ateLoopBitBytes.length-1)),
                c.call(f3mPrefix + "_mul", AC_RZ, preP_PY_twist, EV_at_P_0),

                c.call(f3mPrefix + "_mul", AC_RZ, preQ_QY_twist, EV_at_P_1),
                c.call(f3mPrefix + "_mul", L1Coef, AC_L1, AUX),
                c.call(f3mPrefix + "_add", EV_at_P_1, AUX, EV_at_P_1),
                c.call(f3mPrefix + "_neg", EV_at_P_1, EV_at_P_1),

                c.call(ftmPrefix + "_mul", getPResOffset(), EV_at_P, getPResOffset()),

                /// Next line not needed because it's going to be the last one.
                // c.setLocal("pAdd", c.i32_add(c.getLocal("pAdd"), c.i32_const(ateAddCoefSize))),
            );
        }

    }

    function buildFusedMillerLoop() {
        const f = module.addFunction(prefix+ "_fusedMillerLoop");
        f.addParam("l", "i32");
        f.addParam("r", "i32");
        f.addLocal("i", "i32");

        const c = f.getCodeBuilder();

        const l = c.getLocal("l");
        const F = c.getLocal("r");

        function getLineFunctionOffset() {
            return c.i32_add( l, c.i32_mul( c.getLocal("i"), c.i32_const(ftsize)));
        }

        f.addCode(
            c.call(ftmPrefix + "_one", F),

            c.setLocal("i", c.i32_const(ateLoopBitBytes.length-2)),
            c.block(c.loop(

                c.call(ftmPrefix + "_square", F, F),
                c.call(ftmPrefix + "_mul", F, getLineFunctionOffset(), F),

                c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
                c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            ))

        );

        if (isLoopNegative) {
            f.addCode(
                c.setLocal("i", c.i32_const(ateLoopBitBytes.length-1)),
                c.call(ftmPrefix + "_mul", F, getLineFunctionOffset(), F),

                /// Next line not needed because it's going to be the last one.
                // c.setLocal("pAdd", c.i32_add(c.getLocal("pAdd"), c.i32_const(ateAddCoefSize))),
            );
        }

    }

    function buildCombineLineFunctions() {
        const f = module.addFunction(prefix+ "_combineLineFunctions");
        f.addParam("l", "i32");
        f.addParam("r", "i32");
        f.addParam("res", "i32");
        f.addLocal("i", "i32");

        const c = f.getCodeBuilder();

        const l = c.getLocal("l");
        const r = c.getLocal("r");
        const pRes = c.getLocal("res");

        function getLLineFunctionOffset() {
            return c.i32_add( l, c.i32_mul( c.getLocal("i"), c.i32_const(ftsize)));
        }

        function getRLineFunctionOffset() {
            return c.i32_add( r, c.i32_mul( c.getLocal("i"), c.i32_const(ftsize)));
        }

        function getPResLineFunctionOffset() {
            return c.i32_add( pRes, c.i32_mul( c.getLocal("i"), c.i32_const(ftsize)));
        }

        f.addCode(
            c.setLocal("i", c.i32_const(ateLoopBitBytes.length-2)),
            c.block(c.loop(

                c.call(ftmPrefix + "_mul", getLLineFunctionOffset(), getRLineFunctionOffset(), getPResLineFunctionOffset()),

                c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
                c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            ))

        );

        if (isLoopNegative) {
            f.addCode(
                c.setLocal("i", c.i32_const(ateLoopBitBytes.length-1)),
                c.call(ftmPrefix + "_mul", getLLineFunctionOffset(), getRLineFunctionOffset(), getPResLineFunctionOffset()),

                /// Next line not needed because it's going to be the last one.
                // c.setLocal("pAdd", c.i32_add(c.getLocal("pAdd"), c.i32_const(ateAddCoefSize))),
            );
        }

    }


    function buildFrobeniusMap(n) {
        const F6 = [
            [
                1n,
                1n,
                1n,
                1n,
                1n,
                1n,
            ],
            [
                1n,
                24129022407817241407134263419936114379815707076943508280977368156625538709102831814843582780138963119807143081677569721953561801075623741378629346409604471234573396989178424163772589090105392407118197799904755622897541183052133n,
                24129022407817241407134263419936114379815707076943508280977368156625538709102831814843582780138963119807143081677569721953561801075623741378629346409604471234573396989178424163772589090105392407118197799904755622897541183052132n,
                41898490967918953402344214791240637128170709919953949071783502921025352812571106773058893763790338921418070971888458477323173057491593855069696241854796396165721416325350064441470418137846398469611935719059908164220784476160000n,
                17769468560101711995209951371304522748355002843010440790806134764399814103468274958215310983651375801610927890210888755369611256415970113691066895445191924931148019336171640277697829047741006062493737919155152541323243293107868n,
                17769468560101711995209951371304522748355002843010440790806134764399814103468274958215310983651375801610927890210888755369611256415970113691066895445191924931148019336171640277697829047741006062493737919155152541323243293107869n,
            ]
        ];

        const F3 = [
            [
                1n,
                1n,
                1n,
            ],
            [
                1n,
                24129022407817241407134263419936114379815707076943508280977368156625538709102831814843582780138963119807143081677569721953561801075623741378629346409604471234573396989178424163772589090105392407118197799904755622897541183052132n,
                17769468560101711995209951371304522748355002843010440790806134764399814103468274958215310983651375801610927890210888755369611256415970113691066895445191924931148019336171640277697829047741006062493737919155152541323243293107868n,
            ],
            [
                1n,
                17769468560101711995209951371304522748355002843010440790806134764399814103468274958215310983651375801610927890210888755369611256415970113691066895445191924931148019336171640277697829047741006062493737919155152541323243293107868n,
                24129022407817241407134263419936114379815707076943508280977368156625538709102831814843582780138963119807143081677569721953561801075623741378629346409604471234573396989178424163772589090105392407118197799904755622897541183052132n,
            ]
        ];

        const f = module.addFunction(prefix+ "__frobeniusMap"+n);
        f.addParam("x", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        for (let i=0; i<6; i++) {
            const X = (i==0) ? c.getLocal("x") : c.i32_add(c.getLocal("x"), c.i32_const(i*f1size));
            const R = (i==0) ? c.getLocal("r") : c.i32_add(c.getLocal("r"), c.i32_const(i*f1size));
            const coef = F6[Math.floor(i/3)][n%6] * F3[i%3][n%3];
            if (coef !== 1n) {
                const pCoef =  module.alloc(
                    utils.bigInt2BytesLE(
                        toMontgomery(coef),
                        96
                    )
                );
                f.addCode(c.call(f1mPrefix + "_mul", X, c.i32_const(pCoef), R));
            } else {
                f.addCode(c.call(f1mPrefix + "_copy", X, R));
            }
        }
    }


    function buildCyclotomicSquare() {
        const f = module.addFunction(prefix+ "__cyclotomicSquare");
        f.addParam("x", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        const C00 = c.getLocal("x");
        const C01 = c.i32_add(c.getLocal("x"), c.i32_const(f1size));
        const C02 = c.i32_add(c.getLocal("x"), c.i32_const(2*f1size));
        const C10 = c.i32_add(c.getLocal("x"), c.i32_const(3*f1size));
        const C11 = c.i32_add(c.getLocal("x"), c.i32_const(4*f1size));
        const C12 = c.i32_add(c.getLocal("x"), c.i32_const(5*f1size));

        const pA = module.alloc(f1size*2);
        const A = c.i32_const(pA);
        const A0 = c.i32_const(pA);
        const A1 = c.i32_const(pA+f1size);

        const pB = module.alloc(f1size*2);
        const B = c.i32_const(pB);
        const B0 = c.i32_const(pB);
        const B1 = c.i32_const(pB+f1size);

        const pC = module.alloc(f1size*2);
        const C = c.i32_const(pC);
        const C0 = c.i32_const(pC);
        const C1 = c.i32_const(pC+f1size);

        const pASQ = module.alloc(f2size);
        const ASQ = c.i32_const(pASQ);
        const ASQ0 = c.i32_const(pASQ);
        const ASQ1 = c.i32_const(pASQ+f1size);

        const pBSQ = module.alloc(f2size);
        const BSQ = c.i32_const(pBSQ);
        const BSQ0 = c.i32_const(pBSQ);
        const BSQ1 = c.i32_const(pBSQ+f1size);

        const pCSQ = module.alloc(f2size);
        const CSQ = c.i32_const(pCSQ);
        const CSQ0 = c.i32_const(pCSQ);
        const CSQ1 = c.i32_const(pCSQ+f1size);

        const Aa = c.getLocal("r");
        const Ab = c.i32_add(c.getLocal("r"), c.i32_const(4*f1size));
        const Ba = c.i32_add(c.getLocal("r"), c.i32_const(3*f1size));
        const Bb = c.i32_add(c.getLocal("r"), c.i32_const(2*f1size));
        const Ca = c.i32_add(c.getLocal("r"), c.i32_const(1*f1size));
        const Cb = c.i32_add(c.getLocal("r"), c.i32_const(5*f1size));

        const AUX = c.i32_const(module.alloc(f1size));

        f.addCode(
            c.call(f1mPrefix + "_copy", C00, A0),
            c.call(f1mPrefix + "_copy", C11, A1),
            c.call(f1mPrefix + "_copy", C10, B0),
            c.call(f1mPrefix + "_copy", C02, B1),
            c.call(f1mPrefix + "_copy", C01, C0),
            c.call(f1mPrefix + "_copy", C12, C1),

            c.call(f2mPrefix + "_square", A, ASQ),
            c.call(f2mPrefix + "_square", B, BSQ),
            c.call(f2mPrefix + "_square", C, CSQ),

            // A = vector(3*a^2 - 2*Fp2([vector(a)[0],-vector(a)[1]]))
            // Aa = 3 * ASQ0 - 2 * A0;
            c.call(f1mPrefix + "_sub", ASQ0, A0, Aa),
            c.call(f1mPrefix + "_add", Aa, Aa, Aa),
            c.call(f1mPrefix + "_add", Aa, ASQ0, Aa),
            // Ab = 3 * ASQ1 + 2 * A1;
            c.call(f1mPrefix + "_add", ASQ1, A1, Ab),
            c.call(f1mPrefix + "_add", Ab, Ab, Ab),
            c.call(f1mPrefix + "_add", Ab, ASQ1, Ab),

            // B = vector(3*Fp2([non_residue*c2[1],c2[0]]) + 2*Fp2([vector(b)[0],-vector(b)[1]]))
            // Ba = 3 * non_residue * CSQ1 + 2 * B0;
            c.call(prefix + "_mulNR3", CSQ1, AUX),
            c.call(f1mPrefix + "_add", AUX, B0, Ba),
            c.call(f1mPrefix + "_add", Ba, Ba, Ba),
            c.call(f1mPrefix + "_add", Ba, AUX, Ba),
            // Bb = 3*CSQ0 - 2 * B1;
            c.call(f1mPrefix + "_sub", CSQ0, B1, Bb),
            c.call(f1mPrefix + "_add", Bb, Bb, Bb),
            c.call(f1mPrefix + "_add", Bb, CSQ0, Bb),

            // C = vector(3*b^2 - 2*Fp2([vector(c)[0],-vector(c)[1]]))
            // Ca = 3 * BSQ0 - 2 * C0;
            c.call(f1mPrefix + "_sub", BSQ0, C0, Ca),
            c.call(f1mPrefix + "_add", Ca, Ca, Ca),
            c.call(f1mPrefix + "_add", Ca, BSQ0, Ca),
            // Cb = 3 * BSQ1 + 2 * C1;
            c.call(f1mPrefix + "_add", BSQ1, C1, Cb),
            c.call(f1mPrefix + "_add", Cb, Cb, Cb),
            c.call(f1mPrefix + "_add", Cb, BSQ1, Cb),
        );
    }

    function buildCyclotomicExp(exponent, fnName) {
        const exponentNafBytes = naf(exponent).map( (b) => (b==-1 ? 0xFF: b) );
        const pExponentNafBytes = module.alloc(exponentNafBytes);

        const f = module.addFunction(prefix+ "__cyclotomicExp_"+fnName);
        f.addParam("x", "i32");
        f.addParam("r", "i32");
        f.addLocal("bit", "i32");
        f.addLocal("i", "i32");

        const c = f.getCodeBuilder();

        const x = c.getLocal("x");
        const x00 = c.getLocal("x");
        const x01 = c.i32_add(c.getLocal("x"), c.i32_const(f1size));
        const x02 = c.i32_add(c.getLocal("x"), c.i32_const(2*f1size));
        const x10 = c.i32_add(c.getLocal("x"), c.i32_const(3*f1size));
        const x11 = c.i32_add(c.getLocal("x"), c.i32_const(4*f1size));
        const x12 = c.i32_add(c.getLocal("x"), c.i32_const(5*f1size));

        const res = c.getLocal("r");

        const pInverse = module.alloc(ftsize);
        const inverse = c.i32_const(pInverse);
        const inverse00 = c.i32_const(pInverse);
        const inverse01 = c.i32_const(pInverse+f1size);
        const inverse02 = c.i32_const(pInverse+2*f1size);
        const inverse10 = c.i32_const(pInverse+3*f1size);
        const inverse11 = c.i32_const(pInverse+4*f1size);
        const inverse12 = c.i32_const(pInverse+5*f1size);


        f.addCode(
            c.call(f1mPrefix + "_copy", x00, inverse00),
            c.call(f1mPrefix + "_copy", x01, inverse01),
            c.call(f1mPrefix + "_copy", x02, inverse02),
            c.call(f1mPrefix + "_neg", x10, inverse10),
            c.call(f1mPrefix + "_neg", x11, inverse11),
            c.call(f1mPrefix + "_neg", x12, inverse12),
            c.call(ftmPrefix + "_one", res),

            c.if(
                c.teeLocal("bit", c.i32_load8_s(c.i32_const(exponentNafBytes.length-1), pExponentNafBytes)),
                c.if(
                    c.i32_eq(
                        c.getLocal("bit"),
                        c.i32_const(1)
                    ),
                    c.call(ftmPrefix + "_mul", res, x, res),
                    c.call(ftmPrefix + "_mul", res, inverse, res),
                )
            ),

            c.setLocal("i", c.i32_const(exponentNafBytes.length-2)),
            c.block(c.loop(
                c.call(prefix + "__cyclotomicSquare", res, res),
                c.if(
                    c.teeLocal("bit", c.i32_load8_s(c.getLocal("i"), pExponentNafBytes)),
                    c.if(
                        c.i32_eq(
                            c.getLocal("bit"),
                            c.i32_const(1)
                        ),
                        c.call(ftmPrefix + "_mul", res, x, res),
                        c.call(ftmPrefix + "_mul", res, inverse, res),
                    )
                ),
                c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
                c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            ))
        );
    }

    function buildFinalExponentiationLastChunk() {
        const MNT6753_final_exponent_last_chunk_abs_of_w0 = 204691208819330962009469868104636132783269696790011977400223898462431810102935615891307667367766898917669754470400n;

        buildCyclotomicSquare();
        buildCyclotomicExp(MNT6753_final_exponent_last_chunk_abs_of_w0, "w0");
        const f = module.addFunction(prefix+ "__finalExponentiationLastChunk");
        f.addParam("x", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        const elt = c.getLocal("x");
        const result = c.getLocal("r");
        const w1part = c.i32_const(module.alloc(ftsize));
        const w0part = c.i32_const(module.alloc(ftsize));

        f.addCode(
            c.call(prefix + "__frobeniusMap1", elt, w1part),
            c.call(prefix + "__cyclotomicExp_w0", elt, w0part),
            c.call(ftmPrefix + "_mul", w1part, w0part, result),
        );
    }


    function buildFinalExponentiationFirstChunk() {

        const f = module.addFunction(prefix+ "__finalExponentiationFirstChunk");
        f.addParam("x", "i32");
        f.addParam("xi", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        const elt = c.getLocal("x");
        const eltInv = c.getLocal("xi");
        const beta = c.getLocal("r");
        const eltQ3 = c.i32_const(module.alloc(ftsize));
        const eltQ3OverElt = c.i32_const(module.alloc(ftsize));
        const alpha = c.i32_const(module.alloc(ftsize));

        f.addCode(
            c.call(prefix + "__frobeniusMap3", elt, eltQ3),
            c.call(ftmPrefix + "_mul", eltQ3, eltInv, eltQ3OverElt),
            c.call(prefix + "__frobeniusMap1", eltQ3OverElt, alpha),
            c.call(ftmPrefix + "_mul", alpha, eltQ3OverElt, beta),
        );
    }

    function buildFinalExponentiation() {
        buildFinalExponentiationFirstChunk();
        buildFinalExponentiationLastChunk();
        const f = module.addFunction(prefix+ "_finalExponentiation");
        f.addParam("x", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        const elt = c.getLocal("x");
        const result = c.getLocal("r");
        const eltInv = c.i32_const(module.alloc(ftsize));
        const eltToFirstChunk = c.i32_const(module.alloc(ftsize));

        f.addCode(
            c.call(ftmPrefix + "_inverse", elt, eltInv ),
            c.call(prefix + "__finalExponentiationFirstChunk", elt, eltInv, eltToFirstChunk ),
            c.call(prefix + "__finalExponentiationLastChunk", eltToFirstChunk, result )
        );
    }


    function buildFinalExponentiationOld() {
        const f = module.addFunction(prefix+ "_finalExponentiationOld");
        f.addParam("x", "i32");
        f.addParam("r", "i32");

        const exponent = 129119521415595396014710306456032421075529786121916339618043051454538645105373777417137765707049510513015090026587997279208509759539952171373399816556184658054246934445122434683712249758515142075912382855071692226902812699306965286452865875620478620415339135536651578138124630852841411245063114044076427626521354349718502952988285309849333541213630352110932043828698936614474460281448819530109126473106492442797180252857193080048552501189491359213783058841481431978392771722128135286229420891567559544903231970966039315305865230923024300814788334307759652908820805819427293129932717325550045066338621261382334584633469485279042507653112873505613662346162595624798718660978835342384244182483671072189980911818690903244207181753883232560300278713216908336381030175242331281836803196022816489406715804002685525498662502919760346302653911463614694097216541218340832160715975576449518733830908486041613391828183354500089193133793376316346927602330584336604894214847791219714282509301093232896394808735738348953422584365914239193758384912179069975047674736700432948221178135004609440079320720726286913134205559121306917942266019404840960000n;
        const pExponent = module.alloc(utils.bigInt2BytesLE( exponent, 472 ));

        const c = f.getCodeBuilder();

        f.addCode(
            c.call(ftmPrefix + "_exp", c.getLocal("x"), c.i32_const(pExponent), c.i32_const(472), c.getLocal("r")),
        );
    }

    const pPreP = module.alloc(prePSize);
    const pPreQ = module.alloc(preQSize);

    function buildPairingEquation(nPairings) {

        const f = module.addFunction(prefix+ "_pairingEq"+nPairings);
        for (let i=0; i<nPairings; i++) {
            f.addParam("p_"+i, "i32");
            f.addParam("q_"+i, "i32");
        }
        f.addParam("c", "i32");
        f.setReturnType("i32");


        const c = f.getCodeBuilder();

        const resT = c.i32_const(module.alloc(ftsize));
        const auxT = c.i32_const(module.alloc(ftsize));

        f.addCode(c.call(ftmPrefix + "_one", resT ));

        for (let i=0; i<nPairings; i++) {

            f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p_"+i), c.i32_const(pPreP) ));
            f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q_"+i), c.i32_const(pPreQ) ));
            f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), auxT ));

            f.addCode(c.call(ftmPrefix + "_mul", resT, auxT, resT ));
        }

        f.addCode(c.call(prefix + "_finalExponentiation", resT, resT ));

        f.addCode(c.call(ftmPrefix + "_eq", resT, c.getLocal("c")));
    }


    function buildPairing() {

        const f = module.addFunction(prefix+ "_pairing");
        f.addParam("p", "i32");
        f.addParam("q", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        const resT = c.i32_const(module.alloc(ftsize));

        f.addCode(c.call(prefix + "_prepareG1", c.getLocal("p"), c.i32_const(pPreP) ));
        f.addCode(c.call(prefix + "_prepareG2", c.getLocal("q"), c.i32_const(pPreQ) ));
        f.addCode(c.call(prefix + "_millerLoop", c.i32_const(pPreP), c.i32_const(pPreQ), resT ));
        f.addCode(c.call(prefix + "_finalExponentiation", resT, c.getLocal("r") ));
    }

    function buildGroupMap() {

        const f = module.addFunction(prefix+ "_groupMap");
        f.addParam("t", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        const ResX = c.getLocal("r");
        const ResY = c.i32_add(c.getLocal("r"), c.i32_const(n8));
        const ResZ = c.i32_add(c.getLocal("r"), c.i32_const(n8*2));

        const T = c.getLocal("t");
        const U = c.i32_const(module.modules["f1m"].pOne);

        const _a = 11n;
        const A = c.i32_const(module.alloc(utils.bigInt2BytesLE((_a << BigInt(n64*64)) % q, n8)));
        const _b = 11625908999541321152027340224010374716841167701783584648338908235410859267060079819722747939267925389062611062156601938166010098747920378738927832658133625454260115409075816187555055859490253375704728027944315501122723426879114n;
        const B = c.i32_const(module.alloc(utils.bigInt2BytesLE((_b << BigInt(n64*64)) % q, n8)));
        const _uOver2 = modInv(2n, q);
        const UOver2 = c.i32_const(module.alloc(utils.bigInt2BytesLE((_uOver2 << BigInt(n64*64)) % q, n8)));
        const _conicC = 10474622741979738350586053697810159282042677479988487267945875730256338203142776693264723440947584730354517742972114619330793264372898463767424060463699099041430354081337516110367604534461599617402983929764977041055196119040012n;
        const ConicC = c.i32_const(module.alloc(utils.bigInt2BytesLE((_conicC << BigInt(n64*64)) % q, n8)));
        const _prjZ = 38365735639699746381939366704915555468563774296792699496721397906733830428037078183799997086205833647489050605889539959322880863358082391473031143521765387671570958090617625358358885062894615919620647426481572278916894388596945n;
        const ProjZ = c.i32_const(module.alloc(utils.bigInt2BytesLE((_prjZ << BigInt(n64*64)) % q, n8)));
        const ProjY = U;

        const CT = c.i32_const(module.alloc(f1size));
        const S = c.i32_const(module.alloc(f1size));
        const Z = c.i32_const(module.alloc(f1size));
        const Y = c.i32_const(module.alloc(f1size));
        const V = c.i32_const(module.alloc(f1size));
        const X = c.i32_const(module.alloc(f1size));
        const Y2 = c.i32_const(module.alloc(f1size));
        const AUX1 = c.i32_const(module.alloc(f1size));
        const AUX2 = c.i32_const(module.alloc(f1size));

        f.addCode(
            // ct = ConicC * T
            c.call(f1mPrefix + "_mul", ConicC, T, CT),

            //          CT*ProjY + ProjZ
            // S = 2 * ---------------
            //           CT*t + 1
            c.call(f1mPrefix + "_add", CT, ProjZ, AUX1),
            c.call(f1mPrefix + "_mul", CT, T, AUX2),
            c.call(f1mPrefix + "_add", AUX2, U, AUX2),
            c.call(f1mPrefix + "_inverse", AUX2, AUX2),
            c.call(f1mPrefix + "_mul", AUX1, AUX2, S),
            c.call(f1mPrefix + "_add", S, S, S),

            // Z = ProjZ - S
            c.call(f1mPrefix + "_sub", ProjZ, S, Z),

            // Y = ProjY - S*t
            c.call(f1mPrefix + "_mul", S, T, Y),
            c.call(f1mPrefix + "_sub", ProjY, Y, Y),

            // V = Z/Y - 1/2
            c.call(f1mPrefix + "_inverse", Y, V),
            c.call(f1mPrefix + "_mul", V, Z, V),
            c.call(f1mPrefix + "_sub", V, UOver2, V),

            // Test X = V
            c.call(f1mPrefix + "_copy", V, X),

            // Y2 = X^3 + A*X + B
            c.call(f1mPrefix + "_square", X, Y2),
            c.call(f1mPrefix + "_mul", Y2, X, Y2),
            c.call(f1mPrefix + "_mul", A, X, AUX1),
            c.call(f1mPrefix + "_add", Y2, AUX1, Y2),
            c.call(f1mPrefix + "_add", Y2, B, Y2),

            c.if(
                c.call(f1mPrefix + "_isSquare", Y2),
                [
                    ...c.call(f1mPrefix + "_copy", X, ResX),
                    ...c.call(f1mPrefix + "_sqrt", Y2, ResY),
                    ...c.call(f1mPrefix + "_one", ResZ),
                    ...c.ret([])
                ]
            ),

            // Test X = -U-V
            c.call(f1mPrefix + "_add", U, V, X),
            c.call(f1mPrefix + "_neg", X, X),

            // Y2 = X^3 + A*X + B
            c.call(f1mPrefix + "_square", X, Y2),
            c.call(f1mPrefix + "_mul", Y2, X, Y2),
            c.call(f1mPrefix + "_mul", A, X, AUX1),
            c.call(f1mPrefix + "_add", Y2, AUX1, Y2),
            c.call(f1mPrefix + "_add", Y2, B, Y2),

            c.if(
                c.call(f1mPrefix + "_isSquare", Y2),
                [
                    ...c.call(f1mPrefix + "_copy", X, ResX),
                    ...c.call(f1mPrefix + "_sqrt", Y2, ResY),
                    ...c.call(f1mPrefix + "_one", ResZ),
                    ...c.ret([])
                ]
            ),

            // Test X = 1 + Y^_square2
            c.call(f1mPrefix + "_square", Y, X),
            c.call(f1mPrefix + "_add", U, X, X),

            // Y2 = X^3 + A*X + B
            c.call(f1mPrefix + "_square", X, Y2),
            c.call(f1mPrefix + "_mul", Y2, X, Y2),
            c.call(f1mPrefix + "_mul", A, X, AUX1),
            c.call(f1mPrefix + "_add", Y2, AUX1, Y2),
            c.call(f1mPrefix + "_add", Y2, B, Y2),

            c.if(
                c.call(f1mPrefix + "_isSquare", Y2),
                [
                    ...c.call(f1mPrefix + "_copy", X, ResX),
                    ...c.call(f1mPrefix + "_sqrt", Y2, ResY),
                    ...c.call(f1mPrefix + "_one", ResZ),
                    ...c.ret([])
                ]
            ),
            c.unreachable()
        );

    }


    buildPrepDblStep();
    buildPrepAddStep();

    buildPrepareG1();
    buildPrepareG2();

    for (let i=0; i<10; i++) {
        buildFrobeniusMap(i);
        module.exportFunction(prefix + "__frobeniusMap"+i);
    }

    buildMillerLoop();
    buildComputeLineFunctions();
    buildFusedMillerLoop();
    buildCombineLineFunctions();

    buildFinalExponentiation();
    buildFinalExponentiationOld();

    buildPairingEquation(1);
    buildPairingEquation(2);
    buildPairingEquation(3);

    buildPairing();
    buildGroupMap();

    module.exportFunction(prefix + "_pairingEq1");
    module.exportFunction(prefix + "_pairingEq2");
    module.exportFunction(prefix + "_pairingEq3");

    module.exportFunction(prefix + "_pairing");
    module.exportFunction(prefix + "_groupMap");

    module.exportFunction(prefix + "_prepareG1");
    module.exportFunction(prefix + "_prepareG2");
    module.exportFunction(prefix + "_millerLoop");
    module.exportFunction(prefix + "_computeLineFunctions");
    module.exportFunction(prefix + "_fusedMillerLoop");
    module.exportFunction(prefix + "_combineLineFunctions");
    module.exportFunction(prefix + "_finalExponentiationOld");
    module.exportFunction(prefix + "_finalExponentiation");
    module.exportFunction(prefix + "__finalExponentiationFirstChunk");
    module.exportFunction(prefix + "__cyclotomicExp_w0");
};




---
File: /@zk-email/helpers/node_modules/wasmcurves/src/bigint.js
---

// Many of these utilities are from the `big-integer` library,
// but adjusted to only work with native BigInt type
// Ref https://github.com/peterolson/BigInteger.js/blob/e5d2154d3c417069c51e7116bafc3b91d0b9fe41/BigInteger.js
// Originally licensed The Unlicense

function compare(a, b) {
    return a === b ? 0 : a > b ? 1 : -1;
}

function square(n) {
    return n * n;
}

function isOdd(n) {
    return n % 2n !== 0n;
}

function isEven(n) {
    return n % 2n === 0n;
}

function isNegative(n) {
    return n < 0n;
}

function isPositive(n) {
    return n > 0n;
}

function bitLength(n) {
    if (isNegative(n)) {
        return n.toString(2).length - 1; // discard the - sign
    } else {
        return n.toString(2).length;
    }
}

function abs(n) {
    return n < 0n ? -n : n;
}

function isUnit(n) {
    return abs(n) === 1n;
}

function modInv(a, n) {
    var t = 0n, newT = 1n, r = n, newR = abs(a), q, lastT, lastR;
    while (newR !== 0n) {
        q = r / newR;
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT - (q * newT);
        newR = lastR - (q * newR);
    }
    if (!isUnit(r)) throw new Error(a.toString() + " and " + n.toString() + " are not co-prime");
    if (compare(t, 0n) === -1) {
        t = t + n;
    }
    if (isNegative(a)) {
        return -t;
    }
    return t;
}

function modPow(n, exp, mod) {
    if (mod === 0n) throw new Error("Cannot take modPow with modulus 0");
    var r = 1n,
        base = n % mod;
    if (isNegative(exp)) {
        exp = exp * -1n;
        base = modInv(base, mod);
    }
    while (isPositive(exp)) {
        if (base === 0n) return 0n;
        if (isOdd(exp)) r = r * base % mod;
        exp = exp / 2n;
        base = square(base) % mod;
    }
    return r;
}

function compareAbs(a, b) {
    a = a >= 0n ? a : -a;
    b = b >= 0n ? b : -b;
    return a === b ? 0 : a > b ? 1 : -1;
}

function isDivisibleBy(a, n) {
    if (n === 0n) return false;
    if (isUnit(n)) return true;
    if (compareAbs(n, 2n) === 0) return isEven(a);
    return a % n === 0n;
}

function isBasicPrime(v) {
    var n = abs(v);
    if (isUnit(n)) return false;
    if (n === 2n || n === 3n || n === 5n) return true;
    if (isEven(n) || isDivisibleBy(n, 3n) || isDivisibleBy(n, 5n)) return false;
    if (n < 49n) return true;
    // we don't know if it's prime: let the other functions figure it out
}

function prev(n) {
    return n - 1n;
}

function millerRabinTest(n, a) {
    var nPrev = prev(n),
        b = nPrev,
        r = 0,
        d, i, x;
    while (isEven(b)) b = b / 2n, r++;
    next: for (i = 0; i < a.length; i++) {
        if (n < a[i]) continue;
        x = modPow(BigInt(a[i]), b, n);
        if (isUnit(x) || x === nPrev) continue;
        for (d = r - 1; d != 0; d--) {
            x = square(x) % n;
            if (isUnit(x)) return false;
            if (x === nPrev) continue next;
        }
        return false;
    }
    return true;
}

function isPrime(p) {
    var isPrime = isBasicPrime(p);
    if (isPrime !== undefined) return isPrime;
    var n = abs(p);
    var bits = bitLength(n);
    if (bits <= 64)
        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
    var logN = Math.log(2) * Number(bits);
    var t = Math.ceil(logN);
    for (var a = [], i = 0; i < t; i++) {
        a.push(BigInt(i + 2));
    }
    return millerRabinTest(n, a);
}

module.exports.bitLength = bitLength;
module.exports.isOdd = isOdd;
module.exports.isNegative = isNegative;
module.exports.abs = abs;
module.exports.isUnit = isUnit;
module.exports.compare = compare;
module.exports.modInv = modInv;
module.exports.modPow = modPow;
module.exports.isPrime = isPrime;
module.exports.square = square;



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_applykey.js
---



/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/

module.exports = function buildApplyKey(module, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {

    const f = module.addFunction(fnName);
    f.addParam("pIn", "i32");
    f.addParam("n", "i32");
    f.addParam("pFirst", "i32");
    f.addParam("pInc", "i32");
    f.addParam("pOut", "i32");
    f.addLocal("pOldFree", "i32");
    f.addLocal("i", "i32");
    f.addLocal("pFrom", "i32");
    f.addLocal("pTo", "i32");

    const c = f.getCodeBuilder();

    const t = c.i32_const(module.alloc(sizeF));

    f.addCode(
        c.setLocal("pFrom", c.getLocal("pIn")),
        c.setLocal("pTo", c.getLocal("pOut")),
    );

    // t = first
    f.addCode(
        c.call(
            frPrefix + "_copy",
            c.getLocal("pFirst"),
            t
        )
    );
    f.addCode(
        c.setLocal("i", c.i32_const(0)),
        c.block(c.loop(
            c.br_if(1, c.i32_eq ( c.getLocal("i"), c.getLocal("n") )),

            c.call(
                opGtimesF,
                c.getLocal("pFrom"),
                t,
                c.getLocal("pTo")
            ),
            c.setLocal("pFrom", c.i32_add(c.getLocal("pFrom"), c.i32_const(sizeGIn))),
            c.setLocal("pTo", c.i32_add(c.getLocal("pTo"), c.i32_const(sizeGOut))),

            // t = t* inc
            c.call(
                frPrefix + "_mul",
                t,
                c.getLocal("pInc"),
                t
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
        ))
    );

    module.exportFunction(fnName);

};



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_batchconvertion.js
---



module.exports = buildBatchConvertion;

function buildBatchConvertion(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {
    if (typeof reverse === "undefined") {
        // Set the reverse in a way that allows to use the same buffer as in/out.
        if (sizeIn < sizeOut) {
            reverse = true;
        } else {
            reverse = false;
        }
    }

    const f = module.addFunction(fnName);
    f.addParam("pIn", "i32");
    f.addParam("n", "i32");
    f.addParam("pOut", "i32");
    f.addLocal("i", "i32");
    f.addLocal("itIn", "i32");
    f.addLocal("itOut", "i32");

    const c = f.getCodeBuilder();

    if (reverse) {
        f.addCode(
            c.setLocal("itIn",
                c.i32_add(
                    c.getLocal("pIn"),
                    c.i32_mul(
                        c.i32_sub(
                            c.getLocal("n"),
                            c.i32_const(1)
                        ),
                        c.i32_const(sizeIn)
                    )
                )
            ),
            c.setLocal("itOut",
                c.i32_add(
                    c.getLocal("pOut"),
                    c.i32_mul(
                        c.i32_sub(
                            c.getLocal("n"),
                            c.i32_const(1)
                        ),
                        c.i32_const(sizeOut)
                    )
                )
            ),
            c.setLocal("i", c.i32_const(0)),
            c.block(c.loop(
                c.br_if(1, c.i32_eq ( c.getLocal("i"), c.getLocal("n") )),

                c.call(internalFnName, c.getLocal("itIn"), c.getLocal("itOut")),

                c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.i32_const(sizeIn))),
                c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(sizeOut))),
                c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            )),
        );
    } else {
        f.addCode(
            c.setLocal("itIn", c.getLocal("pIn")),
            c.setLocal("itOut", c.getLocal("pOut")),
            c.setLocal("i", c.i32_const(0)),
            c.block(c.loop(
                c.br_if(1, c.i32_eq ( c.getLocal("i"), c.getLocal("n") )),

                c.call(internalFnName, c.getLocal("itIn"), c.getLocal("itOut")),

                c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.i32_const(sizeIn))),
                c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(sizeOut))),
                c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            )),
        );
    }
}



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_batchinverse.js
---


module.exports = buildBatchInverse;

function buildBatchInverse(module, prefix) {


    const n8 = module.modules[prefix].n64*8;

    const f = module.addFunction(prefix+"_batchInverse");
    f.addParam("pIn", "i32");
    f.addParam("inStep", "i32");
    f.addParam("n", "i32");
    f.addParam("pOut", "i32");
    f.addParam("outStep", "i32");
    f.addLocal("itAux", "i32");
    f.addLocal("itIn", "i32");
    f.addLocal("itOut","i32");
    f.addLocal("i","i32");

    const c = f.getCodeBuilder();

    const AUX = c.i32_const(module.alloc(n8));


    // Alloc Working space for accumulated umltiplications
    f.addCode(
        c.setLocal("itAux", c.i32_load( c.i32_const(0) )),
        c.i32_store(
            c.i32_const(0),
            c.i32_add(
                c.getLocal("itAux"),
                c.i32_mul(
                    c.i32_add(
                        c.getLocal("n"),
                        c.i32_const(1)
                    ),
                    c.i32_const(n8)
                )
            )
        )
    );

    f.addCode(

        // aux[0] = a;
        c.call(prefix+"_one", c.getLocal("itAux")),
        // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]
        c.setLocal("itIn", c.getLocal("pIn")),
        c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
        c.setLocal("i", c.i32_const(0)),

        c.block(c.loop(
            c.br_if(1, c.i32_eq ( c.getLocal("i"), c.getLocal("n") )),
            c.if(
                c.call(prefix+"_isZero", c.getLocal("itIn")),
                c.call(
                    prefix + "_copy",
                    c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
                    c.getLocal("itAux")
                ),
                c.call(
                    prefix+"_mul",
                    c.getLocal("itIn"),
                    c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
                    c.getLocal("itAux")
                )
            ),
            c.setLocal("itIn", c.i32_add(c.getLocal("itIn"), c.getLocal("inStep"))),
            c.setLocal("itAux", c.i32_add(c.getLocal("itAux"), c.i32_const(n8))),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
        )),

        // point to the last
        c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.getLocal("inStep"))),
        c.setLocal("itAux", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))),
        // itOut = pOut + (n-1)*stepOut   // Point to the last
        c.setLocal(
            "itOut",
            c.i32_add(
                c.getLocal("pOut"),
                c.i32_mul(
                    c.i32_sub(c.getLocal("n"), c.i32_const(1)),
                    c.getLocal("outStep"),
                )
            )
        ),

        // aux[n-1] = 1/aux[n-1]
        c.call(prefix+"_inverse", c.getLocal("itAux"), c.getLocal("itAux") ),

        c.block(c.loop(
            c.br_if(1, c.i32_eqz( c.getLocal("i"))),
            c.if(
                c.call(prefix+"_isZero", c.getLocal("itIn")),
                [
                    ...c.call(
                        prefix + "_copy",
                        c.getLocal("itAux"),
                        c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
                    ),
                    ...c.call(
                        prefix + "_zero",
                        c.getLocal("itOut")
                    )
                ],[
                    ...c.call(prefix + "_copy", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)), AUX),
                    ...c.call(
                        prefix+"_mul",
                        c.getLocal("itAux"),
                        c.getLocal("itIn"),
                        c.i32_sub(c.getLocal("itAux"), c.i32_const(n8)),
                    ),
                    ...c.call(
                        prefix+"_mul",
                        c.getLocal("itAux"),
                        AUX,
                        c.getLocal("itOut")
                    )
                ]
            ),
            c.setLocal("itIn", c.i32_sub(c.getLocal("itIn"), c.getLocal("inStep"))),
            c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.getLocal("outStep"))),
            c.setLocal("itAux", c.i32_sub(c.getLocal("itAux"), c.i32_const(n8))),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
        ))

    );


    // Recover Old memory
    f.addCode(
        c.i32_store(
            c.i32_const(0),
            c.getLocal("itAux")
        )
    );

}



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_batchop.js
---



module.exports = buildBatchConvertion;

function buildBatchConvertion(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {
    if (typeof reverse === "undefined") {
        // Set the reverse in a way that allows to use the same buffer as in/out.
        if (sizeIn < sizeOut) {
            reverse = true;
        } else {
            reverse = false;
        }
    }

    const f = module.addFunction(fnName);
    f.addParam("pIn1", "i32");
    f.addParam("pIn2", "i32");
    f.addParam("n", "i32");
    f.addParam("pOut", "i32");
    f.addLocal("i", "i32");
    f.addLocal("itIn1", "i32");
    f.addLocal("itIn2", "i32");
    f.addLocal("itOut", "i32");

    const c = f.getCodeBuilder();

    if (reverse) {
        f.addCode(
            c.setLocal("itIn1",
                c.i32_add(
                    c.getLocal("pIn1"),
                    c.i32_mul(
                        c.i32_sub(
                            c.getLocal("n"),
                            c.i32_const(1)
                        ),
                        c.i32_const(sizeIn)
                    )
                )
            ),
            c.setLocal("itIn2",
                c.i32_add(
                    c.getLocal("pIn2"),
                    c.i32_mul(
                        c.i32_sub(
                            c.getLocal("n"),
                            c.i32_const(1)
                        ),
                        c.i32_const(sizeIn)
                    )
                )
            ),
            c.setLocal("itOut",
                c.i32_add(
                    c.getLocal("pOut"),
                    c.i32_mul(
                        c.i32_sub(
                            c.getLocal("n"),
                            c.i32_const(1)
                        ),
                        c.i32_const(sizeOut)
                    )
                )
            ),
            c.setLocal("i", c.i32_const(0)),
            c.block(c.loop(
                c.br_if(1, c.i32_eq ( c.getLocal("i"), c.getLocal("n") )),

                c.call(internalFnName, c.getLocal("itIn1"), c.getLocal("itIn2"), c.getLocal("itOut")),

                c.setLocal("itIn1", c.i32_sub(c.getLocal("itIn1"), c.i32_const(sizeIn))),
                c.setLocal("itIn2", c.i32_sub(c.getLocal("itIn2"), c.i32_const(sizeIn))),
                c.setLocal("itOut", c.i32_sub(c.getLocal("itOut"), c.i32_const(sizeOut))),
                c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            )),
        );
    } else {
        f.addCode(
            c.setLocal("itIn1", c.getLocal("pIn1")),
            c.setLocal("itIn2", c.getLocal("pIn2")),
            c.setLocal("itOut", c.getLocal("pOut")),
            c.setLocal("i", c.i32_const(0)),
            c.block(c.loop(
                c.br_if(1, c.i32_eq ( c.getLocal("i"), c.getLocal("n") )),

                c.call(internalFnName, c.getLocal("itIn1"), c.getLocal("itIn2"), c.getLocal("itOut")),

                c.setLocal("itIn1", c.i32_add(c.getLocal("itIn1"), c.i32_const(sizeIn))),
                c.setLocal("itIn2", c.i32_add(c.getLocal("itIn2"), c.i32_const(sizeIn))),
                c.setLocal("itOut", c.i32_add(c.getLocal("itOut"), c.i32_const(sizeOut))),
                c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
                c.br(0)
            )),
        );
    }
}



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_curve_jacobian_a0.js
---

/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/

const buildTimesScalarNAF = require("./build_timesscalarnaf");
//const buildTimesScalar = require("./build_timesscalar");
const buildBatchConvertion = require("./build_batchconvertion");
const buildMultiexp = require("./build_multiexp");

module.exports = function buildCurve(module, prefix, prefixField, pB) {


    const n64 = module.modules[prefixField].n64;
    const n8 = n64*8;

    if (module.modules[prefix]) return prefix;  // already builded
    module.modules[prefix] = {
        n64: n64*3
    };

    function buildIsZero() {
        const f = module.addFunction(prefix + "_isZero");
        f.addParam("p1", "i32");
        f.setReturnType("i32");

        const c = f.getCodeBuilder();

        f.addCode(c.call(
            prefixField + "_isZero",
            c.i32_add(
                c.getLocal("p1"),
                c.i32_const(n8*2)
            )
        ));
    }
    function buildIsZeroAffine() {
        const f = module.addFunction(prefix + "_isZeroAffine");
        f.addParam("p1", "i32");
        f.setReturnType("i32");

        const c = f.getCodeBuilder();

        f.addCode(
            c.i32_and(
                c.call(
                    prefixField + "_isZero",
                    c.getLocal("p1")
                ),
                c.call(
                    prefixField + "_isZero",
                    c.i32_add(
                        c.getLocal("p1"),
                        c.i32_const(n8)
                    )
                )
            )
        );
    }

    function buildCopy() {
        const f = module.addFunction(prefix + "_copy");
        f.addParam("ps", "i32");
        f.addParam("pd", "i32");

        const c = f.getCodeBuilder();

        for (let i=0; i<n64*3; i++) {
            f.addCode(
                c.i64_store(
                    c.getLocal("pd"),
                    i*8,
                    c.i64_load(
                        c.getLocal("ps"),
                        i*8
                    )
                )
            );
        }
    }


    function buildCopyAffine() {
        const f = module.addFunction(prefix + "_copyAffine");
        f.addParam("ps", "i32");
        f.addParam("pd", "i32");

        const c = f.getCodeBuilder();

        for (let i=0; i<n64*2; i++) {
            f.addCode(
                c.i64_store(
                    c.getLocal("pd"),
                    i*8,
                    c.i64_load(
                        c.getLocal("ps"),
                        i*8
                    )
                )
            );
        }

    }


    function buildZero() {
        const f = module.addFunction(prefix + "_zero");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        f.addCode(c.call(
            prefixField + "_zero",
            c.getLocal("pr")
        ));

        f.addCode(c.call(
            prefixField + "_one",
            c.i32_add(
                c.getLocal("pr"),
                c.i32_const(n8)
            )
        ));

        f.addCode(c.call(
            prefixField + "_zero",
            c.i32_add(
                c.getLocal("pr"),
                c.i32_const(n8*2)
            )
        ));
    }


    function buildZeroAffine() {
        const f = module.addFunction(prefix + "_zeroAffine");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        f.addCode(c.call(
            prefixField + "_zero",
            c.getLocal("pr")
        ));

        f.addCode(c.call(
            prefixField + "_zero",
            c.i32_add(
                c.getLocal("pr"),
                c.i32_const(n8)
            )
        ));
    }

    function buildEq() {
        const f = module.addFunction(prefix + "_eq");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");
        f.addLocal("z2", "i32");

        const c = f.getCodeBuilder();

        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8*2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        f.addCode(c.setLocal("z2", c.i32_add(c.getLocal("p2"), c.i32_const(n8*2))));
        const z2 = c.getLocal("z2");

        const Z1Z1 = c.i32_const(module.alloc(n8));
        const Z2Z2 = c.i32_const(module.alloc(n8));
        const U1 = c.i32_const(module.alloc(n8));
        const U2 = c.i32_const(module.alloc(n8));
        const Z1_cubed = c.i32_const(module.alloc(n8));
        const Z2_cubed = c.i32_const(module.alloc(n8));
        const S1 = c.i32_const(module.alloc(n8));
        const S2 = c.i32_const(module.alloc(n8));


        f.addCode(
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p1")),
                c.ret( c.call(prefix + "_isZero", c.getLocal("p2"))),
            ),
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p2")),
                c.ret(c.i32_const(0))
            ),
            c.if(
                c.call(prefixField + "_isOne", z1),
                c.ret(c.call(prefix + "_eqMixed", c.getLocal("p2"), c.getLocal("p1")))
            ),
            c.if(
                c.call(prefixField + "_isOne", z2),
                c.ret(c.call(prefix + "_eqMixed", c.getLocal("p1"), c.getLocal("p2")))
            ),

            c.call(prefixField + "_square", z1, Z1Z1),
            c.call(prefixField + "_square", z2, Z2Z2),
            c.call(prefixField + "_mul", x1, Z2Z2, U1),
            c.call(prefixField + "_mul", x2, Z1Z1, U2),
            c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
            c.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
            c.call(prefixField + "_mul", y1, Z2_cubed, S1),
            c.call(prefixField + "_mul", y2, Z1_cubed, S2),

            c.if(
                c.call(prefixField + "_eq", U1, U2),
                c.if(
                    c.call(prefixField + "_eq", S1, S2),
                    c.ret(c.i32_const(1))
                )
            ),
            c.ret(c.i32_const(0))
        );
    }


    function buildEqMixed() {
        const f = module.addFunction(prefix + "_eqMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");

        const c = f.getCodeBuilder();

        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8*2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));

        const Z1Z1 = c.i32_const(module.alloc(n8));
        const U2 = c.i32_const(module.alloc(n8));
        const Z1_cubed = c.i32_const(module.alloc(n8));
        const S2 = c.i32_const(module.alloc(n8));

        f.addCode(
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p1")),
                c.ret( c.call(prefix + "_isZeroAffine", c.getLocal("p2"))),
            ),
            c.if(
                c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
                c.ret(c.i32_const(0))
            ),
            c.if(
                c.call(prefixField + "_isOne", z1),
                c.ret(c.call(prefix + "_eqAffine", c.getLocal("p1"), c.getLocal("p2")))
            ),
            c.call(prefixField + "_square", z1, Z1Z1),
            c.call(prefixField + "_mul", x2, Z1Z1, U2),
            c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
            c.call(prefixField + "_mul", y2, Z1_cubed, S2),

            c.if(
                c.call(prefixField + "_eq", x1, U2),
                c.if(
                    c.call(prefixField + "_eq", y1, S2),
                    c.ret(c.i32_const(1))
                )
            ),
            c.ret(c.i32_const(0))
        );
    }

    function buildDouble() {
        const f = module.addFunction(prefix + "_double");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8*2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8*2));

        const A = c.i32_const(module.alloc(n8));
        const B = c.i32_const(module.alloc(n8));
        const C = c.i32_const(module.alloc(n8));
        const D = c.i32_const(module.alloc(n8));
        const E = c.i32_const(module.alloc(n8));
        const F = c.i32_const(module.alloc(n8));
        const G = c.i32_const(module.alloc(n8));
        const eightC = c.i32_const(module.alloc(n8));

        f.addCode(
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p1")),
                [
                    ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
                    ...c.ret([])
                ]
            ),
            c.if(
                c.call(prefixField + "_isOne", z),
                [
                    ...c.ret(c.call(prefix + "_doubleAffine", c.getLocal("p1"), c.getLocal("pr"))),
                    ...c.ret([])
                ]
            ),

            c.call(prefixField + "_square", x, A),
            c.call(prefixField + "_square", y, B),
            c.call(prefixField + "_square", B, C),

            c.call(prefixField + "_add", x, B, D),
            c.call(prefixField + "_square", D, D),
            c.call(prefixField + "_sub", D, A, D),
            c.call(prefixField + "_sub", D, C, D),
            c.call(prefixField + "_add", D, D, D),

            c.call(prefixField + "_add", A, A, E),
            c.call(prefixField + "_add", E, A, E),
            c.call(prefixField + "_square", E, F),

            c.call(prefixField + "_mul", y, z, G),

            c.call(prefixField + "_add", D, D, x3),
            c.call(prefixField + "_sub", F, x3, x3),

            c.call(prefixField + "_add", C, C, eightC),
            c.call(prefixField + "_add", eightC, eightC, eightC),
            c.call(prefixField + "_add", eightC, eightC, eightC),

            c.call(prefixField + "_sub", D, x3, y3),
            c.call(prefixField + "_mul", y3, E, y3),
            c.call(prefixField + "_sub", y3, eightC, y3),

            c.call(prefixField + "_add", G, G, z3),
        );
    }


    function buildDoubleAffine() {
        const f = module.addFunction(prefix + "_doubleAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8*2));

        const XX = c.i32_const(module.alloc(n8));
        const YY = c.i32_const(module.alloc(n8));
        const YYYY = c.i32_const(module.alloc(n8));
        const S = c.i32_const(module.alloc(n8));
        const M = c.i32_const(module.alloc(n8));
        const eightYYYY = c.i32_const(module.alloc(n8));

        f.addCode(
            c.if(
                c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
                [
                    ...c.call(prefix + "_toJacobian", c.getLocal("p1"), c.getLocal("pr")),
                    ...c.ret([])
                ]
            ),

            // XX = X1^2
            c.call(prefixField + "_square", x, XX),

            // YY = Y1^2
            c.call(prefixField + "_square", y, YY),

            // YYYY = YY^2
            c.call(prefixField + "_square", YY, YYYY),

            // S = 2*((X1+YY)^2-XX-YYYY)
            c.call(prefixField + "_add", x, YY, S),
            c.call(prefixField + "_square", S, S),
            c.call(prefixField + "_sub", S, XX, S),
            c.call(prefixField + "_sub", S, YYYY, S),
            c.call(prefixField + "_add", S, S, S),

            // M = 3*XX+a  (Hera a=0)
            c.call(prefixField + "_add", XX, XX, M),
            c.call(prefixField + "_add", M, XX, M),

            // Z3 = 2*Y1
            c.call(prefixField + "_add", y, y, z3),

            // T = M^2-2*S
            // X3 = T
            c.call(prefixField + "_square", M, x3),
            c.call(prefixField + "_sub", x3, S, x3),
            c.call(prefixField + "_sub", x3, S, x3),

            // Y3 = M*(S-T)-8*YYYY
            c.call(prefixField + "_add", YYYY, YYYY, eightYYYY),
            c.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
            c.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
            c.call(prefixField + "_sub", S, x3, y3),
            c.call(prefixField + "_mul", y3, M, y3),
            c.call(prefixField + "_sub", y3, eightYYYY, y3),
        );
    }


    function buildEqAffine() {
        const f = module.addFunction(prefix + "_eqAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.setReturnType("i32");
        f.addLocal("z1", "i32");

        const c = f.getCodeBuilder();

        f.addCode(
            c.ret(c.i32_and(
                c.call(
                    prefixField + "_eq",
                    c.getLocal("p1"),
                    c.getLocal("p2")
                ),
                c.call(
                    prefixField + "_eq",
                    c.i32_add(c.getLocal("p1"), c.i32_const(n8)),
                    c.i32_add(c.getLocal("p2"), c.i32_const(n8))
                )
            ))
        );
    }

    function buildToMontgomery() {
        const f = module.addFunction(prefix + "_toMontgomery");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        f.addCode(c.call(
            prefixField + "_toMontgomery",
            c.getLocal("p1"),
            c.getLocal("pr")
        ));
        for (let i=1; i<3; i++) {
            f.addCode(c.call(
                prefixField + "_toMontgomery",
                c.i32_add(c.getLocal("p1"), c.i32_const(i*n8)),
                c.i32_add(c.getLocal("pr"), c.i32_const(i*n8))
            ));
        }
    }

    function buildToMontgomeryAffine() {
        const f = module.addFunction(prefix + "_toMontgomeryAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        f.addCode(c.call(
            prefixField + "_toMontgomery",
            c.getLocal("p1"),
            c.getLocal("pr")
        ));
        for (let i=1; i<2; i++) {
            f.addCode(c.call(
                prefixField + "_toMontgomery",
                c.i32_add(c.getLocal("p1"), c.i32_const(i*n8)),
                c.i32_add(c.getLocal("pr"), c.i32_const(i*n8))
            ));
        }
    }

    function buildFromMontgomery() {
        const f = module.addFunction(prefix + "_fromMontgomery");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        f.addCode(c.call(
            prefixField + "_fromMontgomery",
            c.getLocal("p1"),
            c.getLocal("pr")
        ));
        for (let i=1; i<3; i++) {
            f.addCode(c.call(
                prefixField + "_fromMontgomery",
                c.i32_add(c.getLocal("p1"), c.i32_const(i*n8)),
                c.i32_add(c.getLocal("pr"), c.i32_const(i*n8))
            ));
        }
    }


    function buildFromMontgomeryAffine() {
        const f = module.addFunction(prefix + "_fromMontgomeryAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        f.addCode(c.call(
            prefixField + "_fromMontgomery",
            c.getLocal("p1"),
            c.getLocal("pr")
        ));
        for (let i=1; i<2; i++) {
            f.addCode(c.call(
                prefixField + "_fromMontgomery",
                c.i32_add(c.getLocal("p1"), c.i32_const(i*n8)),
                c.i32_add(c.getLocal("pr"), c.i32_const(i*n8))
            ));
        }
    }

    function buildAdd() {

        const f = module.addFunction(prefix + "_add");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");
        f.addLocal("z2", "i32");

        const c = f.getCodeBuilder();

        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8*2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        f.addCode(c.setLocal("z2", c.i32_add(c.getLocal("p2"), c.i32_const(n8*2))));
        const z2 = c.getLocal("z2");
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8*2));

        const Z1Z1 = c.i32_const(module.alloc(n8));
        const Z2Z2 = c.i32_const(module.alloc(n8));
        const U1 = c.i32_const(module.alloc(n8));
        const U2 = c.i32_const(module.alloc(n8));
        const Z1_cubed = c.i32_const(module.alloc(n8));
        const Z2_cubed = c.i32_const(module.alloc(n8));
        const S1 = c.i32_const(module.alloc(n8));
        const S2 = c.i32_const(module.alloc(n8));
        const H = c.i32_const(module.alloc(n8));
        const S2_minus_S1 = c.i32_const(module.alloc(n8));
        const I = c.i32_const(module.alloc(n8));
        const J = c.i32_const(module.alloc(n8));
        const r = c.i32_const(module.alloc(n8));
        const r2 = c.i32_const(module.alloc(n8));
        const V = c.i32_const(module.alloc(n8));
        const V2 = c.i32_const(module.alloc(n8));
        const S1_J2 = c.i32_const(module.alloc(n8));

        f.addCode(
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p1")),
                [
                    ...c.call(prefix + "_copy", c.getLocal("p2"), c.getLocal("pr")),
                    ...c.ret([])
                ]
            ),
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p2")),
                [
                    ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
                    ...c.ret([])
                ]
            ),
            c.if(
                c.call(prefixField + "_isOne", z1),
                [
                    ...c.call(prefix + "_addMixed", x2, x1, x3),
                    ...c.ret([])
                ]
            ),
            c.if(
                c.call(prefixField + "_isOne", z2),
                [
                    ...c.call(prefix + "_addMixed", x1, x2, x3),
                    ...c.ret([])
                ]
            ),
            c.call(prefixField + "_square", z1, Z1Z1),
            c.call(prefixField + "_square", z2, Z2Z2),
            c.call(prefixField + "_mul", x1, Z2Z2, U1),
            c.call(prefixField + "_mul", x2, Z1Z1, U2),
            c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
            c.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
            c.call(prefixField + "_mul", y1, Z2_cubed, S1),
            c.call(prefixField + "_mul", y2, Z1_cubed, S2),

            c.if(
                c.call(prefixField + "_eq", U1, U2),
                c.if(
                    c.call(prefixField + "_eq", S1, S2),
                    [
                        ...c.call(prefix + "_double", c.getLocal("p1"), c.getLocal("pr")),
                        ...c.ret([])
                    ]
                )
            ),

            c.call(prefixField + "_sub", U2, U1, H),
            c.call(prefixField + "_sub", S2, S1, S2_minus_S1),
            c.call(prefixField + "_add", H, H, I),
            c.call(prefixField + "_square", I, I),
            c.call(prefixField + "_mul", H, I, J),
            c.call(prefixField + "_add", S2_minus_S1, S2_minus_S1, r),
            c.call(prefixField + "_mul", U1, I, V),
            c.call(prefixField + "_square", r, r2),
            c.call(prefixField + "_add", V, V, V2),

            c.call(prefixField + "_sub", r2, J, x3),
            c.call(prefixField + "_sub", x3, V2, x3),

            c.call(prefixField + "_mul", S1, J, S1_J2),
            c.call(prefixField + "_add", S1_J2, S1_J2, S1_J2),

            c.call(prefixField + "_sub", V, x3, y3),
            c.call(prefixField + "_mul", y3, r, y3),
            c.call(prefixField + "_sub", y3, S1_J2, y3),

            c.call(prefixField + "_add", z1, z2, z3),
            c.call(prefixField + "_square", z3, z3),
            c.call(prefixField + "_sub", z3, Z1Z1, z3),
            c.call(prefixField + "_sub", z3, Z2Z2, z3),
            c.call(prefixField + "_mul", z3, H, z3),
        );

    }


    function buildAddMixed() {

        const f = module.addFunction(prefix + "_addMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");

        const c = f.getCodeBuilder();

        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8*2))));
        const z1 = c.getLocal("z1");
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8*2));

        const Z1Z1 = c.i32_const(module.alloc(n8));
        const U2 = c.i32_const(module.alloc(n8));
        const Z1_cubed = c.i32_const(module.alloc(n8));
        const S2 = c.i32_const(module.alloc(n8));
        const H = c.i32_const(module.alloc(n8));
        const HH = c.i32_const(module.alloc(n8));
        const S2_minus_y1 = c.i32_const(module.alloc(n8));
        const I = c.i32_const(module.alloc(n8));
        const J = c.i32_const(module.alloc(n8));
        const r = c.i32_const(module.alloc(n8));
        const r2 = c.i32_const(module.alloc(n8));
        const V = c.i32_const(module.alloc(n8));
        const V2 = c.i32_const(module.alloc(n8));
        const y1_J2 = c.i32_const(module.alloc(n8));

        f.addCode(
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p1")),
                [
                    ...c.call(prefix + "_copyAffine", c.getLocal("p2"), c.getLocal("pr")),
                    ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr") , c.i32_const(n8*2))),
                    ...c.ret([])
                ]
            ),
            c.if(
                c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
                [
                    ...c.call(prefix + "_copy", c.getLocal("p1"), c.getLocal("pr")),
                    ...c.ret([])
                ]
            ),
            c.if(
                c.call(prefixField + "_isOne", z1),
                [
                    ...c.call(prefix + "_addAffine", x1, x2, x3),
                    ...c.ret([])
                ]
            ),
            c.call(prefixField + "_square", z1, Z1Z1),
            c.call(prefixField + "_mul", x2, Z1Z1, U2),
            c.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
            c.call(prefixField + "_mul", y2, Z1_cubed, S2),

            c.if(
                c.call(prefixField + "_eq", x1, U2),
                c.if(
                    c.call(prefixField + "_eq", y1, S2),
                    [
                        ...c.call(prefix + "_doubleAffine", c.getLocal("p2"), c.getLocal("pr")),
                        ...c.ret([])
                    ]
                )
            ),

            c.call(prefixField + "_sub", U2, x1, H),
            c.call(prefixField + "_sub", S2, y1, S2_minus_y1),
            c.call(prefixField + "_square", H, HH),
            c.call(prefixField + "_add", HH , HH, I),
            c.call(prefixField + "_add", I , I, I),
            c.call(prefixField + "_mul", H, I, J),
            c.call(prefixField + "_add", S2_minus_y1, S2_minus_y1, r),
            c.call(prefixField + "_mul", x1, I, V),
            c.call(prefixField + "_square", r, r2),
            c.call(prefixField + "_add", V, V, V2),

            c.call(prefixField + "_sub", r2, J, x3),
            c.call(prefixField + "_sub", x3, V2, x3),

            c.call(prefixField + "_mul", y1, J, y1_J2),
            c.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),

            c.call(prefixField + "_sub", V, x3, y3),
            c.call(prefixField + "_mul", y3, r, y3),
            c.call(prefixField + "_sub", y3, y1_J2, y3),

            c.call(prefixField + "_add", z1, H, z3),
            c.call(prefixField + "_square", z3, z3),
            c.call(prefixField + "_sub", z3, Z1Z1, z3),
            c.call(prefixField + "_sub", z3, HH, z3),
        );
    }


    function buildAddAffine() {

        const f = module.addFunction(prefix + "_addAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");
        f.addLocal("z1", "i32");

        const c = f.getCodeBuilder();

        const x1 = c.getLocal("p1");
        const y1 = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        f.addCode(c.setLocal("z1", c.i32_add(c.getLocal("p1"), c.i32_const(n8*2))));
        const x2 = c.getLocal("p2");
        const y2 = c.i32_add(c.getLocal("p2"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8*2));

        const H = c.i32_const(module.alloc(n8));
        const HH = c.i32_const(module.alloc(n8));
        const y2_minus_y1 = c.i32_const(module.alloc(n8));
        const I = c.i32_const(module.alloc(n8));
        const J = c.i32_const(module.alloc(n8));
        const r = c.i32_const(module.alloc(n8));
        const r2 = c.i32_const(module.alloc(n8));
        const V = c.i32_const(module.alloc(n8));
        const V2 = c.i32_const(module.alloc(n8));
        const y1_J2 = c.i32_const(module.alloc(n8));

        f.addCode(
            c.if(
                c.call(prefix + "_isZeroAffine", c.getLocal("p1")),
                [
                    ...c.call(prefix + "_copyAffine", c.getLocal("p2"), c.getLocal("pr")),
                    ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr") , c.i32_const(n8*2))),
                    ...c.ret([])
                ]
            ),
            c.if(
                c.call(prefix + "_isZeroAffine", c.getLocal("p2")),
                [
                    ...c.call(prefix + "_copyAffine", c.getLocal("p1"), c.getLocal("pr")),
                    ...c.call(prefixField + "_one", c.i32_add(c.getLocal("pr") , c.i32_const(n8*2))),
                    ...c.ret([])
                ]
            ),


            c.if(
                c.call(prefixField + "_eq", x1, x2),
                c.if(
                    c.call(prefixField + "_eq", y1, y2),
                    [
                        ...c.call(prefix + "_doubleAffine", c.getLocal("p2"), c.getLocal("pr")),
                        ...c.ret([])
                    ]
                )
            ),

            c.call(prefixField + "_sub", x2, x1, H),
            c.call(prefixField + "_sub", y2, y1, y2_minus_y1),
            c.call(prefixField + "_square", H, HH),
            c.call(prefixField + "_add", HH , HH, I),
            c.call(prefixField + "_add", I , I, I),
            c.call(prefixField + "_mul", H, I, J),
            c.call(prefixField + "_add", y2_minus_y1, y2_minus_y1, r),
            c.call(prefixField + "_mul", x1, I, V),
            c.call(prefixField + "_square", r, r2),
            c.call(prefixField + "_add", V, V, V2),

            c.call(prefixField + "_sub", r2, J, x3),
            c.call(prefixField + "_sub", x3, V2, x3),

            c.call(prefixField + "_mul", y1, J, y1_J2),
            c.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),

            c.call(prefixField + "_sub", V, x3, y3),
            c.call(prefixField + "_mul", y3, r, y3),
            c.call(prefixField + "_sub", y3, y1_J2, y3),

            c.call(prefixField + "_add", H, H, z3),
        );
    }

    function buildNeg() {
        const f = module.addFunction(prefix + "_neg");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8*2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8*2));

        f.addCode(
            c.call(prefixField + "_copy", x, x3),
            c.call(prefixField + "_neg", y, y3),
            c.call(prefixField + "_copy", z, z3)
        );
    }


    function buildNegAffine() {
        const f = module.addFunction(prefix + "_negAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));

        f.addCode(
            c.call(prefixField + "_copy", x, x3),
            c.call(prefixField + "_neg", y, y3),
        );
    }


    function buildSub() {
        const f = module.addFunction(prefix + "_sub");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const AUX = c.i32_const(module.alloc(n8*3));

        f.addCode(
            c.call(prefix + "_neg", c.getLocal("p2"), AUX),
            c.call(prefix + "_add", c.getLocal("p1"), AUX, c.getLocal("pr")),
        );
    }

    function buildSubMixed() {
        const f = module.addFunction(prefix + "_subMixed");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const AUX = c.i32_const(module.alloc(n8*3));

        f.addCode(
            c.call(prefix + "_negAffine", c.getLocal("p2"), AUX),
            c.call(prefix + "_addMixed", c.getLocal("p1"), AUX, c.getLocal("pr")),
        );
    }


    function buildSubAffine() {
        const f = module.addFunction(prefix + "_subAffine");
        f.addParam("p1", "i32");
        f.addParam("p2", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const AUX = c.i32_const(module.alloc(n8*3));

        f.addCode(
            c.call(prefix + "_negAffine", c.getLocal("p2"), AUX),
            c.call(prefix + "_addAffine", c.getLocal("p1"), AUX, c.getLocal("pr")),
        );
    }

    // This sets Z to One
    function buildNormalize() {
        const f = module.addFunction(prefix + "_normalize");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8*2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));
        const z3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8*2));


        const Z_inv = c.i32_const(module.alloc(n8));
        const Z2_inv = c.i32_const(module.alloc(n8));
        const Z3_inv = c.i32_const(module.alloc(n8));

        f.addCode(
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p1")),
                c.call(prefix + "_zero", c.getLocal("pr")),
                [
                    ...c.call(prefixField + "_inverse", z, Z_inv),
                    ...c.call(prefixField + "_square", Z_inv, Z2_inv),
                    ...c.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
                    ...c.call(prefixField + "_mul", x, Z2_inv, x3),
                    ...c.call(prefixField + "_mul", y, Z3_inv, y3),
                    ...c.call(prefixField + "_one", z3),
                ]
            )
        );
    }


    // Does not set Z.
    function buildToAffine() {
        const f = module.addFunction(prefix + "_toAffine");
        f.addParam("p1", "i32");
        f.addParam("pr", "i32");

        const c = f.getCodeBuilder();

        const x = c.getLocal("p1");
        const y = c.i32_add(c.getLocal("p1"), c.i32_const(n8));
        const z = c.i32_add(c.getLocal("p1"), c.i32_const(n8*2));
        const x3 = c.getLocal("pr");
        const y3 = c.i32_add(c.getLocal("pr"), c.i32_const(n8));


        const Z_inv = c.i32_const(module.alloc(n8));
        const Z2_inv = c.i32_const(module.alloc(n8));
        const Z3_inv = c.i32_const(module.alloc(n8));

        f.addCode(
            c.if(
                c.call(prefix + "_isZero", c.getLocal("p1")),
                [
                    ...c.call(prefixField + "_zero", x3),
                    ...c.call(prefixField + "_zero", y3),
                ],
                [
                    ...c.call(prefixField + "_inverse", z, Z_inv),
                    ...c.call(prefixField + "_square", Z_inv, Z2_inv),
                    ...c.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
                    ...c.call(prefixField + "_mul", x, Z2_inv, x3),
                    ...c.call(prefixField + "_mul", y, Z3_inv, y3),
                ]
            )
        );
    }


    function buildToJacobian() {
