                    c.i32_eq(
                        c.getLocal("it"),
                        c.getLocal("last")
                    )
                ),
                c.setLocal(
                    "s",
                    c.i32_load(c.getLocal("it"), 8)
                ),
                c.if(
                    c.i32_or(
                        c.i32_lt_u(
                            c.getLocal("s"),
                            c.getLocal("offsetWitness"),
                        ),
                        c.i32_ge_u(
                            c.getLocal("s"),
                            c.i32_add(
                                c.getLocal("offsetWitness"),
                                c.getLocal("nWitness"),
                            )
                        )
                    ),
                    [
                        ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8+12))),
                        ...c.br(1)
                    ]
                ),

                c.setLocal(
                    "m",
                    c.i32_load(c.getLocal("it"))
                ),
                c.if(
                    c.i32_eq(c.getLocal("m"), c.i32_const(0)),
                    c.setLocal("pOut", c.getLocal("pA")),
                    c.if(
                        c.i32_eq(c.getLocal("m"), c.i32_const(1)),
                        c.setLocal("pOut", c.getLocal("pB")),
                        [
                            ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8+12))),
                            ...c.br(1)
                        ]
                    )
                ),
                c.setLocal(
                    "c",
                    c.i32_load(c.getLocal("it"), 4)
                ),
                c.if(
                    c.i32_or(
                        c.i32_lt_u(
                            c.getLocal("c"),
                            c.getLocal("offsetOut"),
                        ),
                        c.i32_ge_u(
                            c.getLocal("c"),
                            c.i32_add(
                                c.getLocal("offsetOut"),
                                c.getLocal("nOut"),
                            )
                        )
                    ),
                    [
                        ...c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8+12))),
                        ...c.br(1)
                    ]
                ),
                c.setLocal(
                    "pOut",
                    c.i32_add(
                        c.getLocal("pOut"),
                        c.i32_mul(
                            c.i32_sub(
                                c.getLocal("c"),
                                c.getLocal("offsetOut")
                            ),
                            c.i32_const(n8)
                        )
                    )
                ),
                c.call(
                    prefixField + "_mul",
                    c.i32_add(
                        c.getLocal("pWitness"),
                        c.i32_mul(
                            c.i32_sub(c.getLocal("s"), c.getLocal("offsetWitness")),
                            c.i32_const(n8)
                        )
                    ),
                    c.i32_add( c.getLocal("it"), c.i32_const(12)),
                    aux
                ),
                c.call(
                    prefixField + "_add",
                    c.getLocal("pOut"),
                    aux,
                    c.getLocal("pOut"),
                ),
                c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8+12))),
                c.br(0)
            )),

            c.setLocal("ita", c.getLocal("pA")),
            c.setLocal("itb", c.getLocal("pB")),
            c.setLocal("it", c.getLocal("pC")),
            c.setLocal(
                "last",
                c.i32_add(
                    c.getLocal("pA"),
                    c.i32_mul(
                        c.getLocal("nOut"),
                        c.i32_const(n8)
                    )
                )
            ),
            c.block(c.loop(
                c.br_if(
                    1,
                    c.i32_eq(
                        c.getLocal("ita"),
                        c.getLocal("last")
                    )
                ),
                c.call(
                    prefixField + "_mul",
                    c.getLocal("ita"),
                    c.getLocal("itb"),
                    c.getLocal("it")
                ),
                c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
                c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
                c.setLocal("it", c.i32_add(c.getLocal("it"), c.i32_const(n8))),
                c.br(0)
            )),

        );
    }

    function buildJoinABC() {
        const f = module.addFunction(prefix+"_joinABC");
        f.addParam("pA", "i32");
        f.addParam("pB", "i32");
        f.addParam("pC", "i32");
        f.addParam("n", "i32");
        f.addParam("pP", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("itc", "i32");
        f.addLocal("itp", "i32");
        f.addLocal("last", "i32");

        const c = f.getCodeBuilder();

        const aux = c.i32_const(module.alloc(n8));

        f.addCode(
            c.setLocal("ita", c.getLocal("pA")),
            c.setLocal("itb", c.getLocal("pB")),
            c.setLocal("itc", c.getLocal("pC")),
            c.setLocal("itp", c.getLocal("pP")),
            c.setLocal(
                "last",
                c.i32_add(
                    c.getLocal("pA"),
                    c.i32_mul(
                        c.getLocal("n"),
                        c.i32_const(n8)
                    )
                )
            ),
            c.block(c.loop(
                c.br_if(
                    1,
                    c.i32_eq(
                        c.getLocal("ita"),
                        c.getLocal("last")
                    )
                ),
                c.call(
                    prefixField + "_mul",
                    c.getLocal("ita"),
                    c.getLocal("itb"),
                    aux
                ),
                c.call(
                    prefixField + "_sub",
                    aux,
                    c.getLocal("itc"),
                    c.getLocal("itp"),
                ),
                c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
                c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
                c.setLocal("itc", c.i32_add(c.getLocal("itc"), c.i32_const(n8))),
                c.setLocal("itp", c.i32_add(c.getLocal("itp"), c.i32_const(n8))),
                c.br(0)
            ))
        );
    }

    function buildBatchAdd() {
        const f = module.addFunction(prefix+"_batchAdd");
        f.addParam("pa", "i32");
        f.addParam("pb", "i32");
        f.addParam("n", "i32");
        f.addParam("pr", "i32");
        f.addLocal("ita", "i32");
        f.addLocal("itb", "i32");
        f.addLocal("itr", "i32");
        f.addLocal("last", "i32");

        const c = f.getCodeBuilder();

        f.addCode(
            c.setLocal("ita", c.getLocal("pa")),
            c.setLocal("itb", c.getLocal("pb")),
            c.setLocal("itr", c.getLocal("pr")),
            c.setLocal(
                "last",
                c.i32_add(
                    c.getLocal("pa"),
                    c.i32_mul(
                        c.getLocal("n"),
                        c.i32_const(n8)
                    )
                )
            ),
            c.block(c.loop(
                c.br_if(
                    1,
                    c.i32_eq(
                        c.getLocal("ita"),
                        c.getLocal("last")
                    )
                ),
                c.call(
                    prefixField + "_add",
                    c.getLocal("ita"),
                    c.getLocal("itb"),
                    c.getLocal("itr"),
                ),
                c.setLocal("ita", c.i32_add(c.getLocal("ita"), c.i32_const(n8))),
                c.setLocal("itb", c.i32_add(c.getLocal("itb"), c.i32_const(n8))),
                c.setLocal("itr", c.i32_add(c.getLocal("itr"), c.i32_const(n8))),
                c.br(0)
            ))
        );
    }

    buildBuildABC();
    buildJoinABC();
    buildBatchAdd();

    module.exportFunction(prefix + "_buildABC");
    module.exportFunction(prefix + "_joinABC");
    module.exportFunction(prefix + "_batchAdd");

    return prefix;

};




---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_test.js
---


function buildTest1(module, fn) {
    const f = module.addFunction("test_"+fn);
    f.addParam("x", "i32");
    f.addParam("r", "i32");
    f.addParam("n", "i32");
    f.addLocal("i", "i32");

    const c = f.getCodeBuilder();

    f.addCode(c.setLocal("i", c.getLocal("n")));
    f.addCode(c.block(c.loop(
        c.call(fn, c.getLocal("x"),  c.getLocal("r")),
        c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
        c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
        c.br(0)
    )));

    module.exportFunction("test_"+fn);
}

function buildTest2(module, fn) {
    const f = module.addFunction("test_"+fn);
    f.addParam("x", "i32");
    f.addParam("y", "i32");
    f.addParam("r", "i32");
    f.addParam("n", "i32");
    f.addLocal("i", "i32");

    const c = f.getCodeBuilder();

    f.addCode(c.setLocal("i", c.getLocal("n")));
    f.addCode(c.block(c.loop(
        c.call(fn, c.getLocal("x"),  c.getLocal("y"),  c.getLocal("r")),
        c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
        c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
        c.br(0)
    )));

    module.exportFunction("test_"+fn);
}

module.exports.buildTest1 = buildTest1;
module.exports.buildTest2 = buildTest2;



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_testf1.js
---

/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/

module.exports = function buildTestF1(module) {

    const pR2 = module.modules.f1m.pR2;
    const n8 = module.modules.f1m.n64*8;


    function buildTestF1() {
        const f = module.addFunction("testF1");
        f.addParam("n", "i32");
        f.addLocal("i", "i32");

        const c = f.getCodeBuilder();

        const pAux1 = module.alloc(n8);

        f.addCode(c.setLocal("i", c.getLocal("n")));
        f.addCode(c.block(c.loop(
            c.call("f1m_mul", c.i32_const(pR2), c.i32_const(pR2), c.i32_const(pAux1)),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
            c.br(0)
        )));
    }

    buildTestF1();
    module.exportFunction("testF1");
};



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_testg1.js
---

/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/

module.exports = function buildTestAddG1(module) {

    function buildTestAddG1() {
        const f = module.addFunction("testAddG1");
        f.addParam("n", "i32");
        f.addParam("pP", "i32");
        f.addParam("pR", "i32");
        f.addLocal("i", "i32");

        const c = f.getCodeBuilder();

        f.addCode(c.call("g1_zero", c.getLocal("pR")));

        f.addCode(c.setLocal("i", c.getLocal("n")));
        f.addCode(c.block(c.loop(
            c.call("g1_add", c.getLocal("pP"), c.getLocal("pR"), c.getLocal("pR")),
            c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),
            c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
            c.br(0)
        )));
    }

    buildTestAddG1();
    module.exportFunction("testAddG1");
};




---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_timesscalar.js
---

/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/

module.exports = function buildTimesScalar(module, fnName, elementLen, opAB, opAA, opCopy, opInit) {

    const f = module.addFunction(fnName);
    f.addParam("base", "i32");
    f.addParam("scalar", "i32");
    f.addParam("scalarLength", "i32");
    f.addParam("r", "i32");
    f.addLocal("i", "i32");
    f.addLocal("b", "i32");

    const c = f.getCodeBuilder();

    const aux = c.i32_const(module.alloc(elementLen));

    f.addCode(
        c.if(
            c.i32_eqz(c.getLocal("scalarLength")),
            [
                ...c.call(opInit, c.getLocal("r")),
                ...c.ret([])
            ]
        )
    );
    f.addCode(c.call(opCopy, c.getLocal("base"), aux));
    f.addCode(c.call(opInit, c.getLocal("r")));
    f.addCode(c.setLocal("i", c.getLocal("scalarLength")));
    f.addCode(c.block(c.loop(
        c.setLocal("i", c.i32_sub(c.getLocal("i"), c.i32_const(1))),

        c.setLocal(
            "b",
            c.i32_load8_u(
                c.i32_add(
                    c.getLocal("scalar"),
                    c.getLocal("i")
                )
            )
        ),
        ...innerLoop(),
        c.br_if(1, c.i32_eqz ( c.getLocal("i") )),
        c.br(0)
    )));


    function innerLoop() {
        const code = [];
        for (let i=0; i<8; i++) {
            code.push(
                ...c.call(opAA, c.getLocal("r"), c.getLocal("r")),
                ...c.if(
                    c.i32_ge_u( c.getLocal("b"), c.i32_const(0x80 >> i)),
                    [
                        ...c.setLocal(
                            "b",
                            c.i32_sub(
                                c.getLocal("b"),
                                c.i32_const(0x80 >> i)
                            )
                        ),
                        ...c.call(opAB, c.getLocal("r"),aux, c.getLocal("r"))
                    ]
                )
            );
        }
        return code;
    }

};



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_timesscalarnaf.js
---

/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/

module.exports = function buildTimesScalarNAF(module, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {

    const f = module.addFunction(fnName);
    f.addParam("base", "i32");
    f.addParam("scalar", "i32");
    f.addParam("scalarLength", "i32");
    f.addParam("r", "i32");
    f.addLocal("old0", "i32");
    f.addLocal("nbits", "i32");
    f.addLocal("i", "i32");
    f.addLocal("last", "i32");
    f.addLocal("cur", "i32");
    f.addLocal("carry", "i32");
    f.addLocal("p", "i32");

    const c = f.getCodeBuilder();

    const aux = c.i32_const(module.alloc(elementLen));

    function getBit(IDX) {
        return c.i32_and(
            c.i32_shr_u(
                c.i32_load(
                    c.i32_add(
                        c.getLocal("scalar"),
                        c.i32_and(
                            c.i32_shr_u(
                                IDX,
                                c.i32_const(3)
                            ),
                            c.i32_const(0xFFFFFFFC)
                        )
                    )
                ),
                c.i32_and(
                    IDX,
                    c.i32_const(0x1F)
                )
            ),
            c.i32_const(1)
        );
    }

    function pushBit(b) {
        return [
            ...c.i32_store8(
                c.getLocal("p"),
                c.i32_const(b)
            ),
            ...c.setLocal(
                "p",
                c.i32_add(
                    c.getLocal("p"),
                    c.i32_const(1)
                )
            )
        ];
    }

    f.addCode(
        c.if(
            c.i32_eqz(c.getLocal("scalarLength")),
            [
                ...c.call(opInit, c.getLocal("r")),
                ...c.ret([])
            ]
        ),
        c.setLocal("nbits", c.i32_shl(c.getLocal("scalarLength"), c.i32_const(3))),
        c.setLocal("old0", c.i32_load(c.i32_const(0))),
        c.setLocal("p", c.getLocal("old0")),
        c.i32_store(
            c.i32_const(0),
            c.i32_and(
                c.i32_add(
                    c.i32_add(
                        c.getLocal("old0"),
                        c.i32_const(32)
                    ),
                    c.getLocal("nbits")
                ),
                c.i32_const(0xFFFFFFF8)
            )
        ),
        c.setLocal("i", c.i32_const(1)),

        c.setLocal("last",getBit(c.i32_const(0))),
        c.setLocal("carry",c.i32_const(0)),

        c.block(c.loop(
            c.br_if(1, c.i32_eq( c.getLocal("i"), c.getLocal("nbits"))),

            c.setLocal("cur", getBit(c.getLocal("i"))),
            c.if( c.getLocal("last"),
                c.if( c.getLocal("cur"),
                    c.if(c.getLocal("carry"),
                        [
                            ...c.setLocal("last", c.i32_const(0)),
                            ...c.setLocal("carry", c.i32_const(1)),
                            ...pushBit(1)
                        ]
                        ,
                        [
                            ...c.setLocal("last", c.i32_const(0)),
                            ...c.setLocal("carry", c.i32_const(1)),
                            ...pushBit(255)
                        ],
                    ),
                    c.if(c.getLocal("carry"),
                        [
                            ...c.setLocal("last", c.i32_const(0)),
                            ...c.setLocal("carry", c.i32_const(1)),
                            ...pushBit(255)
                        ]
                        ,
                        [
                            ...c.setLocal("last", c.i32_const(0)),
                            ...c.setLocal("carry", c.i32_const(0)),
                            ...pushBit(1)
                        ],
                    ),
                ),
                c.if( c.getLocal("cur"),
                    c.if(c.getLocal("carry"),
                        [
                            ...c.setLocal("last", c.i32_const(0)),
                            ...c.setLocal("carry", c.i32_const(1)),
                            ...pushBit(0)
                        ]
                        ,
                        [
                            ...c.setLocal("last", c.i32_const(1)),
                            ...c.setLocal("carry", c.i32_const(0)),
                            ...pushBit(0)
                        ],
                    ),
                    c.if(c.getLocal("carry"),
                        [
                            ...c.setLocal("last", c.i32_const(1)),
                            ...c.setLocal("carry", c.i32_const(0)),
                            ...pushBit(0)
                        ]
                        ,
                        [
                            ...c.setLocal("last", c.i32_const(0)),
                            ...c.setLocal("carry", c.i32_const(0)),
                            ...pushBit(0)
                        ],
                    ),
                )
            ),
            c.setLocal("i", c.i32_add(c.getLocal("i"), c.i32_const(1))),
            c.br(0)
        )),

        c.if( c.getLocal("last"),
            c.if(c.getLocal("carry"),
                [
                    ...pushBit(255),
                    ...pushBit(0),
                    ...pushBit(1)
                ]
                ,
                [
                    ...pushBit(1)
                ],
            ),
            c.if(c.getLocal("carry"),
                [
                    ...pushBit(0),
                    ...pushBit(1)
                ]
            ),
        ),

        c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),

        // p already points to the last bit

        c.call(opCopy, c.getLocal("base"), aux),

        c.call(opInit, c.getLocal("r")),

        c.block(c.loop(


            c.call(opAA, c.getLocal("r"), c.getLocal("r")),


            c.setLocal("cur",
                c.i32_load8_u(
                    c.getLocal("p")
                )
            ),

            c.if(
                c.getLocal("cur"),
                c.if(
                    c.i32_eq(c.getLocal("cur"), c.i32_const(1)),
                    c.call(opAB,  c.getLocal("r"), aux, c.getLocal("r")),
                    c.call(opAmB, c.getLocal("r"), aux, c.getLocal("r")),
                )
            ),

            c.br_if(1, c.i32_eq( c.getLocal("old0"), c.getLocal("p"))),
            c.setLocal("p", c.i32_sub(c.getLocal("p"), c.i32_const(1))),
            c.br(0)

        )),

        c.i32_store( c.i32_const(0), c.getLocal("old0"))

    );

};



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/build_tomcook.js
---

const assert = require("assert");

module.exports = function buildTomCook(module, _prefix) {

    const prefix = _prefix || "tomcook";
    const definedFunctions = {};

    const CHUNK_BITS = 29;
    const CHUNK_BASE = 1 << CHUNK_BITS;
    const CHUNK_BASE_MAX = "9223372036317904896";

    function load(size, c, localVar, pos) {
        if (size == "l") {
            return c.i64_load(c.getLocal(localVar), pos*8);
        } else if (size=="s") {
            return c.i64_load32_s(c.getLocal(localVar), pos*4);
        } else {
            assert(false, "invalid size: "+size);
        }
    }

    function store(size, c, localVar, pos, value) {
        if (size == "l") {
            return c.i64_store(c.getLocal(localVar), pos*8, value);
        } else if (size == "s") {
            return c.i64_store32(c.getLocal(localVar), pos*4, value);
        } else {
            assert(false, "invalid size: "+size);
        }
    }

    function storeAdjusting(size, c, carryVar, dstVar, auxVar, pos) {
        return c.if(
            c.i64_lt_s(
                c.getLocal(carryVar),
                c.i64_const(0)
            ),
            [
                ...c.setLocal(auxVar,
                    c.i64_rem_s(
                        c.i64_add(
                            c.i64_const(CHUNK_BASE_MAX),
                            c.getLocal(carryVar)
                        ),
                        c.i64_const(CHUNK_BASE)
                    )
                ),
                ...store(size, c, dstVar, pos, c.getLocal(auxVar)),
                ...c.setLocal(carryVar,
                    c.i64_sub(
                        c.getLocal(carryVar),
                        c.getLocal(auxVar)
                    )
                )
            ]
            ,  // elsif
            [
                ...store(size, c, dstVar, pos,
                    c.i64_rem_s(
                        c.getLocal(carryVar),
                        c.i64_const(CHUNK_BASE)
                    )
                ),
            ]
        );
    }

    function buildMul3(sizes) {
        const fnName = prefix+"_mul3"+sizes;
        if (definedFunctions[fnName]) return;
        definedFunctions[fnName] = true;

        const f = module.addFunction(fnName);
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");

        f.addLocal("a0", "i64");
        f.addLocal("a1", "i64");
        f.addLocal("a2", "i64");
        f.addLocal("b0", "i64");
        f.addLocal("b1", "i64");
        f.addLocal("b2", "i64");

        f.addLocal("c", "i64");

        const c = f.getCodeBuilder();

        f.addCode(
            // calculate p

            c.setLocal("a0", load(sizes[0], c, "x", 0)),
            c.setLocal("b0", load(sizes[1], c, "y", 0)),

            c.setLocal("c", c.i64_mul( c.getLocal("a0"), c.getLocal("b0") )),

            store(sizes[2], c, "r", 0,
                c.i64_rem_s( c.getLocal("c"), c.i64_const(CHUNK_BASE))
            ),

            c.setLocal("a1", load(sizes[0], c, "x", 1)),
            c.setLocal("b1", load(sizes[1], c, "y", 1)),

            c.setLocal("c", c.i64_add(
                c.i64_div_s( c.getLocal("c"), c.i64_const(CHUNK_BASE)),
                c.i64_add(
                    c.i64_mul( c.getLocal("a0"), c.getLocal("b1") ),
                    c.i64_mul( c.getLocal("a1"), c.getLocal("b0") )
                )
            )),
            store(sizes[2], c, "r", 1,
                c.i64_rem_s( c.getLocal("c"), c.i64_const(CHUNK_BASE))
            ),

            c.setLocal("a2", load(sizes[0], c, "x", 2)),
            c.setLocal("b2", load(sizes[1], c, "y", 2)),

            c.setLocal("c", c.i64_add(
                c.i64_add(
                    c.i64_mul( c.getLocal("a0"), c.getLocal("b2") ),
                    c.i64_mul( c.getLocal("a2"), c.getLocal("b0") )
                ),
                c.i64_add(
                    c.i64_div_s( c.getLocal("c"), c.i64_const(CHUNK_BASE)),
                    c.i64_mul( c.getLocal("a1"), c.getLocal("b1") ),
                )
            )),
            store(sizes[2], c, "r", 2,
                c.i64_rem_s( c.getLocal("c"), c.i64_const(CHUNK_BASE))
            ),

            c.setLocal("c", c.i64_add(
                c.i64_add(
                    c.i64_div_s( c.getLocal("c"), c.i64_const(CHUNK_BASE)),
                    c.i64_mul( c.getLocal("a1"), c.getLocal("b2"))
                ),
                c.i64_mul( c.getLocal("a2"), c.getLocal("b1") ),
            )),
            store(sizes[2], c, "r", 3,
                c.i64_rem_s( c.getLocal("c"), c.i64_const(CHUNK_BASE))
            ),

            c.setLocal("c", c.i64_add(
                c.i64_mul( c.getLocal("a2"), c.getLocal("b2") ),
                c.i64_div_s( c.getLocal("c"), c.i64_const(CHUNK_BASE)),
            )),
            store(sizes[2], c, "r", 4,
                c.i64_rem_s( c.getLocal("c"), c.i64_const(CHUNK_BASE))
            ),

            store(sizes[2], c, "r", 5,
                c.i64_div_s( c.getLocal("c"), c.i64_const(CHUNK_BASE)),
            ),
        );
    }

    function buildAdd(n, sizes) {

        const fnName = prefix+"_add"+n+sizes;
        if (definedFunctions[fnName]) return;
        definedFunctions[fnName] = true;


        const f = module.addFunction(fnName);
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        for (let i=0; i<n; i++) {
            f.addCode(
                store(sizes[2], c, "r", i,
                    c.i64_add(
                        load(sizes[0], c, "x", i),
                        load(sizes[1], c, "y", i)
                    )
                )
            );
        }
    }


    function buildSub(n, sizes) {
        const fnName = prefix+"_sub"+n+sizes;
        if (definedFunctions[fnName]) return;
        definedFunctions[fnName] = true;

        const f = module.addFunction(fnName);
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");

        const c = f.getCodeBuilder();

        for (let i=0; i<n; i++) {
            f.addCode(
                store(sizes[2], c, "r", i,
                    c.i64_sub(
                        load(sizes[0], c, "x", i),
                        load(sizes[1], c, "y", i)
                    )
                )
            );
        }
    }


    function buildMulShort(n, sizes) {
        const fnName = prefix+"_mulshort"+n+sizes;
        if (definedFunctions[fnName]) return;
        definedFunctions[fnName] = true;


        const f = module.addFunction(fnName);
        f.addParam("x", "i32");
        f.addParam("s", "i32");
        f.addParam("r", "i32");

        f.addLocal("s64", "i64");

        const c = f.getCodeBuilder();

        f.addCode(c.setLocal("s64", c.i64_extend_i32_s(c.getLocal("s"))));
        for (let i=0; i<n; i++) {
            f.addCode(
                store(sizes[1], c, "r", i,
                    c.i64_mul(
                        load(sizes[0], c, "x", i),
                        c.getLocal("s64")
                    )
                )
            );
        }
    }

    function buildDivShort(n, sizes) {
        const fnName = prefix+"_divshort"+n+sizes;
        if (definedFunctions[fnName]) return;
        definedFunctions[fnName] = true;

        const f = module.addFunction(fnName);
        f.addParam("x", "i32");
        f.addParam("s", "i32");
        f.addParam("r", "i32");

        f.addLocal("c", "i64");
        f.addLocal("s64", "i64");

        const c = f.getCodeBuilder();

        f.addCode(
            c.setLocal("s64", c.i64_extend_i32_s(c.getLocal("s"))),
            c.setLocal("c", load(sizes[0], c, "x", n-1)),
            store(sizes[1], c, "r", n-1,
                c.i64_div_s(
                    c.getLocal("c"),
                    c.getLocal("s64")
                )
            )
        );

        for (let i=n-2; i>=0; i--) {
            f.addCode(
                c.setLocal("c",
                    c.i64_add(
                        c.i64_mul(
                            c.i64_rem_s(
                                c.getLocal("c"),
                                c.getLocal("s64")
                            ),
                            c.i64_const(CHUNK_BASE)
                        ),
                        load(sizes[0], c, "x", i)
                    )
                ),

                store(sizes[1], c, "r", i,
                    c.i64_div_s(
                        c.getLocal("c"),
                        c.getLocal("s64")
                    )
                )
            );
        }
    }


    function buildRecompose(n, sizes) {

        const fnName = prefix+"_recompose"+n+sizes;
        if (definedFunctions[fnName]) return;
        definedFunctions[fnName] = true;

        const sn = n/3;
        const f = module.addFunction(fnName);
        f.addParam("s", "i32");
        f.addParam("r", "i32");

        f.addLocal("c", "i64");
        f.addLocal("aux", "i64");

        const c = f.getCodeBuilder();

        /*
            0     sn        sn*2   sn*3   sn*4   sn*5
            0     sn
                  sn*2      sn*3
                            sn*4   sn*5
                                   sn+6   sn*7
                                          sn*8   sn*9


            b= Math.floor(i/sn)

            b*2*sn  + (i-b*sn)
            b*2*sn  + (i-b*sn) - sn
        */

        f.addCode(c.setLocal("c", c.i64_const(0)));

        for (let i=0; i<sn; i++) {
            f.addCode(
                c.setLocal(
                    "c",
                    c.i64_add(
                        c.i64_div_s(c.getLocal("c"), c.i64_const(CHUNK_BASE)),
                        load("l", c, "s", i)
                    )
                ),

                storeAdjusting(sizes[0], c, "c", "r", "aux", i)
            );
        }


        for (let i=sn; i<sn*5; i++) {

            const b= Math.floor(i/sn);
            const i1 = b*2*sn  + (i-b*sn);
            const i2 = i1 - sn;

            f.addCode(
                c.setLocal(
                    "c",
                    c.i64_add(
                        c.i64_div_s(c.getLocal("c"), c.i64_const(CHUNK_BASE)),
                        c.i64_add(
                            load("l", c, "s", i1),
                            load("l", c, "s", i2)
                        )
                    )
                )
            );

            f.addCode(
                storeAdjusting(sizes[0], c, "c", "r", "aux", i)
            );
        }


        for (let i=sn*5; i<n*2; i++) {

            const b= Math.floor(i/sn);
            const i1 = b*2*sn  + (i-b*sn);
            const i2 = i1 - sn;

            f.addCode(
                c.setLocal(
                    "c",
                    c.i64_add(
                        c.i64_div_s(c.getLocal("c"), c.i64_const(CHUNK_BASE)),
                        load("l", c, "s", i2)
                    )
                ),

                storeAdjusting(sizes[0], c, "c", "r", "aux", i)
            );
        }
    }

    function buildMul(n, sizes) {

        if (n==3) {
            return buildMul3(sizes);
        }

        const fnName = prefix+"_mul"+n+sizes;
        if (definedFunctions[fnName]) return;
        definedFunctions[fnName] = true;

        const sn = n/3;
        const sn2 = sn*2;

        buildAdd(sn, sizes[0]+sizes[0]+"l");
        buildAdd(sn, "l"+sizes[0]+"l");
        buildSub(sn, "l"+sizes[0]+"l");
        buildAdd(sn, sizes[1]+sizes[1]+"l");
        buildAdd(sn, "l"+sizes[1]+"l");
        buildSub(sn, "l"+sizes[1]+"l");
        buildMulShort(sn, "ll");
        buildMul(sn, "lll");
        buildMul(sn, sizes[0]+sizes[1]+"l");

        buildMulShort(sn2, "ll");
        buildDivShort(sn2, "ll");
        buildAdd(sn2, "lll");
        buildSub(sn2, "lll");
        buildRecompose(n, sizes[2]);


        const f = module.addFunction(fnName);
        f.addParam("x", "i32");
        f.addParam("y", "i32");
        f.addParam("r", "i32");

        f.addLocal("m1", "i32");
        f.addLocal("m2", "i32");

        f.addLocal("n1", "i32");
        f.addLocal("n2", "i32");


        const c = f.getCodeBuilder();

        const ws0 = sizes[0] == "s" ? 4 : 8;
        const ws1 = sizes[1] == "s" ? 4 : 8;
        const wsi = 8;

        const m0 = c.getLocal("x");
        f.addCode(c.setLocal("m1", c.i32_add( c.getLocal("x"), c.i32_const(sn*ws0) )));
        const m1 = c.getLocal("m1");
        f.addCode(c.setLocal("m2", c.i32_add( c.getLocal("x"), c.i32_const((sn*2)*ws0 ))));
        const m2 = c.getLocal("m2");

        const n0 = c.getLocal("y");
        f.addCode(c.setLocal("n1", c.i32_add( c.getLocal("y"), c.i32_const(sn*ws1) )));
        const n1 = c.getLocal("n1");
        f.addCode(c.setLocal("n2", c.i32_add( c.getLocal("y"), c.i32_const((sn*2)*ws1 ))));
        const n2 = c.getLocal("n2");

        const po = c.i32_const(module.alloc(sn*wsi));
        f.addCode(c.call(prefix + "_add" + sn + sizes[0]+sizes[0]+"l", m0, m2, po));
        const p0 = m0;
        const p1 = c.i32_const(module.alloc(sn*wsi));
        f.addCode(c.call(prefix + "_add" + sn + "l"+sizes[0]+"l", po, m1, p1));
        const pn1 = c.i32_const(module.alloc(sn*wsi));
        f.addCode(c.call(prefix + "_sub" + sn + "l"+sizes[0]+"l", po, m1, pn1));
        const pn2 = c.i32_const(module.alloc(sn*wsi));
        f.addCode(
            c.call(prefix + "_add" + sn + "l"+sizes[0]+"l", pn1, m2, pn2),
            c.call(prefix + "_mulshort" + sn + "ll", pn2, c.i32_const(2), pn2),
            c.call(prefix + "_sub" + sn + "l"+sizes[0]+"l", pn2, m0, pn2)
        );
        const pi = m2;

        const qo = c.i32_const(module.alloc(sn*wsi));
        f.addCode(c.call(prefix + "_add" + sn + sizes[1]+sizes[1]+"l", n0, n2, qo));
        const q0 = n0;
        const q1 = c.i32_const(module.alloc(sn*wsi));
        f.addCode(c.call(prefix + "_add" + sn + "l"+sizes[1]+"l", qo, n1, q1));
        const qn1 = c.i32_const(module.alloc(sn*wsi));
        f.addCode(c.call(prefix + "_sub" + sn + "l"+sizes[1]+"l", qo, n1, qn1));
        const qn2 = c.i32_const(module.alloc(sn*wsi));
        f.addCode(
            c.call(prefix + "_add" + sn + "l"+sizes[1]+"l", qn1, n2, qn2),
            c.call(prefix + "_mulshort" + sn +"ll", qn2, c.i32_const(2), qn2),
            c.call(prefix + "_sub" + sn + "l"+sizes[1]+"l", qn2, n0, qn2)
        );
        const qi = n2;

        const ps0 = module.alloc(sn*2*5*wsi);
        const s0 = c.i32_const(ps0);
        const s1 = c.i32_const(ps0 + (2*sn)*wsi);
        const s2 = c.i32_const(ps0 + (4*sn)*wsi);
        const s3 = c.i32_const(ps0 + (6*sn)*wsi);
        const s4 = c.i32_const(ps0 + (8*sn)*wsi);

        const r0 = s0;
        const r1 = c.i32_const(module.alloc(sn*2*wsi));
        const rn1 = c.i32_const(module.alloc(sn*2*wsi));
        const rn2 = c.i32_const(module.alloc(sn*2*wsi));
        const ri = s4;

        f.addCode(c.call(prefix + "_mul" + sn + sizes[0]+sizes[1]+"l", p0, q0, r0));
        f.addCode(c.call(prefix + "_mul" + sn + "lll" , p1, q1, r1));
        f.addCode(c.call(prefix + "_mul" + sn + "lll" , pn1, qn1, rn1));
        f.addCode(c.call(prefix + "_mul" + sn + "lll" , pn2, qn2, rn2));
        f.addCode(c.call(prefix + "_mul" + sn + sizes[0]+sizes[1]+"l", pi, qi, ri));

        const aux = c.i32_const(module.alloc(sn*wsi));

        f.addCode(

            // s3 = (r(-2) - r(1))/3
            c.call(prefix + "_sub" + sn2 + "lll", rn2, r1, s3),
            c.call(prefix + "_divshort" + sn2 + "ll", s3, c.i32_const(3), s3),

            // s1 = (r(1) - r(-1))/2
            c.call(prefix + "_sub" + sn2 + "lll", r1, rn1, s1),
            c.call(prefix + "_divshort" + sn2 + "ll", s1, c.i32_const(2), s1),

            // s2 = r(-1) - r(0)
            c.call(prefix + "_sub" + sn2 + "lll", rn1, r0, s2),

            // s3 = (s2-s3)/2 + r(inf)*2
            c.call(prefix + "_sub" + sn2 + "lll", s2, s3, s3),
            c.call(prefix + "_divshort" + sn2 + "ll", s3, c.i32_const(2), s3),
            c.call(prefix + "_mulshort" + sn2 + "ll", ri, c.i32_const(2), aux),
            c.call(prefix + "_add" + sn2 + "lll", s3, aux, s3),

            // s2 = s2 + s1 - s4
            c.call(prefix + "_add" + sn2 + "lll", s2, s1, s2),
            c.call(prefix + "_sub" + sn2 + "lll", s2, s4, s2),

            // s1 = s1 - s3
            c.call(prefix + "_sub" + sn2 + "lll", s1, s3, s1),
        );

        f.addCode(c.call(prefix + "_recompose"+ n + sizes[2], s0, c.getLocal("r")));

    }


    buildMul(9, "sss");
    module.exportFunction(prefix+"_mul9sss", prefix+"_mul9");

    buildDivShort(6, "ss");
    module.exportFunction(prefix+"_divshort6ss", prefix+"_divshort6");

    buildMulShort(6, "ss");
    module.exportFunction(prefix+"_mulshort6ss", prefix+"_mulshort6");

    buildMul(3, "sss");
    module.exportFunction(prefix+"_mul3sss", prefix+"_mul3");

};



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/f1.js
---

/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/

const ModuleBuilder = require("wasmbuilder").ModuleBuilder;
const buildF1 = require("./build_f1.js");
const buildTestF1 = require("./build_testf1.js");
const { bitLength } = require("./bigint.js");

async function build(q) {
    const f1 = new F1(q);

    f1.q = BigInt(q);
    f1.n64 = Math.floor((bitLength(f1.q - 1n) - 1)/64) +1;
    f1.n32 = f1.n64*2;
    f1.n8 = f1.n64*8;

    f1.memory = new WebAssembly.Memory({initial:1});
    f1.i32 = new Uint32Array(f1.memory.buffer);

    const moduleBuilder = new ModuleBuilder();
    buildF1(moduleBuilder, f1.q);
    buildTestF1(moduleBuilder);

    const code = moduleBuilder.build();

    const wasmModule = await WebAssembly.compile(code);

    f1.instance = await WebAssembly.instantiate(wasmModule, {
        env: {
            "memory": f1.memory
        }
    });

    Object.assign(f1, f1.instance.exports);

    return f1;
}

class F1 {

    constructor() {

    }

    alloc(length) {
        const res = this.i32[0];
        this.i32[0] += length;
        return res;
    }

    putInt(pos, _a) {
        const a = BigInt(_a);
        if (pos & 0x7) throw new Error("Pointer must be aligned");
        if (bitLength(a) > this.n64*64) {
            return this.putInt(a % this.q);
        }
        for (let i=0; i<this.n32; i++) {
            this.i32[(pos>>2)+i] = Number(a >> BigInt(i*32) & 0xFFFFFFFFn);
        }
    }

    allocInt(_a) {
        const p = this.alloc(this.n8);
        if (_a) this.putInt(p, _a);
        return p;
    }

    putInt2(pos, _a) {
        const a = BigInt(_a);
        if (pos & 0x7) throw new Error("Pointer must be aligned");
        if (bitLength(a) > this.n64*64*2) {
            return this.putInt(a % this.q);
        }
        for (let i=0; i<this.n32*2; i++) {
            this.i32[(pos>>2)+i] = Number(a >> BigInt(i*32) & 0xFFFFFFFFn);
        }
    }

    getInt(pos) {
        if (pos & 0x7) throw new Error("Pointer must be aligned");
        let acc = BigInt(this.i32[(pos>>2)+this.n32-1]);
        for (let i=this.n32-2; i>=0; i--) {
            acc = acc << 32n;
            acc = acc + BigInt(this.i32[(pos>>2)+i]);
        }
        return acc;
    }

    getInt2(pos) {
        if (pos & 0x7) throw new Error("Pointer must be aligned");
        const last = this.n32*2-1;
        let acc = BigInt(this.i32[(pos>>2)+last]);
        for (let i=last; i>=0; i--) {
            acc = acc << 32n;
            acc = acc + BigInt(this.i32[(pos>>2)+i]);
        }
        return acc;
    }

    allocInt2(_a) {
        const p = this.alloc(this.n8*2);
        if (_a) this.putInt2(p, _a);
        return p;
    }

    test_F1(n) {
        const start = new Date().getTime();

        this.instance.exports.testF1(n);

        const end = new Date().getTime();
        const time = end - start;

        return time;
    }
/*
    function test(n) {

        const q = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;
        let a = (1n << 512n)%q ;
        let b = a >> 128n;

        let c;

        const start = new Date().getTime();
        for (let i=0; i<n; i++) c = a+b;

        const end = new Date().getTime();
        const time = end - start;

        console.log(time);
    }
*/
}

module.exports = build;



---
File: /@zk-email/helpers/node_modules/wasmcurves/src/utils.js
---

/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/

exports.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {
    const b = Array(len);
    let v = BigInt(_a);
    for (let i=0; i<len; i++) {
        b[i] = Number(v & 0xFFn);
        v = v >> 8n;
    }
    return b;
};

exports.bigInt2U32LE = function bigInt2BytesLE(_a, len) {
    const b = Array(len);
    let v = BigInt(_a);
    for (let i=0; i<len; i++) {
        b[i] = Number(v & 0xFFFFFFFFn);
        v = v >> 32n;
    }
    return b;
};

exports.isOcamNum = function(a) {
    if (!Array.isArray(a)) return false;
    if (a.length != 3) return false;
    if (typeof a[0] !== "number") return false;
    if (typeof a[1] !== "number") return false;
    if (!Array.isArray(a[2])) return false;
    return true;
};





---
File: /@zk-email/helpers/node_modules/wasmcurves/test/helpers/helpers.js
---

function genValues(n, neg, bitsPerWord) {
    bitsPerWord = bitsPerWord || 32;
    const res = [];
    res.push(0n);
    for (let i=0; i<n; i++) {
        if (i>0) {
            res.push( (1n << BigInt(bitsPerWord*i)) - 1n);
        }
        if (i<n-1) {
            res.push( 1n << BigInt(bitsPerWord*i));
            res.push( (1n << BigInt(bitsPerWord*i)) + 1n);
        }
    }

    if (neg) {
        const nt= res.length;
        for (let i=0; i<nt; i++) res.push(0n - res[i]);
    }

    return res;
}

module.exports.genValues = genValues;



---
File: /@zk-email/helpers/node_modules/wasmcurves/test/bls12381.js
---

const assert = require("assert");
const buildBls12381 = require("../src/bls12381/build_bls12381.js");
const buildProtoboard = require("wasmbuilder").buildProtoboard;
const {bitLength} = require("../src/bigint.js");

describe("Basic tests for g1 in bls12-381", function () {

    this.timeout(10000000);

    const n8q=48;
    const n8r=32;

    function getFieldElementF12(pR) {
        pb.ftm_fromMontgomery(pR, pR);
        const res =  [
            [
                [
                    pb.get(pR),
                    pb.get(pR+n8q),
                ],[
                    pb.get(pR+n8q*2),
                    pb.get(pR+n8q*3),
                ],[
                    pb.get(pR+n8q*4),
                    pb.get(pR+n8q*5),
                ]
            ],[
                [
                    pb.get(pR+n8q*6),
                    pb.get(pR+n8q*7),
                ],[
                    pb.get(pR+n8q*8),
                    pb.get(pR+n8q*9),
                ],[
                    pb.get(pR+n8q*10),
                    pb.get(pR+n8q*11),
                ]
            ]
        ];
        pb.ftm_toMontgomery(pR, pR);
        return res;
    }
    function getFieldElementF6(pR) {
        pb.f6m_fromMontgomery(pR, pR);
        const res =  [
            [
                pb.get(pR),
                pb.get(pR+n8q),
            ],[
                pb.get(pR+n8q*2),
                pb.get(pR+n8q*3),
            ],[
                pb.get(pR+n8q*4),
                pb.get(pR+n8q*5),
            ]
        ];
        pb.f6m_toMontgomery(pR, pR);
        return res;
    }
    function getFieldElementF2(pR) {
        pb.f2m_fromMontgomery(pR, pR);
        const res =  [
            pb.get(pR),
            pb.get(pR+n8q),
        ];
        pb.f2m_toMontgomery(pR, pR);
        return res;
    }

    function assertEqualF12(p1, p2) {
        for (let i=0; i<2; i++) {
            for (let j=0; j<3; j++) {
                for (let k=0; k<2; k++) {
                    assert.equal(p1[i][j][k], p2[i][j][k]);
                }
            }
        }
    }

    function assertEqualF6(p1, p2) {
        for (let j=0; j<3; j++) {
            for (let k=0; k<2; k++) {
                assert.equal(BigInt(p1[j][k]), BigInt(p2[j][k]));
            }
        }
    }

    function assertEqualF2(p1, p2) {
        for (let k=0; k<2; k++) {
            assert.equal(p1[k], p2[k]);
        }
    }

    function ns(p) {
        pb.f1m_fromMontgomery(p, p);
        const n = pb.get(p);
        pb.f1m_toMontgomery(p, p);
        return "0x" + n.toString(16);
    }

    //eslint-disable-next-line no-unused-vars
    function printF1(s, p) {
        console.log(s, " " + ns(p));
    }

    //eslint-disable-next-line no-unused-vars
    function printF2(s, p) {
        console.log(s + " Fq2(" + ns(p) + " + " + ns(p+n8q) +"*u " );
    }

    //eslint-disable-next-line no-unused-vars
    function printF6(s, p) {
        console.log(s + " [Fq2(\n" + ns(p) + " +\n " + ns(p+n8q) +"*u],[" );
        console.log("Fq2(\n" + ns(p+n8q*2) + " +\n " + ns(p+n8q*3) +"*u],[" );
        console.log("Fq2(\n" + ns(p+n8q*4) + " +\n " + ns(p+n8q*5) +"*u]" );
    }

    //eslint-disable-next-line no-unused-vars
    function printF12(s, p) {
        console.log(s + " [ [Fq2(\n" + ns(p) + " +\n " + ns(p+n8q) +"*u],[" );
        console.log("Fq2(\n" + ns(p+n8q*2) + " +\n " + ns(p+n8q*3) +"*u],[" );
        console.log("Fq2(\n" + ns(p+n8q*4) + " +\n " + ns(p+n8q*5) +"*u]]" );
        console.log("[ [Fq2(\n" + ns(p+n8q*6) + " +\n " + ns(p+n8q*7) +"*u],[" );
        console.log("Fq2(\n" + ns(p+n8q*8) + " +\n " + ns(p+n8q*9) +"*u],[" );
        console.log("Fq2(\n" + ns(p+n8q*10) + " +\n " + ns(p+n8q*11) +"*u]]" );
    }

    //eslint-disable-next-line no-unused-vars
    function printG1(s, p) {
        console.log(s + " G1(" + ns(p) + " , " + ns(p+n8q) + " , " + ns(p+n8q*2) + ")"   );
    }

    //eslint-disable-next-line no-unused-vars
    function printG2(s, p) {
        console.log(s + " (G2):");
        for (let i=0; i<6; i++) {
            console.log(ns(p+n8q*i));
        }
        console.log("");
    }


    let pb;
    before(async () => {
        pb = await buildProtoboard((module) => {
            buildBls12381(module);
        }, n8q);
    });

    it("It should do a basic point operation in F2", async () => {
        const e1 = pb.alloc(n8q*2);
        pb.set(e1, 1n);
        pb.set(e1+n8q, 2n);
        const e2 = pb.alloc(n8q*2);
        pb.f2m_square(e1,e2);

        const e3 = pb.alloc(n8q*2);
        pb.f2m_mul(e1,e1, e3);

        const res2 = getFieldElementF2(e2);
        const res3 = getFieldElementF2(e3);

        assert(res2[0] = res3[0]);
        assert(res2[1] = res3[1]);
    });
    it("It should do a big exponentioation F2", async () => {
        const e1 = pb.alloc(n8q*2);
        pb.set(e1, 1n);
        pb.set(e1+n8q, 2n);

        const exp = pb.bls12381.q ** 2n - 1n;

        const l = (Math.floor((bitLength(exp)- 1) / 64) +1)*8;

        const ps = pb.alloc(l);

        pb.set(ps, exp, l);

        const e2 = pb.alloc(n8q*2);
        pb.f2m_exp(e1, ps, l, e2);

        const res2 = getFieldElementF2(e2);

        assert.equal(res2[0], 1n);
        assert.equal(res2[1], 0n);
    });
    it("It should do a basic op in f2", async () => {
        const e1 = pb.alloc(n8q*2);

        for (let i=0; i<2; i++) {
            pb.set(e1+n8q*i, BigInt(i+1));
        }

        pb.f2m_toMontgomery(e1, e1);

        const e2 = pb.alloc(n8q*2);
        pb.f2m_square(e1, e2);

        const e3 = pb.alloc(n8q*2);
        pb.f2m_mul(e1,e1, e3);

        const res2 = getFieldElementF2(e2);
        const res3 = getFieldElementF2(e3);

        assertEqualF2(res2, res3);
    });
    it("It should do a basic op in f6", async () => {
        const e1 = pb.alloc(n8q*6);

        for (let i=0; i<6; i++) {
            if ((i==2)||(i==5)) {
                pb.set(e1+n8q*i, 1n);
            } else {
                pb.f1m_zero(e1+n8q*i);
            }
        }

        pb.f6m_toMontgomery(e1, e1);

        const e2 = pb.alloc(n8q*6);
        pb.f6m_square(e1, e2);

        const e3 = pb.alloc(n8q*6);
        pb.f6m_mul(e1,e1, e3);

        pb.f6m_fromMontgomery(e2, e2);
        pb.f6m_fromMontgomery(e3, e3);

        const res2 = getFieldElementF6(e2);
        const res3 = getFieldElementF6(e3);

        assertEqualF6(res2, res3);
    });
    it("It should do a basic op in f12", async () => {
        const e1 = pb.alloc(n8q*12);

        for (let i=0; i<12; i++) {
            if ((i==5)||(i==6)) {
                pb.set(e1+n8q*i, 1n);
            } else {
                pb.f1m_zero(e1+n8q*i);
            }
        }

        pb.ftm_toMontgomery(e1, e1);

        const e2 = pb.alloc(n8q*12);
        pb.ftm_square(e1, e2);

        const e3 = pb.alloc(n8q*12);
        pb.ftm_mul(e1,e1, e3);

        pb.ftm_fromMontgomery(e2, e2);
        pb.ftm_fromMontgomery(e3, e3);

        const res2 = getFieldElementF12(e2);
        const res3 = getFieldElementF12(e3);

        assertEqualF12(res2, res3);
    });


    it("It should do a big exponentioation F12", async () => {
        const e1 = pb.alloc(n8q*12);

        for (let i=0; i<12; i++) {
            pb.set(e1+n8q*i, BigInt(i+1));
        }

        const exp = pb.bls12381.q ** 12n - 1n;

        const l = (Math.floor((bitLength(exp) - 1) / 64) +1)*8;

        const ps = pb.alloc(l);

        pb.set(ps, exp, l);

        const e2 = pb.alloc(n8q*12);
        pb.ftm_exp(e1, ps, l, e2);

        const res2 = getFieldElementF12(e2);

        assert.equal(res2[0][0][0], 1n);
        assert.equal(res2[0][0][1], 0n);
        assert.equal(res2[0][1][0], 0n);
        assert.equal(res2[0][1][1], 0n);
        assert.equal(res2[0][2][0], 0n);
        assert.equal(res2[0][2][1], 0n);
        assert.equal(res2[1][0][0], 0n);
        assert.equal(res2[1][0][1], 0n);
        assert.equal(res2[1][1][0], 0n);
        assert.equal(res2[1][1][1], 0n);
        assert.equal(res2[1][2][0], 0n);
        assert.equal(res2[1][2][1], 0n);
    });
    it("It should do a basic point doubling adding G1", async () => {
        const pG1 = pb.bls12381.pG1gen;

        const p1 = pb.alloc(n8q*3);
        const p2 = pb.alloc(n8q*3);

        pb.g1m_add(pG1, pG1, p1); // 2*G1
        pb.g1m_add(p1, pG1, p1);  // 3*G1
        pb.g1m_add(p1, pG1, p1);  // 4*G1

        pb.g1m_double(pG1, p2); // 2*G1
        pb.g1m_double(p2, p2); // 4*G1

        assert.equal(pb.g1m_isZero(pG1), 0);
        assert.equal(pb.g1m_eq(p1, p2), 1);

        pb.g1m_sub(p1, p2, p1);  // 0
        assert.equal(pb.g1m_isZero(p1), 1);

    });
    it("It should timesScalar G1", async () => {

        const s=10;
        const pG1 = pb.bls12381.pG1gen;

        const p1 = pb.alloc(n8q*3);
        const p2 = pb.alloc(n8q*3);
        const ps = pb.alloc(n8r);

        pb.set(ps, s);

        pb.g1m_timesScalar(pG1, ps, n8r, p1);

        pb.g1m_zero(p2);

        for (let i=0; i<s; i++) {
            pb.g1m_add(pG1,p2, p2);
        }

        assert.equal(pb.g1m_eq(p1, p2), 1);
    });
    it("G1n == 0", async () => {
        const pG1 = pb.bls12381.pG1gen;
        const pr = pb.bls12381.pr;

        const p1 = pb.alloc(n8q*3);

        pb.g1m_timesScalar(pG1, pr, n8r, p1);

        assert.equal(pb.g1m_isZero(p1), 1);
    });
    it("It should do a basic point doubling adding G2", async () => {
        const pG2 = pb.bls12381.pG2gen;

        const p1 = pb.alloc(n8q*6);
        const p2 = pb.alloc(n8q*6);

        pb.g2m_add(pG2, pG2, p1); // 2*G1
        pb.g2m_add(p1, pG2, p1);  // 3*G1
        pb.g2m_add(p1, pG2, p1);  // 4*G1

        pb.g2m_double(pG2, p2); // 2*G1
        pb.g2m_double(p2, p2); // 4*G1

        assert.equal(pb.g2m_isZero(pG2), 0);
        assert.equal(pb.g2m_eq(p1, p2), 1);

        pb.g2m_sub(p1, p2, p1);  // 0
        assert.equal(pb.g2m_isZero(p1), 1);

    });
    it("It should timesScalar G2", async () => {

        const s=10;
        const pG2 = pb.bls12381.pG2gen;

        const p1 = pb.alloc(n8q*6);
        const p2 = pb.alloc(n8q*6);
        const ps = pb.alloc(n8r);

        pb.set(ps, s);

        pb.g2m_timesScalar(pG2, ps, n8r, p1);

        pb.g2m_zero(p2);

        for (let i=0; i<s; i++) {
            pb.g2m_add(pG2,p2, p2);
        }

        assert.equal(pb.g2m_eq(p1, p2), 1);
    });
    it("G2n == 0", async () => {
        const pG2 = pb.bls12381.pG2gen;
        const pr = pb.bls12381.pr;

        const p1 = pb.alloc(n8q*6);

        pb.g2m_timesScalar(pG2, pr, n8r, p1);

        assert.equal(pb.g2m_isZero(p1), 1);
    });

    it("Should f6_mul1", async () => {
        const pA = pb.alloc(n8q*6);
        const pB = pb.alloc(n8q*6);
        const pRes1 = pb.alloc(n8q*6);
        const pRes2 = pb.alloc(n8q*6);
        const pOne = pb.alloc(n8q*6);
        const pRef = pb.alloc(n8q*6);
        for (let i=0; i<6; i++) {
            pb.set(pA + i*n8q, i+1);
            if ([2,3].indexOf(i)>=0) {
                pb.set(pB + i*n8q, i+1);
            } else {
                pb.f1m_zero(pB + i*n8q);
            }
        }
        pb.f6m_one(pOne);

        pb.f6m_toMontgomery(pA,pA);
        pb.f6m_toMontgomery(pB,pB);
        const pc1 = pb.alloc(n8q*2);
        pb.set(pc1, 3);
        pb.set(pc1 + n8q, 4);
        pb.f2m_toMontgomery(pc1, pc1);


        pb.f6m_mul1(pOne, pc1, pRef);
        pb.f6m_mul1(pA, pc1, pRes1);
        pb.f6m_mul(pA, pB, pRes2);

        const ref = getFieldElementF6(pRef);
        const res1 = getFieldElementF6(pRes1);
        const res2 = getFieldElementF6(pRes2);

        assertEqualF6(ref, [[0,0], [3,4], [0,0]]);
        assertEqualF6(res1, res2);
    });

    it("Should f6_mul01", async () => {
        const pA = pb.alloc(n8q*6);
        const pB = pb.alloc(n8q*6);
        const pRes1 = pb.alloc(n8q*6);
        const pRes2 = pb.alloc(n8q*6);
        const pOne = pb.alloc(n8q*6);
        const pRef = pb.alloc(n8q*6);
        for (let i=0; i<6; i++) {
            pb.set(pA + i*n8q, i+1);
            if ([0,1,2,3].indexOf(i)>=0) {
                pb.set(pB + i*n8q, i+1);
            } else {
                pb.f1m_zero(pB + i*n8q);
            }
        }
        pb.f6m_one(pOne);

        pb.f6m_toMontgomery(pA,pA);
        pb.f6m_toMontgomery(pB,pB);
        const pc0 = pb.alloc(n8q*2);
        pb.set(pc0, 1);
        pb.set(pc0 + n8q, 2);
        pb.f2m_toMontgomery(pc0, pc0);
        const pc1 = pb.alloc(n8q*2);
        pb.set(pc1, 3);
        pb.set(pc1 + n8q, 4);
        pb.f2m_toMontgomery(pc1, pc1);


        pb.f6m_mul01(pOne, pc0, pc1, pRef);
        pb.f6m_mul01(pA, pc0, pc1, pRes1);
        pb.f6m_mul(pA, pB, pRes2);

        const ref = getFieldElementF6(pRef);
        const res1 = getFieldElementF6(pRes1);
        const res2 = getFieldElementF6(pRes2);

        assertEqualF6(ref, [[1,2], [3,4], [0,0]]);
        assertEqualF6(res1, res2);
    });
    it("Should f12_014", async () => {
        const pA = pb.alloc(n8q*12);
        const pB = pb.alloc(n8q*12);
        const pRes1 = pb.alloc(n8q*12);
        const pRes2 = pb.alloc(n8q*12);
        const pOne = pb.alloc(n8q*12);
        const pRef = pb.alloc(n8q*12);
        for (let i=0; i<12; i++) {
            pb.set(pA + i*n8q, i+1);
            if ([0,1,2,3,8,9].indexOf(i)>=0) {
                pb.set(pB + i*n8q, i+1);
            } else {
                pb.f1m_zero(pB + i*n8q);
            }
        }
        pb.ftm_one(pOne);

        pb.ftm_toMontgomery(pA,pA);
        pb.ftm_toMontgomery(pB,pB);
        const pc0 = pb.alloc(n8q*2);
        pb.set(pc0, 1);
        pb.set(pc0 + n8q, 2);
        pb.ftm_toMontgomery(pc0, pc0);
        const pc1 = pb.alloc(n8q*2);
        pb.set(pc1, 3);
        pb.set(pc1 + n8q, 4);
        pb.f2m_toMontgomery(pc1, pc1);
        const pc4 = pb.alloc(n8q*2);
        pb.set(pc4, 9);
        pb.set(pc4 + n8q, 10);
        pb.f2m_toMontgomery(pc4, pc4);


        pb.ftm_mul014(pOne, pc0, pc1, pc4, pRef);
        pb.ftm_mul014(pA, pc0, pc1, pc4, pRes1);
        pb.ftm_mul(pA, pB, pRes2);

        const ref = getFieldElementF12(pRef);
        const res1 = getFieldElementF12(pRes1);
        const res2 = getFieldElementF12(pRes2);

        assertEqualF12(ref, [[[1,2], [3,4], [0,0]],[[0,0], [9,10], [0,0]]]);
        assertEqualF12(res1, res2);
    });


    it("Should Test Frobenius", async () => {
        const pA = pb.alloc(n8q*12);
        const pB = pb.alloc(n8q*12);
        const pAq = pb.alloc(n8q*12);
        const pAqi = pb.alloc(n8q*12);
        const pq = pb.bls12381.pq;
        let res1, res2;
        for (let i=0; i<12; i++) {
            pb.set(pA+n8q*i, BigInt(i+1));
        }
        pb.ftm_toMontgomery(pA, pA);
        // printF12("pA", pA);

        pb.ftm_frobeniusMap0(pA, pB);
        res1 = getFieldElementF12(pA);
        res2 = getFieldElementF12(pB);

        assertEqualF12(res1, res2);

        pb.ftm_exp(pA, pq, n8q,pAq);

        for (let power = 1; power<10; ++power) {
            pb["ftm_frobeniusMap"+power](pA, pAqi);
            res1 = getFieldElementF12(pAq);
            res2 = getFieldElementF12(pAqi);

            // printF12("Aq", pAq);
            // printF12("Aqi", pAqi);

            assertEqualF12(res1, res2);

            pb.ftm_exp(pAq, pq, n8q,pAq);
        }

    });

    it("Should test Inverse", async () => {


        // template<typename FieldT>
        // void test_unitary_inverse()
        // {
        //     assert(FieldT::extension_degree() % 2 == 0);
        //     FieldT a = FieldT::random_element();
        //     FieldT aqcubed_minus1 = a.Frobenius_map(FieldT::extension_degree()/2) * a.inverse();
        //     assert(aqcubed_minus1.inverse() == aqcubed_minus1.unitary_inverse());

        const pA = pb.alloc(n8q*12);
        const pAf = pb.alloc(n8q*12);
        const pAInverse = pb.alloc(n8q*12);
        const pAcubedMinus1 = pb.alloc(n8q*12);
        const pAcubedMinus1Inverse = pb.alloc(n8q*12);
        const pAcubedMinus1UnitaryInverse = pb.alloc(n8q*12);
        let res1, res2;
        for (let i=0; i<12; i++) {
            pb.set(pA+n8q*i, BigInt(i+1));
        }
        pb.ftm_toMontgomery(pA, pA);
        pb.ftm_frobeniusMap6(pA, pAf);
        pb.ftm_inverse(pA, pAInverse);
        pb.ftm_mul(pAf, pAInverse, pAcubedMinus1);
        pb.ftm_inverse(pAcubedMinus1, pAcubedMinus1Inverse);
        pb.ftm_conjugate(pAcubedMinus1, pAcubedMinus1UnitaryInverse);

        // printF12("AcubedMinus1Inverse: ", pAcubedMinus1Inverse);
        // printF12("AcubedMinus1UnitaryInverse: ", pAcubedMinus1UnitaryInverse);
        res1 = getFieldElementF12(pAcubedMinus1Inverse);
        res2 = getFieldElementF12(pAcubedMinus1UnitaryInverse);
        assertEqualF12(res1, res2);

    });

    it("Should test Cyclotomic Square", async () => {

        // typedef Fqk<edwards_pp> FieldT;
        // assert(FieldT::extension_degree() % 2 == 0);
        //  FieldT a = FieldT::random_element();
        // FieldT a_unitary = a.Frobenius_map(FieldT::extension_degree()/2) * a.inverse();
        // // beta = a^((q^(k/2)-1)*(q+1))
        // FieldT beta = a_unitary.Frobenius_map(1) * a_unitary;
        // assert(beta.cyclotomic_squared() == beta.squared());


        const pA = pb.alloc(n8q*12);
        const pBeta = pb.alloc(n8q*12);
        const pCycSquare = pb.alloc(n8q*12);
        const pNormSquare = pb.alloc(n8q*12);
        const pCycExp = pb.alloc(n8q*12);
        const pNormExp = pb.alloc(n8q*12);
        const pr = pb.alloc(n8q);
        const pe = pb.alloc(544);
        const peZ = pb.alloc(n8q);

        pb.set(pr, 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n);
        pb.set(pe, 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n, 544);
        pb.set(peZ, 15132376222941642752n);

        let res1, res2;
        for (let i=0; i<12; i++) {
            pb.set(pA+n8q*i, BigInt(i+1));
        }

        pb.ftm_exp(pA, pe, 544, pBeta);
        pb.ftm_square(pBeta, pNormSquare);
        pb.bls12381__cyclotomicSquare(pBeta, pCycSquare);

        // printF12("NormSquare2: ", pNormSquare);
        // printF12("CycSquare2: ", pCycSquare);
        res1 = getFieldElementF12(pNormSquare);
        res2 = getFieldElementF12(pCycSquare);
        assertEqualF12(res1, res2);


        pb.ftm_exp(pBeta, peZ, n8q, pNormExp);
        pb.ftm_conjugate(pNormExp, pNormExp);
        pb.bls12381__cyclotomicExp_w0(pBeta, pCycExp);

        // printF12("NormExp: ", pNormExp);
        // printF12("CycExp: ", pCycExp);
        res1 = getFieldElementF12(pNormExp);
        res2 = getFieldElementF12(pCycExp);
        assertEqualF12(res1, res2);

    });

    it("Should test unitary", async () => {
        const pG1 = pb.bls12381.pG1gen;
        const pG2 = pb.bls12381.pG2gen;
        const pnG1 = pb.alloc(n8q*3);
        const pnG2 = pb.alloc(n8q*6);

        const pP = pb.alloc(n8q*12);
        const pQ = pb.alloc(n8q*12);
        const pR = pb.alloc(n8q*12);

        pb.g1m_neg(pG1, pnG1);
        pb.g2m_neg(pG2, pnG2);

        pb.bls12381_pairing(pG1, pG2, pP);
        pb.ftm_conjugate(pP, pP);
        pb.bls12381_pairing(pG1, pnG2, pQ);
        pb.bls12381_pairing(pnG1, pG2, pR);

        // printF12("P: ", pP);
        // printF12("Q: ", pQ);
        // printF12("R: ", pR);

        const P = getFieldElementF12(pP);
        const Q = getFieldElementF12(pQ);
        const R = getFieldElementF12(pR);

        assertEqualF12(P, Q);
        assertEqualF12(Q, R);
    });

    it("It should do a basic pairing", async () => {
        const ps = pb.alloc(n8r);
        const pOne = pb.alloc(n8q*12);
        pb.set(ps, 10n);
        const pRes1 = pb.alloc(n8q*12);
        const pRes2 = pb.alloc(n8q*12);
        const pRes3 = pb.alloc(n8q*12);
        const pRes4 = pb.alloc(n8q*12);

        const pG1s = pb.alloc(n8q*3);
        const pG2s = pb.alloc(n8q*2*3);
        const pG1gen = pb.bls12381.pG1gen;
        const pG2gen = pb.bls12381.pG2gen;

        pb.ftm_one(pOne);
        pb.g1m_timesScalar(pG1gen, ps, n8r, pG1s);
        pb.g2m_timesScalar(pG2gen, ps, n8r, pG2s);

        const pPreP = pb.alloc(n8q*3);
        const pPreQ = pb.alloc(n8q*2*3 + n8q*2*3*70);

        pb.bls12381_prepareG1(pG1s, pPreP);
        pb.bls12381_prepareG2(pG2gen, pPreQ);


        // printG1("pPreP: ", pPreP);
        // for (let i=0; i<75; i++) {
        //     printG1("pPreQ " + i + ":", pPreQ + i*48*2*3);
        // }
        pb.bls12381_millerLoop(pPreP, pPreQ, pRes1);
        // printF12("Miller Result: ", pRes1);
        pb.bls12381_finalExponentiation(pRes1, pRes2);

        pb.bls12381_prepareG1(pG1gen, pPreP);
        pb.bls12381_prepareG2(pG2s, pPreQ);
        pb.bls12381_millerLoop(pPreP, pPreQ, pRes3);
        pb.bls12381_finalExponentiation(pRes3, pRes4);

        const res2 = getFieldElementF12(pRes2);
        const res4 = getFieldElementF12(pRes4);

        assertEqualF12(res2, res4);

        pb.bls12381_pairing(pG1s, pG2gen, pRes1);

        const start = new Date().getTime();
        pb.bls12381_pairing(pG1gen, pG2s, pRes2);
        const end = new Date().getTime();
        const time = end - start;
        console.log("Time to compute a single pairing (ms): " + time);

        const resL = getFieldElementF12(pRes1);
        const resR = getFieldElementF12(pRes2);

        assertEqualF12(resL, resR);

    });

    it("Generator should be in group G1", async () => {
        const pG1 = pb.bls12381.pG1gen;

        assert.equal(pb.g1m_inGroupAffine(pG1), 1);
    });

    it("Point in curve and not in group G1", async () => {
        const p1 = pb.alloc(n8q*3);
        const pG1b = pb.bls12381.pG1b;

        pb.set(p1, 4n, n8q);
        pb.f1m_toMontgomery(p1, p1);
        pb.f1m_square(p1, p1+n8q);
        pb.f1m_mul(p1, p1+n8q, p1+n8q);
        pb.f1m_add(p1+n8q, pG1b, p1+n8q);

        assert.equal(pb.g1m_inGroupAffine(p1), 0);
        assert.equal(pb.g1m_inCurveAffine(p1), 0);

        pb.f1m_sqrt(p1+n8q, p1+n8q);

        assert.equal(pb.g1m_inGroupAffine(p1), 0);
        assert.equal(pb.g1m_inCurveAffine(p1), 1);

        const ph= pb.alloc(16);
        pb.set(ph, 0x396c8c005555e1568c00aaab0000aaabn, 16);

        pb.g1m_timesScalarAffine(p1, ph, 16  ,p1);

        assert.equal(pb.g1m_inCurve(p1), 1);
        assert.equal(pb.g1m_inGroup(p1), 1);
    });

    it("It should test in group G2", async () => {
        const pG2 = pb.bls12381.pG2gen;

        assert.equal(pb.g2m_inGroupAffine(pG2), 1);
    });


    it("Point in curve and not in group G2", async () => {
        const p1 = pb.alloc(n8q*6);
        const pG2b = pb.bls12381.pG2b;

        pb.set(p1, 0n, n8q);
        pb.set(p1+n8q, 4n, n8q);
        pb.f2m_toMontgomery(p1, p1);
        pb.f2m_square(p1, p1+n8q*2);
        pb.f2m_mul(p1, p1+n8q*2, p1+n8q*2);
        pb.f2m_add(p1+n8q*2, pG2b, p1+n8q*2);

        assert.equal(pb.g2m_inGroupAffine(p1), 0);
        assert.equal(pb.g2m_inCurveAffine(p1), 0);

        pb.f2m_sqrt(p1+n8q*2, p1+n8q*2);

        assert.equal(pb.g2m_inGroupAffine(p1), 0);
        assert.equal(pb.g2m_inCurveAffine(p1), 1);

        const ph= pb.alloc(64);
        pb.set(ph, 0x05d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5n, 64);

        pb.g2m_timesScalarAffine(p1, ph, 64  ,p1);

        assert.equal(pb.g2m_inCurve(p1), 1);
        assert.equal(pb.g2m_inGroup(p1), 1);
    });


});



---
File: /@zk-email/helpers/node_modules/wasmcurves/test/bn128.js
---

const assert = require("assert");
const buildBn128 = require("../src/bn128/build_bn128.js");
const buildProtoboard = require("wasmbuilder").buildProtoboard;

describe("Basic tests for g1 in bn128", () => {

    function getFieldElementF12(pR) {
        return [
            [
                [
                    pb.get(pR),
                    pb.get(pR+32),
                ],[
                    pb.get(pR+32*2),
                    pb.get(pR+32*3),
                ],[
                    pb.get(pR+32*4),
                    pb.get(pR+32*5),
                ]
            ],[
                [
                    pb.get(pR+32*6),
                    pb.get(pR+32*7),
                ],[
                    pb.get(pR+32*8),
                    pb.get(pR+32*9),
                ],[
                    pb.get(pR+32*10),
                    pb.get(pR+32*11),
                ]
            ]
        ];
    }

    function assertEqualF12(p1, p2) {
        for (let i=0; i<2; i++) {
            for (let j=0; j<3; j++) {
                for (let k=0; k<2; k++) {
                    assert.equal(p1[i][j][k], p2[i][j][k]);
                }
            }
        }
    }

    function ns(p) {
        pb.f1m_fromMontgomery(p, p);
        const n = pb.get(p);
        pb.f1m_toMontgomery(p, p);
        return "0x" + n.toString(16);
    }

    //eslint-disable-next-line no-unused-vars
    function printF1(s, p) {
        console.log(s, " " + ns(p));
    }

    //eslint-disable-next-line no-unused-vars
    function printF2(s, p) {
        console.log(s + " Fq2(" + ns(p) + " + " + ns(p+32) +"*u " );
    }

    //eslint-disable-next-line no-unused-vars
    function printF6(s, p) {
        console.log(s + " [Fq2(\n" + ns(p) + " +\n " + ns(p+32) +"*u],[" );
        console.log("Fq2(\n" + ns(p+32*2) + " +\n " + ns(p+32*3) +"*u],[" );
        console.log("Fq2(\n" + ns(p+32*4) + " +\n " + ns(p+32*5) +"*u]" );
    }

    //eslint-disable-next-line no-unused-vars
    function printF12(s, p) {
        console.log(s + " [ [Fq2(\n" + ns(p) + " +\n " + ns(p+32) +"*u],[" );
        console.log("Fq2(\n" + ns(p+32*2) + " +\n " + ns(p+32*3) +"*u],[" );
        console.log("Fq2(\n" + ns(p+32*4) + " +\n " + ns(p+32*5) +"*u]]" );
        console.log("[ [Fq2(\n" + ns(p+32*6) + " +\n " + ns(p+32*7) +"*u],[" );
        console.log("Fq2(\n" + ns(p+32*8) + " +\n " + ns(p+32*9) +"*u],[" );
        console.log("Fq2(\n" + ns(p+32*10) + " +\n " + ns(p+32*11) +"*u]]" );
    }

    //eslint-disable-next-line no-unused-vars
    function printG1(s, p) {
        console.log(s + " G1(" + ns(p) + " , " + ns(p+n8) + " , " + ns(p+n8*2) + ")"   );
    }

    //eslint-disable-next-line no-unused-vars
    function printG2(s, p) {
        console.log(s + " (G2):");
        for (let i=0; i<6; i++) {
            console.log(ns(p+n8*i));
        }
        console.log("");
    }


    let pb;
    const n8=32;
    before(async () => {
        pb = await buildProtoboard((module) => {
            buildBn128(module);
        }, n8);
    });

    it("It should do a basic point doubling adding G1", async () => {
        const pG1 = pb.bn128.pG1gen;

        const p1 = pb.alloc(n8*3);
        const p2 = pb.alloc(n8*3);

        pb.g1m_add(pG1, pG1, p1); // 2*G1
        // pb.g1m_normalize(p1, p1);
        printG1("2*G1=",p1);
        pb.g1m_add(p1, pG1, p1);  // 3*G1
        // pb.g1m_normalize(p1, p1);
        printG1("3*G1=",p1);
        pb.g1m_add(p1, pG1, p1);  // 4*G1

        pb.g1m_double(pG1, p2); // 2*G1
        pb.g1m_double(p2, p2); // 4*G1

        assert.equal(pb.g1m_isZero(pG1), 0);
        assert.equal(pb.g1m_eq(p1, p2), 1);

        pb.g1m_sub(p1, p2, p1);  // 0
        assert.equal(pb.g1m_isZero(p1), 1);

    });

    it("It should do a basic doubling adding G1", async () => {
        const pG1 = pb.bn128.pG1gen;

        const p1 = pb.alloc(n8*3);
        const p2 = pb.alloc(n8*3);

        pb.g1m_add(pG1, pG1, p1); // 2*G1
        pb.g1m_add(p1, pG1, p1);  // 3*G1
        pb.g1m_add(p1, pG1, p1);  // 4*G1

        pb.g1m_double(pG1, p2); // 2*G1
        pb.g1m_double(p2, p2); // 4*G1

        assert.equal(pb.g1m_isZero(pG1), 0);
        assert.equal(pb.g1m_eq(p1, p2), 1);

