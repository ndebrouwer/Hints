        const pC = pbInt.alloc(64);

        const start = new Date().getTime();
        pbInt.test_int_mul(pA, pB, pC, 10000000);
        const end = new Date().getTime();
        const time = end - start;

        const c = pbInt.get(pC, 1, 64);
        console.log("Result: " + c.toString(16));
        console.log("Refere: " + (A * B).toString(16));

        console.log("Tom School (ms): " + time);
    }).timeout(10000000);
    it("It should profile tomCook", async () => {
        let start, end, time;
        const A = (1n << 254n) - 1n;
        const B = (1n << 254n) - 1n;

        console.log(A.toString(16));

        const pA = pbTC.set(pbTC.alloc(9*4), A, 9*4);
        const pB = pbTC.set(pbTC.alloc(9*4), B, 9*4);
        const pC = pbTC.alloc(9*4*2);

        // start = new Date().getTime();
        // pbTC.test_tomcook_mul1(pA, pB, pC, 100000000);
        // end = new Date().getTime();
        // time = end - start;
        // console.log("Mul1 Tom Cook Time (ms): " + time);

        start = new Date().getTime();
        pbTC.test_tomcook_mul9(pA, pB, pC, 10000000);
        end = new Date().getTime();
        time = end - start;

        const c = pbTC.get(pC, 1, 9*4*2);
        console.log("Result: " + c.toString(16));
        console.log("Refere: " + (A * B).toString(16));

        console.log("Mul9 Tom Cook Time (ms): " + time);
    }).timeout(10000000);

});



---
File: /@zk-email/helpers/node_modules/wasmcurves/tools/buildpedersentablebases_mnt6753.js
---


const buildProtoboard = require("wasmbuilder").buildProtoboard;
const buildMNT6753 = require("../src/mnt6753/build_mnt6753.js");
const bigInt = require("big-integer");
const fs = require("fs");
const path = require("path");

var pedersenParameters = [
    ["2071893303198007985737678972190309212568452221625132024511988170095494148670997278812694070338313361389889122280160253462982652030041813566301365289695187505618174204273471887226695702458395861269694368663558765191107385382142", "17187187414417664367585796530257262302159176591062800465884265459977066325098901507827719965058588341044788483232395252403515861767227243983849894797683644816538861625368393588001624014759720661490214325432345769098675755344007"],
    ["12212700530208157134689256057121042620633735483309261868159828729358269133353025097021648766749096328904625282610227267815597560656189994727627613599055093979638719153187781645363642530065802177696707603573183038198049837281284", "25783690089010390455572974279288664362239817189553105020262800542618336981545722940934884637537924384027963108482794866752096889610121505188228870561534980224779056104062778099246844511975082198175449341056361726557212816273203"],
    ["24970556048065806436025775756019294569514287852390684813064321958272933228137795169157911036418821145649315804385644486444483724251269635399290126638401987231852781394516304251109918520031098349546899855265794613791318815401876", "31962426837049224740980485154381998358868991216693595616538747324158910634872015696123705432006307054685021215563881823301198025102710386453970240354239402398745821628720107919855566997584156778139135499881940592882629489943551"],
    ["4431264411717549274439490659582560401278429696218324463252012866668010436230467390709079687847260266333949609702709398614735778908621392906775244210809408019439483728382538000678063011124654256466867465806472450156285959296478", "5357104929738581133630585435713154584790058687516758823722160588386982989576958329026493218285464648215758171648009368623425257221760769388865621253647844864279048734223948216626860899712215839882580351969504555475483295828321"],
    ["6671433602972561813695090966408317709238420789110797829702834855105065892311048504872981038933746208133427345903147737968972400166128764694941204592973429712710593028851732935226387767696882706160253984317874861465334699161990", "21711555364470068355814107901005676801426239531219087510381972880175131973242407029290710493957974865954350244915332826635503654142837214217367474143450949577779528038476129095441904192715126325925180200706764720129647900154510"],
    ["3279287280516667726034641228088153493377068947932964914992332109534304163378313362642088339811737854700479601646880961405137089274374094406319964129318466368217040667072259586616947873396338805588189680637610631077799406849678", "36083410532375699766897530133147718931585816209038495573380944607379201487163666226805598827634658263382384531791578426004569849840500849793075159834066479383773342040065664681946311465722831163353980052849824208445357276512039"],
    ["6080315379067559396366920603391445316068884876999059159889161166465434118824372554207399274504146495157531657398487486565476348416859948241407968265138831613853730297645692192334843976583486101896736840413872097839964499683332", "26420424881408892228870218588074681761407815765852299070750308032078795079763335114222685666340147826454447640325063954005645285100365609355311780905109783862569185820306941334828547063301806152701392010289886220468661953965919"],
    ["39301831400422949389818222554551556278076967824511010861535510094278551646323817962504510429949535607847124719220397592919414191667356795652722963307663320704947997484288198213588564623546419124090570040138115255574753268044296", "36457812814376230890682190373753614518702525324272794059443925877471853974877472140825740785996758245920724784158181335975363784020543877031746359325492875482739908200696955809723414504629601464266420637086159099075048645416374"],
    ["7540664997550190973602360351030883142324749771399862809105176292300299526593722518355361727448429173635571954137685816627918496116227546648451982643232613412226512084475776533244886987139627138835739493051117039845249333293796", "41832168374796125531735699856185177965741887376998317172586340222379811256102274861246907652644659486244227261842256173112551393210515106271575307252302330588981902151799763241646966710905966859708456096352215232407040721812440"],
    ["36397483455279521486180767892445054628947434149047678403043888842127539677645442740735471632069262625023630925482329096023950321390546066181899597320416634680062586092646310952310844092327312810134226425393239318043723435147242", "18286472905180979924646715322917829676123207845562357760879307637733164075896656550520464980631401874233327857749869297454439627725894967171722892001304897028600380951109713197296853450963512190698451016172641099337226932835103"],
    ["38971740405150801303656120540964048311055428317597420804659853006910052152298169876746036294761470660390748610246706280407819428237389693394271333553585474382213782764591195401917422695201611402679319607462045083981820266292526", "12052300622245628070333354588755219239307478469529845235720526151711813563444656737524423919201679934065964579148677093493832843694922101898382470265577630638871822779691658559083989998504649770048646951871151837463810472588643"],
    ["28580639909521896467730379621107007981713563598576419274286032656030060646413984885651670728423715399952200046109842062405825188571385283021073346904536651485834210457583868625103914909503900539953858010694440026958408821693616", "33074070963001755009804136607611008375296623364907104158069380168975081449307467755506733151497347867221785696657950398557975950305507047259982036542250828282873739093067701764175433149313198906930824052021363292166457216217373"],
];


buildProtoboard((module) => {
    buildMNT6753(module);
}, 96). then(function(pb) {

    const tableSize = 96*3*pedersenParameters.length*4;
    const pTable = pb.alloc(tableSize);

    const res = [];
    for (let i=0; i<pedersenParameters.length; i++) {
        const p1 = pTable + i*96*3*4;
        pb.set(p1, bigInt(pedersenParameters[i][0]));
        pb.set(p1+96, bigInt(pedersenParameters[i][1]));
        pb.set(p1+96*2, bigInt(1));

        pb.g1m_toMontgomery(p1, p1);

        res.push(...pb.i8.slice(p1, p1+96*2));

        const p2 = p1+96*3;
        pb.g1m_double(p1, p2);
        pb.g1m_normalize(p2, p2);
        res.push(...pb.i8.slice(p2, p2+96*2));

        const p3 = p2+96*3;
        pb.g1m_add(p1, p2, p3);
        pb.g1m_normalize(p3, p3);
        res.push(...pb.i8.slice(p3, p3+96*2));

        const p4 = p3+96*3;
        pb.g1m_double(p2, p4);
        pb.g1m_normalize(p4, p4);
        res.push(...pb.i8.slice(p4, p4+96*2));
    }

    fs.writeFileSync(
        path.join( __dirname, "..", "build", "pedersenparams_mnt6753.js"),
`
// Code generated automatically by tools/buildpedersentablebases_mnt6753.js
module.exports = Buffer.from("${Buffer.from(res).toString("base64")}", "base64");;
`
    );

});



---
File: /@zk-email/helpers/node_modules/wasmcurves/tools/buildwasm_bls12381.js
---

const ModuleBuilder = require("wasmbuilder").ModuleBuilder;
const buildBls12381 = require("../src/bls12381/build_bls12381.js");
const fs = require("fs");
const path = require("path");

function buildWasm() {
    const moduleBuilder = new ModuleBuilder();
    moduleBuilder.setMemory(25);
    buildBls12381(moduleBuilder);

    const code = moduleBuilder.build();

    fs.writeFileSync(
        path.join( __dirname, "..", "build", "bls12381_wasm.js"),
        `
            exports.code = "${Buffer.from(code).toString("base64")}";
            exports.pq = ${moduleBuilder.modules.f1m.pq};
            exports.pr = ${moduleBuilder.modules.frm.pq};
            exports.pG1gen = ${moduleBuilder.modules.bls12381.pG1gen};
            exports.pG1zero = ${moduleBuilder.modules.bls12381.pG1zero};
            exports.pG1b = ${moduleBuilder.modules.bls12381.pG1b};
            exports.pG2gen = ${moduleBuilder.modules.bls12381.pG2gen};
            exports.pG2zero = ${moduleBuilder.modules.bls12381.pG2zero};
            exports.pG2b = ${moduleBuilder.modules.bls12381.pG2b};
            exports.pOneT = ${moduleBuilder.modules.bls12381.pOneT};
            exports.prePSize = ${moduleBuilder.modules.bls12381.prePSize};
            exports.preQSize = ${moduleBuilder.modules.bls12381.preQSize};
            exports.n8q = 48;
            exports.n8r = 32;
            exports.q = "${moduleBuilder.modules.bls12381.q}";
            exports.r = "${moduleBuilder.modules.bls12381.r}";
        `
    );

    fs.writeFileSync(
        path.join( __dirname, "..", "build", "bls12381.wasm"),
        Buffer.from(code)
    );
}

buildWasm();



---
File: /@zk-email/helpers/node_modules/wasmcurves/tools/buildwasm_bn128.js
---

const ModuleBuilder = require("wasmbuilder").ModuleBuilder;
const buildBn128 = require("../src/bn128/build_bn128.js");
const fs = require("fs");
const path = require("path");

function buildWasm() {
    const moduleBuilder = new ModuleBuilder();
    moduleBuilder.setMemory(25);
    buildBn128(moduleBuilder);

    const code = moduleBuilder.build();

    fs.writeFileSync(
        path.join( __dirname, "..", "build", "bn128_wasm.js"),
        `
            exports.code = "${Buffer.from(code).toString("base64")}";
            exports.pq = ${moduleBuilder.modules.f1m.pq};
            exports.pr = ${moduleBuilder.modules.frm.pq};
            exports.pG1gen = ${moduleBuilder.modules.bn128.pG1gen};
            exports.pG1zero = ${moduleBuilder.modules.bn128.pG1zero};
            exports.pG1b = ${moduleBuilder.modules.bn128.pG1b};
            exports.pG2gen = ${moduleBuilder.modules.bn128.pG2gen};
            exports.pG2zero = ${moduleBuilder.modules.bn128.pG2zero};
            exports.pG2b = ${moduleBuilder.modules.bn128.pG2b};
            exports.pOneT = ${moduleBuilder.modules.bn128.pOneT};
            exports.prePSize = ${moduleBuilder.modules.bn128.prePSize};
            exports.preQSize = ${moduleBuilder.modules.bn128.preQSize};
            exports.n8q = 32;
            exports.n8r = 32;
            exports.q = "${moduleBuilder.modules.bn128.q}";
            exports.r = "${moduleBuilder.modules.bn128.r}";
        `
    );

    fs.writeFileSync(
        path.join( __dirname, "..", "build", "bn128.wasm"),
        Buffer.from(code)
    );
}

buildWasm();



---
File: /@zk-email/helpers/node_modules/wasmcurves/tools/buildwasm_mnt6753.js
---

const ModuleBuilder = require("wasmbuilder").ModuleBuilder;
const buildMNT6753 = require("../src/mnt6753/build_mnt6753.js");
const buildPedersenHash = require("../src/build_pedersenhash.js");
const baseTables = require("../build/pedersenparams_mnt6753.js");
const fs = require("fs");
const path = require("path");

function buildWasm() {

    const moduleBuilder = new ModuleBuilder();
    moduleBuilder.setMemory(1000);

    buildMNT6753(moduleBuilder);
    buildPedersenHash(moduleBuilder, "g1m", "g1m", "f1m", 188, baseTables);

    const code = moduleBuilder.build();

    fs.writeFileSync(
        path.join( __dirname, "..", "build", "mnt6753_wasm.js"),
        `
            exports.code = "${Buffer.from(code).toString("base64")}";
            exports.pq = ${moduleBuilder.modules.mnt6753.pq};
            exports.pr = ${moduleBuilder.modules.mnt6753.pq};
            exports.pG1gen = ${moduleBuilder.modules.mnt6753.pG1gen};
            exports.pG1zero = ${moduleBuilder.modules.mnt6753.pG1zero};
            exports.pG2gen = ${moduleBuilder.modules.mnt6753.pG2gen};
            exports.pG2zero = ${moduleBuilder.modules.mnt6753.pG2zero};
            exports.pOneT = ${moduleBuilder.modules.mnt6753.pOneT};
            exports.prePSize = ${moduleBuilder.modules.mnt6753.prePSize};
            exports.preQSize = ${moduleBuilder.modules.mnt6753.preQSize};
        `
    );
}

buildWasm();



---
File: /@zk-email/helpers/node_modules/wasmcurves/.eslintrc.js
---

module.exports = {
    "env": {
        "es6": true,
        "node": true,
        "mocha": true,
        "es2020": true
    },
    "globals": {
        "WebAssembly": true
    },
    "parserOptions": {
        "ecmaVersion": 2020
    },
    "extends": "eslint:recommended",
    "rules": {
        "indent": [
            "error",
            4
        ],
        "linebreak-style": [
            "error",
            "unix"
        ],
        "quotes": [
            "error",
            "double"
        ],
        "semi": [
            "error",
            "always"
        ]
    }
};



---
File: /@zk-email/helpers/node_modules/wasmcurves/index.js
---

/*
    Copyright 2019 0KIMS association.

    This file is part of wasmsnark (Web Assembly zkSnark Prover).

    wasmsnark is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    wasmsnark is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.
*/


// module.exports.bn128_wasm = require("./build/bn128_wasm.js");
// module.exports.bls12381_wasm = require("./build/bls12381_wasm.js");
// module.exports.mnt6753_wasm = require("./build/mnt6753_wasm.js");

module.exports.buildBn128 = require("./src/bn128/build_bn128.js");
module.exports.buildBls12381 = require("./src/bls12381/build_bls12381.js");
// module.exports.buildMnt6753 = require("./src/mnt6753/build_mnt7.js");

module.exports.buildF1m = require("./src/build_f1m");



---
File: /@zk-email/helpers/src/dkim/dns-archive.ts
---

import { CustomError } from '../lib/mailauth/tools';

const ZKEMAIL_DNS_ARCHIVER_API = 'https://archive.prove.email/api/key';

export async function resolveDNSFromZKEmailArchive(name: string, type: string) {
  if (type !== 'TXT') {
    throw new Error(`ZK Email Archive only supports TXT records - got ${type}`);
  }

  // Get domain from full dns record name - $selector._domainkey.$domain.com
  const domain = name.split('.').slice(2).join('.');
  const selector = name.split('.')[0];

  const queryUrl = new URL(ZKEMAIL_DNS_ARCHIVER_API);
  queryUrl.searchParams.set('domain', domain);

  const resp = await fetch(queryUrl);
  const data = await resp.json();

  const dkimRecord = data.find((record: any) => record.selector === selector);

  if (!dkimRecord) {
    throw new CustomError(
      `DKIM record not found for domain ${domain} and selector ${selector} in ZK Email Archive.`,
      'ENODATA',
    );
  }

  return [dkimRecord.value];
}



---
File: /@zk-email/helpers/src/dkim/dns-over-http.ts
---

import { CustomError } from '../lib/mailauth/tools';

// DoH servers list
export enum DoHServer {
  // Google Public DNS
  Google = 'https://dns.google/resolve',
  // Cloudflare DNS
  Cloudflare = 'https://cloudflare-dns.com/dns-query',
}

/**
 * DNS over HTTPS (DoH) resolver
 *
 * @export
 * @class DoH
 */
export class DoH {
  // DNS response codes
  static DoHStatusNoError = 0;

  // DNS RR types
  static DoHTypeTXT = 16;

  /**
   * Resolve DKIM public key from DNS
   *
   * @static
   * @param {string} name DKIM record name (e.g. 20230601._domainkey.gmail.com)
   * @param {string} dnsServerURL DNS over HTTPS API URL
   * @return {*}  {(Promise<string | null>)} DKIM public key or null if not found
   * @memberof DoH
   */
  public static async resolveDKIMPublicKey(name: string, dnsServerURL: string): Promise<string | null> {
    let cleanURL = dnsServerURL;
    if (!cleanURL.startsWith('https://')) {
      cleanURL = `https://${cleanURL}`;
    }
    if (cleanURL.endsWith('/')) {
      cleanURL = cleanURL.slice(0, -1);
    }

    const queryUrl = new URL(cleanURL);
    queryUrl.searchParams.set('name', name);
    queryUrl.searchParams.set('type', DoH.DoHTypeTXT.toString());

    const resp = await fetch(queryUrl, {
      headers: {
        accept: 'application/dns-json',
      },
    });

    if (resp.status === 200) {
      const out = await resp.json();
      if (typeof out === 'object' && out !== null && 'Status' in out && 'Answer' in out) {
        const result = out as DoHResponse;
        if (result.Status === DoH.DoHStatusNoError && result.Answer.length > 0) {
          for (const ans of result.Answer) {
            if (ans.type === DoH.DoHTypeTXT) {
              let dkimRecord = ans.data;
              /*
                  Remove all double quotes
                  Some DNS providers wrap TXT records in double quotes, 
                  and others like Cloudflare may include them. According to 
                  TXT (potentially multi-line) and DKIM (Base64 data) standards,
                  we can directly remove all double quotes from the DKIM public key.
              */
              dkimRecord = dkimRecord.replace(/"/g, '');
              return dkimRecord;
            }
          }
        }
      }
    }
    return null;
  }
}

interface DoHResponse {
  Status: number; // NOERROR - Standard DNS response code (32 bit integer).
  TC: boolean; // Whether the response is truncated
  AD: boolean; // Whether all response data was validated with DNSSEC
  CD: boolean; // Whether the client asked to disable DNSSEC
  Question: Question[];
  Answer: Answer[];
  Comment: string;
}

interface Question {
  name: string; // FQDN with trailing dot
  type: number; // A - Standard DNS RR type. 5:CNAME, 16:TXT
}

interface Answer {
  name: string; // Always matches name in the Question section
  type: number; // A - Standard DNS RR type. 5:CNAME, 16:TXT
  TTL: number; // Record's time-to-live in seconds
  data: string; // Record data
}

export async function resolveDNSHTTP(name: string, type: string) {
  if (type !== 'TXT') {
    throw new Error(`DNS over HTTP: Only type TXT is supported, got ${type}`);
  }
  const googleResult = await DoH.resolveDKIMPublicKey(name, DoHServer.Google);
  if (!googleResult) {
    throw new CustomError('No DKIM record found in Google', 'ENODATA');
  }

  const regex = /p=([^;]*)/;
  const match = regex.exec(googleResult);
  if (match) {
    const valueAfterP = match[1]; // Extracting the value after p=
    if (valueAfterP === '') {
      throw new CustomError('No DKIM record found in Google (empty p=)', 'ENODATA');
    }
  }

  const cloudflareResult = await DoH.resolveDKIMPublicKey(name, DoHServer.Cloudflare);

  // Log an error if there is a mismatch in the result
  if (googleResult !== cloudflareResult) {
    console.error('DKIM record mismatch between Google and Cloudflare! Using Google result.');
  }

  return [googleResult];
}



---
File: /@zk-email/helpers/src/dkim/index.ts
---

import { pki } from 'node-forge';
import { DkimVerifier } from '../lib/mailauth/dkim-verifier';
import { writeToStream } from '../lib/mailauth/tools';
import sanitizers from './sanitizers';
import { resolveDNSHTTP } from './dns-over-http';
import { resolveDNSFromZKEmailArchive } from './dns-archive';

// `./mailauth` is modified version of https://github.com/postalsys/mailauth
// Main modification are including emailHeaders in the DKIM result, making it work in the browser, add types
// TODO: Fork the repo and make the changes; consider upstream to original repo

export interface DKIMVerificationResult {
  publicKey: bigint;
  signature: bigint;
  headers: Buffer;
  body: Buffer;
  bodyHash: string;
  signingDomain: string;
  selector: string;
  algo: string;
  format: string;
  modulusLength: number;
  appliedSanitization?: string;
}

/**
 *
 * @param email Entire email data as a string or buffer
 * @param domain Domain to verify DKIM signature for. If not provided, the domain is extracted from the `From` header
 * @param enableSanitization If true, email will be applied with various sanitization to try and pass DKIM verification
 * @param fallbackToZKEmailDNSArchive If true, ZK Email DNS Archive (https://archive.prove.email/api-explorer) will
 *                                    be used to resolve DKIM public keys if we cannot resolve from HTTP DNS
 * @returns
 */
export async function verifyDKIMSignature(
  email: Buffer | string,
  domain: string = '',
  enableSanitization: boolean = true,
  fallbackToZKEmailDNSArchive: boolean = false,
): Promise<DKIMVerificationResult> {
  const emailStr = email.toString();

  let dkimResult = await tryVerifyDKIM(email, domain, fallbackToZKEmailDNSArchive);

  // If DKIM verification fails, try again after sanitizing email
  let appliedSanitization;
  if (dkimResult.status.comment === 'bad signature' && enableSanitization) {
    const results = await Promise.all(
      sanitizers.map((sanitize) =>
        tryVerifyDKIM(sanitize(emailStr), domain, fallbackToZKEmailDNSArchive).then((result) => ({
          result,
          sanitizer: sanitize.name,
        })),
      ),
    );

    const passed = results.find((r) => r.result.status.result === 'pass');

    if (passed) {
      console.log(`DKIM: Verification passed after applying sanitization "${passed.sanitizer}"`);
      dkimResult = passed.result;
      appliedSanitization = passed.sanitizer;
    }
  }

  const {
    status: { result, comment },
    signingDomain,
    publicKey,
    signature,
    status,
    body,
    bodyHash,
  } = dkimResult;

  if (result !== 'pass') {
    throw new Error(`DKIM signature verification failed for domain ${signingDomain}. Reason: ${comment}`);
  }

  const pubKeyData = pki.publicKeyFromPem(publicKey.toString());

  return {
    signature: BigInt(`0x${Buffer.from(signature, 'base64').toString('hex')}`),
    headers: status.signedHeaders,
    body,
    bodyHash,
    signingDomain: dkimResult.signingDomain,
    publicKey: BigInt(pubKeyData.n.toString()),
    selector: dkimResult.selector,
    algo: dkimResult.algo,
    format: dkimResult.format,
    modulusLength: dkimResult.modulusLength,
    appliedSanitization,
  };
}

async function tryVerifyDKIM(
  email: Buffer | string,
  domain: string = '',
  fallbackToZKEmailDNSArchive: boolean = false,
) {
  const resolver = async (name: string, type: string) => {
    try {
      const result = await resolveDNSHTTP(name, type);
      return result;
    } catch (e) {
      if (fallbackToZKEmailDNSArchive) {
        console.log('DNS over HTTP failed, falling back to ZK Email Archive');
        const result = await resolveDNSFromZKEmailArchive(name, type);
        return result;
      }
      throw e;
    }
  };

  const dkimVerifier = new DkimVerifier({
    resolver,
  });

  await writeToStream(dkimVerifier, email as any);

  let domainToVerifyDKIM = domain;
  if (!domainToVerifyDKIM) {
    if (dkimVerifier.headerFrom.length > 1) {
      throw new Error('Multiple From header in email and domain for verification not specified');
    }

    domainToVerifyDKIM = dkimVerifier.headerFrom[0].split('@')[1];
  }

  const dkimResult = dkimVerifier.results.find((d: any) => d.signingDomain === domainToVerifyDKIM);

  if (!dkimResult) {
    throw new Error(`DKIM signature not found for domain ${domainToVerifyDKIM}`);
  }

  dkimResult.headers = dkimVerifier.headers;

  return dkimResult;
}



---
File: /@zk-email/helpers/src/dkim/sanitizers.ts
---

function getHeaderValue(email: string, header: string) {
  const headerStartIndex = email.indexOf(`${header}: `) + header.length + 2;
  const headerEndIndex = email.indexOf('\n', headerStartIndex);
  const headerValue = email.substring(headerStartIndex, headerEndIndex);

  return headerValue;
}

function setHeaderValue(email: string, header: string, value: string) {
  return email.replace(getHeaderValue(email, header), value);
}

// Google sets their own Message-ID and put the original one  in X-Google-Original-Message-ID
// when ARC forwarding
// TODO: Add test for this
function revertGoogleMessageId(email: string): string {
  // (Optional check) This only happens when google does ARC
  if (!email.includes('ARC-Authentication-Results')) {
    return email;
  }

  const googleReplacedMessageId = getHeaderValue(email, 'X-Google-Original-Message-ID');

  if (googleReplacedMessageId) {
    return setHeaderValue(email, 'Message-ID', googleReplacedMessageId);
  }

  return email;
}

// Remove labels inserted to Subject - `[ListName] Newsletter 2024` to `Newsletter 2024`
function removeLabels(email: string): string {
  // Replace Subject: [label] with Subject:
  const sanitized = email.replace(/Subject: \[.*\]/, 'Subject:');
  return sanitized;
}

// Sometimes, newline encodings re-encode \r\n as just \n, so re-insert the \r
// TODO: Add test for this
function insert13Before10(email: string): string {
  const byteArray = new TextEncoder().encode(email);

  const ret = new Uint8Array(byteArray.length + 1000);

  let j = 0;
  for (let i = 0; i < byteArray.length; i++) {
    // Ensure each \n is preceded by a \r
    if (byteArray[i] === 10 && i > 0 && byteArray[i - 1] !== 13) {
      ret[j] = 13;
      j++;
    }
    ret[j] = byteArray[i];
    j++;
  }

  return Buffer.from(ret.slice(0, j).buffer).toString();
}

// Replace `=09` with `\t` in email
// TODO: Add test for this
function sanitizeTabs(email: string): string {
  return email.replace('=09', '\t');
}

const sanitizers = [revertGoogleMessageId, removeLabels, insert13Before10, sanitizeTabs];

export default sanitizers;



---
File: /@zk-email/helpers/src/lib/mailauth/body/index.ts
---

import { SimpleHash } from './simple';
import { RelaxedHash } from './relaxed';

export const dkimBody = (canonicalization: any, ...options: [string, number]) => {
  canonicalization = (canonicalization ?? 'simple/simple').toString().split('/').pop()?.toLowerCase().trim();
  switch (canonicalization) {
    case 'simple':
      return new SimpleHash(...options);
    case 'relaxed':
      return new RelaxedHash(...options);
    default:
      throw new Error('Unknown body canonicalization');
  }
};



---
File: /@zk-email/helpers/src/lib/mailauth/body/relaxed.ts
---

import * as crypto from 'crypto';

const CHAR_CR = 0x0d;
const CHAR_LF = 0x0a;
const CHAR_SPACE = 0x20;
const CHAR_TAB = 0x09;

/**
 * Class for calculating body hash of an email message body stream
 * using the "relaxed" canonicalization
 *
 * @class
 */
export class RelaxedHash {
  byteLength: number;
  bodyHashedBytes: number;
  private remainder: Buffer | boolean;
  private bodyHash: crypto.Hash;
  private maxBodyLength: number;
  private maxSizeReached: boolean;
  private emptyLinesQueue: Array<Buffer>;
  private fullBody: Buffer;

  /**
   * @param {String} [algorithm] Hashing algo, either "sha1" or "sha256"
   * @param {Number} [maxBodyLength] Allowed body length count, the value from the l= parameter
   */
  constructor(algorithm: string, maxBodyLength: number) {
    algorithm = algorithm?.split('-')?.pop()?.toLowerCase() || 'sha256';

    this.bodyHash = crypto.createHash(algorithm);

    this.remainder = false;
    this.byteLength = 0;

    this.bodyHashedBytes = 0;
    this.maxBodyLength = maxBodyLength;

    this.maxSizeReached = false;

    this.emptyLinesQueue = [];

    this.fullBody = Buffer.alloc(0);
  }

  private updateBodyHash(chunk: Buffer) {
    if (this.maxSizeReached) {
      return;
    }

    // the following is needed for the l= option
    if (
      typeof this.maxBodyLength === 'number' &&
      !isNaN(this.maxBodyLength) &&
      this.maxBodyLength >= 0 &&
      this.bodyHashedBytes + chunk.length > this.maxBodyLength
    ) {
      this.maxSizeReached = true;
      if (this.bodyHashedBytes >= this.maxBodyLength) {
        // nothing to do here, skip entire chunk
        return;
      }

      // only use allowed size of bytes
      chunk = chunk.subarray(0, this.maxBodyLength - this.bodyHashedBytes);
    }

    this.bodyHashedBytes += chunk.length;
    this.bodyHash.update(chunk);
    this.fullBody = Buffer.concat([this.fullBody, Buffer.from(chunk)]);

    //process.stdout.write(chunk);
  }

  private drainPendingEmptyLines() {
    if (this.emptyLinesQueue.length) {
      for (let emptyLine of this.emptyLinesQueue) {
        this.updateBodyHash(emptyLine);
      }
      this.emptyLinesQueue = [];
    }
  }

  private pushBodyHash(chunk: Buffer) {
    if (!chunk || !chunk.length) {
      return;
    }

    // remove line endings
    let foundNonLn = false;

    // buffer line endings and empty lines
    for (let i = chunk.length - 1; i >= 0; i--) {
      if (chunk[i] !== CHAR_LF && chunk[i] !== CHAR_CR) {
        this.drainPendingEmptyLines();
        if (i < chunk.length - 1) {
          this.emptyLinesQueue.push(chunk.subarray(i + 1));
          chunk = chunk.subarray(0, i + 1);
        }
        foundNonLn = true;
        break;
      }
    }

    if (!foundNonLn) {
      this.emptyLinesQueue.push(chunk);
      return;
    }

    this.updateBodyHash(chunk);
  }

  fixLineBuffer(line: Buffer) {
    let resultLine = [];

    let nonWspFound = false;
    let prevWsp = false;

    for (let i = line.length - 1; i >= 0; i--) {
      if (line[i] === CHAR_LF) {
        resultLine.unshift(line[i]);
        if (i === 0 || line[i - 1] !== CHAR_CR) {
          // add missing carriage return
          resultLine.unshift(CHAR_CR);
        }
        continue;
      }

      if (line[i] === CHAR_CR) {
        resultLine.unshift(line[i]);
        continue;
      }

      if (line[i] === CHAR_SPACE || line[i] === CHAR_TAB) {
        if (nonWspFound) {
          prevWsp = true;
        }
        continue;
      }

      if (prevWsp) {
        resultLine.unshift(CHAR_SPACE);
        prevWsp = false;
      }

      nonWspFound = true;
      resultLine.unshift(line[i]);
    }

    if (prevWsp && nonWspFound) {
      resultLine.unshift(CHAR_SPACE);
    }

    return Buffer.from(resultLine);
  }

  update(chunk: Buffer | null, final: boolean) {
    this.byteLength += (chunk && chunk.length) || 0;
    if (this.maxSizeReached) {
      return;
    }

    // Canonicalize content by applying a and b in order:
    // a.1. Ignore all whitespace at the end of lines.
    // a.2. Reduce all sequences of WSP within a line to a single SP character.

    // b.1. Ignore all empty lines at the end of the message body.
    // b.2. If the body is non-empty but does not end with a CRLF, a CRLF is added.

    let lineEndPos = -1;
    let lineNeedsFixing = false;
    let cursorPos = 0;

    if (this.remainder && this.remainder instanceof Buffer && this.remainder.length) {
      if (chunk) {
        // concatting chunks might be bad for performance :S
        chunk = Buffer.concat([this.remainder, chunk]);
      } else {
        chunk = this.remainder;
      }
      this.remainder = false;
    }

    if (chunk && chunk.length) {
      for (let pos = 0; pos < chunk.length; pos++) {
        switch (chunk[pos]) {
          case CHAR_LF:
            if (
              !lineNeedsFixing &&
              // previous character is not <CR>
              ((pos >= 1 && chunk[pos - 1] !== CHAR_CR) ||
                // LF is the first byte on the line
                pos === 0 ||
                // there's a space before line break
                (pos >= 2 && chunk[pos - 1] === CHAR_CR && chunk[pos - 2] === CHAR_SPACE))
            ) {
              lineNeedsFixing = true;
            }

            // line break
            if (lineNeedsFixing) {
              // emit pending bytes up to the last line break before current line
              if (lineEndPos >= 0 && lineEndPos >= cursorPos) {
                let chunkPart = chunk.subarray(cursorPos, lineEndPos + 1);
                this.pushBodyHash(chunkPart);
              }

              let line = chunk.subarray(lineEndPos + 1, pos + 1);
              this.pushBodyHash(this.fixLineBuffer(line));

              lineNeedsFixing = false;

              // move cursor to the start of next line
              cursorPos = pos + 1;
            }

            lineEndPos = pos;

            break;

          case CHAR_SPACE:
            if (!lineNeedsFixing && pos && chunk[pos - 1] === CHAR_SPACE) {
              lineNeedsFixing = true;
            }
            break;

          case CHAR_TAB:
            // non-space WSP always needs replacing
            lineNeedsFixing = true;
            break;

          default:
        }
      }
    }

    if (chunk && cursorPos < chunk.length && cursorPos !== lineEndPos) {
      // emit data from chunk

      let chunkPart = chunk.subarray(cursorPos, lineEndPos + 1);

      if (chunkPart.length) {
        this.pushBodyHash(lineNeedsFixing ? this.fixLineBuffer(chunkPart) : chunkPart);
        lineNeedsFixing = false;
      }

      cursorPos = lineEndPos + 1;
    }

    if (chunk && !final && cursorPos < chunk.length) {
      this.remainder = chunk.subarray(cursorPos);
    }

    if (final) {
      let chunkPart = (cursorPos && chunk && chunk.subarray(cursorPos)) || chunk;
      if (chunkPart && chunkPart.length) {
        this.pushBodyHash(lineNeedsFixing ? this.fixLineBuffer(chunkPart) : chunkPart);
        lineNeedsFixing = false;
      }

      if (this.bodyHashedBytes) {
        // terminating line break for non-empty messages
        this.updateBodyHash(Buffer.from([CHAR_CR, CHAR_LF]));
      }
    }
  }

  digest(encoding: crypto.BinaryToTextEncoding) {
    this.update(null, true);

    // finalize
    return this.bodyHash.digest(encoding);
  }
}

/*
let fs = require('fs');

const getBody = message => {
    message = message.toString('binary');
    let match = message.match(/\r?\n\r?\n/);
    if (match) {
        message = message.substr(match.index + match[0].length);
    }
    return Buffer.from(message, 'binary');
};

let s = fs.readFileSync(process.argv[2]);

let k = new RelaxedHash('rsa-sha256', -1);

for (let byte of getBody(s)) {
    k.update(Buffer.from([byte]));
}

console.error(k.digest('base64'));
console.error(k.byteLength, k.bodyHashedBytes);
*/



---
File: /@zk-email/helpers/src/lib/mailauth/body/simple.ts
---

import * as crypto from 'crypto';

/**
 * Class for calculating body hash of an email message body stream
 * using the "simple" canonicalization
 *
 * @class
 */
export class SimpleHash {
  byteLength: number;
  bodyHashedBytes: number;
  private remainder: Buffer[];
  private bodyHash: crypto.Hash;
  private maxBodyLength: number;
  private fullBody: Buffer;
  private lastNewline: boolean;
  /**
   * @param {String} [algorithm] Hashing algo, either "sha1" or "sha256"
   * @param {Number} [maxBodyLength] Allowed body length count, the value from the l= parameter
   */
  constructor(algorithm: string, maxBodyLength: number) {
    algorithm = algorithm?.split('-')?.pop() || 'sha256';
    this.bodyHash = crypto.createHash(algorithm);

    this.remainder = [];
    this.byteLength = 0;

    this.bodyHashedBytes = 0;
    this.maxBodyLength = maxBodyLength;

    this.lastNewline = false;

    this.fullBody = Buffer.alloc(0);
  }

  private updateBodyHash(chunk: Buffer) {
    // the following is needed for l= option
    if (
      typeof this.maxBodyLength === 'number' &&
      !isNaN(this.maxBodyLength) &&
      this.maxBodyLength >= 0 &&
      this.bodyHashedBytes + chunk.length > this.maxBodyLength
    ) {
      if (this.bodyHashedBytes >= this.maxBodyLength) {
        // nothing to do here, skip entire chunk
        return;
      }
      // only use allowed size of bytes
      chunk = chunk.subarray(0, this.maxBodyLength - this.bodyHashedBytes);
    }

    this.bodyHashedBytes += chunk.length;
    this.bodyHash.update(chunk);
    this.fullBody = Buffer.concat([this.fullBody, chunk]);

    //process.stdout.write(chunk);
  }

  update(chunk: Buffer) {
    if (this.remainder.length) {
      // see if we can release the last remainder
      for (let i = 0; i < chunk.length; i++) {
        let c = chunk[i];
        if (c !== 0x0a && c !== 0x0d) {
          // found non-line terminator byte, can release previous chunk
          for (let remainderChunk of this.remainder) {
            this.updateBodyHash(remainderChunk);
          }
          this.remainder = [];
        }
      }
    }

    // find line terminators from the end of chunk
    let matchStart: boolean | number = false;
    for (let i = chunk.length - 1; i >= 0; i--) {
      let c = chunk[i];
      if (c === 0x0a || c === 0x0d) {
        // stop looking
        matchStart = i;
      } else {
        break;
      }
    }

    if (matchStart === 0) {
      // nothing but newlines in this chunk
      this.remainder.push(chunk);
      return;
    } else if (matchStart !== false) {
      this.remainder.push(chunk.subarray(matchStart));
      chunk = chunk.subarray(0, matchStart);
    }

    this.updateBodyHash(chunk);
    this.lastNewline = chunk[chunk.length - 1] === 0x0a;
  }

  digest(encoding: crypto.BinaryToTextEncoding) {
    if (!this.lastNewline || !this.bodyHashedBytes) {
      // emit empty line buffer to keep the stream flowing
      this.updateBodyHash(Buffer.from('\r\n'));
    }

    return this.bodyHash.digest(encoding);
  }
}



---
File: /@zk-email/helpers/src/lib/mailauth/header/index.ts
---

import { Options, SignatureType, SigningHeaderLines } from '../dkim-verifier';
import { relaxedHeaders } from './relaxed';
import { simpleHeaders } from './simple';

export const generateCanonicalizedHeader = (
  type: SignatureType,
  signingHeaderLines: SigningHeaderLines,
  options: Options,
) => {
  options = options || {};
  let canonicalization = (options.canonicalization || 'simple/simple')
    .toString()
    ?.split('/')
    ?.shift()
    ?.toLowerCase()
    .trim();
  switch (canonicalization) {
    case 'simple':
      return simpleHeaders(type, signingHeaderLines, options);
    case 'relaxed':
      return relaxedHeaders(type, signingHeaderLines, options);
    default:
      throw new Error('Unknown header canonicalization');
  }
};



---
File: /@zk-email/helpers/src/lib/mailauth/header/relaxed.ts
---

import type { Options, SignatureType, SigningHeaderLines } from '../dkim-verifier';
import { formatSignatureHeaderLine, formatRelaxedLine } from '../tools';

// generate headers for signing
export const relaxedHeaders = (type: SignatureType, signingHeaderLines: SigningHeaderLines, options: Options) => {
  let {
    signatureHeaderLine,
    signingDomain,
    selector,
    algorithm,
    canonicalization,
    bodyHash,
    signTime,
    signature,
    instance,
    bodyHashedBytes,
  } = options || {};
  let chunks = [];

  for (let signedHeaderLine of signingHeaderLines.headers) {
    chunks.push(formatRelaxedLine(signedHeaderLine.line, '\r\n'));
  }

  let opts: boolean | Record<string, unknown> = false;

  if (!signatureHeaderLine) {
    opts = {
      a: algorithm,
      c: canonicalization,
      s: selector,
      d: signingDomain,
      h: signingHeaderLines.keys,
      bh: bodyHash,
    };

    if (typeof bodyHashedBytes === 'number') {
      opts.l = bodyHashedBytes;
    }

    if (instance) {
      // ARC only
      opts.i = instance;
    }

    if (signTime) {
      if (typeof signTime === 'string' || typeof signTime === 'number') {
        signTime = new Date(signTime);
      }

      if (Object.prototype.toString.call(signTime) === '[object Date]' && signTime.toString() !== 'Invalid Date') {
        // we need a unix timestamp value
        signTime = Math.round(signTime.getTime() / 1000);
        opts.t = signTime;
      }
    }

    signatureHeaderLine = formatSignatureHeaderLine(
      type,
      Object.assign(
        {
          // make sure that b= always has a value, otherwise folding would be different
          b: signature || 'a'.repeat(73),
        },
        opts,
      ) as Record<string, string | boolean>,
      true,
    );
  }

  chunks.push(
    Buffer.from(
      formatRelaxedLine(signatureHeaderLine)
        .toString('binary')
        // remove value from b= key
        .replace(/([;:\s]+b=)[^;]+/, '$1'),
      'binary',
    ),
  );

  return { canonicalizedHeader: Buffer.concat(chunks), signatureHeaderLine, dkimHeaderOpts: opts };
};



---
File: /@zk-email/helpers/src/lib/mailauth/header/simple.ts
---

import type { Options, SignatureType, SigningHeaderLines } from '../dkim-verifier';
import { formatSignatureHeaderLine } from '../tools';

const formatSimpleLine = (line: Buffer | string, suffix?: string) =>
  Buffer.from(line.toString('binary') + (suffix ? suffix : ''), 'binary');

// generate headers for signing
export const simpleHeaders = (type: SignatureType, signingHeaderLines: SigningHeaderLines, options: Options) => {
  let {
    signatureHeaderLine,
    signingDomain,
    selector,
    algorithm,
    canonicalization,
    bodyHash,
    signTime,
    signature,
    instance,
    bodyHashedBytes,
  } = options || {};
  let chunks = [];

  for (let signedHeaderLine of signingHeaderLines.headers) {
    chunks.push(formatSimpleLine(signedHeaderLine.line, '\r\n'));
  }

  let opts: boolean | Record<string, any> = false;

  if (!signatureHeaderLine) {
    opts = {
      a: algorithm,
      c: canonicalization,
      s: selector,
      d: signingDomain,
      h: signingHeaderLines.keys,
      bh: bodyHash,
    };

    if (typeof bodyHashedBytes === 'number') {
      opts.l = bodyHashedBytes;
    }

    if (instance) {
      // ARC only (should never happen thoug as simple algo is not allowed)
      opts.i = instance;
    }

    if (signTime) {
      if (typeof signTime === 'string' || typeof signTime === 'number') {
        signTime = new Date(signTime);
      }

      if (Object.prototype.toString.call(signTime) === '[object Date]' && signTime.toString() !== 'Invalid Date') {
        // we need a unix timestamp value
        signTime = Math.round(signTime.getTime() / 1000);
        opts.t = signTime;
      }
    }

    signatureHeaderLine = formatSignatureHeaderLine(
      type,
      Object.assign(
        {
          // make sure that b= has a value, otherwise folding would be different
          b: signature || 'a'.repeat(73),
        },
        opts,
      ) as Record<string, string | boolean>,
      true,
    );
  }

  chunks.push(
    Buffer.from(
      formatSimpleLine(signatureHeaderLine)
        .toString('binary')
        // remove value from b= key
        .replace(/([;:\s]+b=)[^;]+/, '$1'),
      'binary',
    ),
  );

  return { canonicalizedHeader: Buffer.concat(chunks), signatureHeaderLine, dkimHeaderOpts: opts };
};



---
File: /@zk-email/helpers/src/lib/mailauth/dkim-verifier.ts
---

const IS_BROWSER = typeof window !== 'undefined';

// @ts-ignore
import addressparser from 'addressparser';
import * as crypto from 'crypto';
import {
  getSigningHeaderLines,
  getPublicKey,
  parseDkimHeaders,
  formatAuthHeaderRow,
  getAlignment,
  parseHeaders,
} from './tools';
import { MessageParser } from './message-parser';
import { dkimBody } from './body';
import { generateCanonicalizedHeader } from './header';

export type SignatureType = 'DKIM' | 'ARC' | 'AS';

export type ParsedHeaders = ReturnType<typeof parseHeaders>;

export type Parsed = ParsedHeaders['parsed'][0];

export type ParseDkimHeaders = ReturnType<typeof parseDkimHeaders>;

export type SigningHeaderLines = ReturnType<typeof getSigningHeaderLines>;

export interface Options {
  signatureHeaderLine: string;
  signingDomain?: string;
  selector?: string;
  algorithm?: string;
  canonicalization: string;
  bodyHash?: string;
  signTime?: string | number | Date;
  signature?: string;
  instance: string | boolean;
  bodyHashedBytes?: string;
}

export class DkimVerifier extends MessageParser {
  envelopeFrom: string | boolean;
  headerFrom: string[];
  results: { [key: string]: any }[];
  private options: Record<string, any>;
  private resolver: (...args: [name: string, type: string]) => Promise<any>;
  private minBitLength: number;
  private signatureHeaders: ParseDkimHeaders[] & { [key: string]: any }[];
  private bodyHashes: Map<string, any>;
  private arc: { chain: false };
  private seal: { bodyHash: string };
  private sealBodyHashKey: string = '';
  constructor(options: Record<string, any>) {
    super();

    this.options = options || {};
    this.resolver = this.options.resolver;
    this.minBitLength = this.options.minBitLength;

    this.results = [];

    this.signatureHeaders = [] as any;
    this.bodyHashes = new Map();

    this.headerFrom = [];
    this.envelopeFrom = false;

    // ARC verification info
    this.arc = { chain: false };

    // should we also seal this message using ARC
    this.seal = this.options.seal;

    if (this.seal) {
      // calculate body hash for the seal
      let bodyCanon = 'relaxed';
      let hashAlgo = 'sha256';
      this.sealBodyHashKey = `${bodyCanon}:${hashAlgo}:`;
      this.bodyHashes.set(this.sealBodyHashKey, dkimBody(bodyCanon, hashAlgo, 0));
    }
  }

  async messageHeaders(headers: ParsedHeaders) {
    this.headers = headers;

    this.signatureHeaders = headers.parsed
      .filter((h) => h.key === 'dkim-signature')
      .map((h) => {
        const value: ParseDkimHeaders & { [key: string]: any } = parseDkimHeaders(h.line);
        value.type = 'DKIM';
        return value;
      });

    let fromHeaders = headers?.parsed?.filter((h) => h.key === 'from');
    for (const fromHeader of fromHeaders) {
      let fromHeaderString = fromHeader.line.toString();
      let splitterPos = fromHeaderString.indexOf(':');
      if (splitterPos >= 0) {
        fromHeaderString = fromHeaderString.substr(splitterPos + 1);
      }
      let from = addressparser(fromHeaderString.trim());
      for (let addr of from) {
        if (addr && addr.address) {
          this.headerFrom.push(addr.address);
        }
      }
    }

    if (this.options.sender) {
      let returnPath = addressparser(this.options.sender);
      this.envelopeFrom = returnPath.length && returnPath[0].address ? returnPath[0].address : false;
    } else {
      let returnPathHeader = headers.parsed.filter((h) => h.key === 'return-path').pop();
      if (returnPathHeader) {
        let returnPathHeaderString = returnPathHeader.line.toString();
        let splitterPos = returnPathHeaderString.indexOf(':');
        if (splitterPos >= 0) {
          returnPathHeaderString = returnPathHeaderString.substr(splitterPos + 1);
        }
        let returnPath = addressparser(returnPathHeaderString.trim());
        this.envelopeFrom = returnPath.length && returnPath[0].address ? returnPath[0].address : false;
      }
    }

    for (let signatureHeader of this.signatureHeaders) {
      signatureHeader.algorithm = signatureHeader.parsed?.a?.value || '';
      signatureHeader.signAlgo = signatureHeader.algorithm.split('-').shift().toLowerCase().trim();
      signatureHeader.hashAlgo = signatureHeader.algorithm.split('-').pop().toLowerCase().trim();

      signatureHeader.canonicalization = signatureHeader.parsed?.c?.value || '';
      signatureHeader.headerCanon =
        signatureHeader.canonicalization.split('/').shift().toLowerCase().trim() || 'simple';
      // if body canonicalization is not set, then defaults to 'simple'
      signatureHeader.bodyCanon = (signatureHeader.canonicalization.split('/')[1] || 'simple').toLowerCase().trim();

      signatureHeader.signingDomain = signatureHeader.parsed?.d?.value || '';
      signatureHeader.selector = signatureHeader.parsed?.s?.value || '';

      signatureHeader.maxBodyLength =
        signatureHeader.parsed?.l?.value && !isNaN(signatureHeader.parsed?.l?.value)
          ? signatureHeader.parsed?.l?.value
          : '';

      const validSignAlgo = ['rsa', 'ed25519'];
      const validHeaderAlgo = signatureHeader.type === 'DKIM' ? ['sha256', 'sha1'] : ['sha256'];
      const validHeaderCanon = signatureHeader.type !== 'AS' ? ['relaxed', 'simple'] : ['relaxed'];
      const validBodyCanon = signatureHeader.type !== 'AS' ? ['relaxed', 'simple'] : ['relaxed'];

      if (
        !validSignAlgo.includes(signatureHeader.signAlgo) ||
        !validHeaderAlgo.includes(signatureHeader.hashAlgo) ||
        !validHeaderCanon.includes(signatureHeader.headerCanon) ||
        !validBodyCanon.includes(signatureHeader.bodyCanon) ||
        !signatureHeader.signingDomain ||
        !signatureHeader.selector
      ) {
        signatureHeader.skip = true;
        continue;
      }

      signatureHeader.bodyHashKey = [
        signatureHeader.bodyCanon,
        signatureHeader.hashAlgo,
        signatureHeader.maxBodyLength,
      ].join(':');
      if (!this.bodyHashes.has(signatureHeader.bodyHashKey)) {
        this.bodyHashes.set(
          signatureHeader.bodyHashKey,
          dkimBody(signatureHeader.bodyCanon, signatureHeader.hashAlgo, signatureHeader.maxBodyLength),
        );
      }
    }
  }

  async nextChunk(chunk: Buffer) {
    for (let bodyHash of this.bodyHashes.values()) {
      bodyHash.update(chunk);
    }
  }

  async finalChunk() {
    try {
      if (!this.headers || !this.bodyHashes.size) {
        return;
      }

      // convert bodyHashes from hash objects to base64 strings
      for (let [key, bodyHash] of this.bodyHashes.entries()) {
        this.bodyHashes.get(key).hash = bodyHash.digest('base64');
      }

      for (let signatureHeader of this.signatureHeaders) {
        if (signatureHeader.skip) {
          // TODO: add failing header line?
          continue;
        }

        let signingHeaderLines = getSigningHeaderLines(
          (
            this.headers as {
              parsed: { key: string | null; casedKey: string | undefined; line: Buffer }[];
              original: Buffer;
            }
          ).parsed,
          signatureHeader.parsed?.h?.value,
          true,
        );

        let { canonicalizedHeader } = generateCanonicalizedHeader(signatureHeader.type, signingHeaderLines as any, {
          signatureHeaderLine: signatureHeader.original as string,
          canonicalization: signatureHeader.canonicalization,
          instance: ['ARC', 'AS'].includes(signatureHeader.type) ? signatureHeader.parsed?.i?.value : false,
        });

        let signingHeaders = {
          keys: signingHeaderLines.keys,
          headers: signingHeaderLines.headers.map((l) => l.line.toString()),
        };

        let publicKey, rr, modulusLength;
        let status: { [key: string]: any } = {
          result: 'neutral',
          comment: false,
          // ptype properties
          header: {
            // signing domain
            i: signatureHeader.signingDomain ? `@${signatureHeader.signingDomain}` : false,
            // dkim selector
            s: signatureHeader.selector,
            // algo
            a: signatureHeader.parsed?.a?.value,
            // signature value
            b: signatureHeader.parsed?.b?.value ? `${signatureHeader.parsed?.b?.value.substr(0, 8)}` : false,
          },
        };

        if (signatureHeader.type === 'DKIM' && this.headerFrom?.length) {
          status.aligned = this.headerFrom?.length
            ? getAlignment(this.headerFrom[0] ?? ''.split('@')?.pop(), [signatureHeader.signingDomain])
            : false;
        }

        let bodyHashObj = this.bodyHashes.get(signatureHeader.bodyHashKey);
        let bodyHash = bodyHashObj?.hash;
        if (signatureHeader.parsed?.bh?.value !== bodyHash) {
          status.result = 'neutral';
          status.comment = `body hash did not verify`;
        } else {
          try {
            let res = await getPublicKey(
              signatureHeader.type,
              `${signatureHeader.selector}._domainkey.${signatureHeader.signingDomain}`,
              this.minBitLength,
              this.resolver,
            );

            publicKey = res?.publicKey;
            rr = res?.rr;
            modulusLength = res?.modulusLength;

            try {
              let ver_result = false;
              if (!IS_BROWSER) {
                ver_result = crypto.verify(
                  signatureHeader.signAlgo === 'rsa' ? signatureHeader.algorithm : null,
                  canonicalizedHeader,
                  publicKey,
                  Buffer.from(signatureHeader.parsed?.b?.value, 'base64'),
                );
              } else {
                let ver = crypto.createVerify('RSA-SHA256');
                ver.update(canonicalizedHeader);
                ver_result = ver.verify(
                  { key: publicKey.toString(), format: 'pem' },
                  Buffer.from(signatureHeader.parsed?.b?.value, 'base64'),
                );
              }

              status.signedHeaders = canonicalizedHeader;
              status.result = ver_result ? 'pass' : 'fail';

              if (status?.result === 'fail') {
                status.comment = 'bad signature';
              }
            } catch (err: any) {
              status.comment = err.message;
              status.result = 'neutral';
            }
          } catch (err: any) {
            if (err.rr) {
              rr = err.rr;
            }

            switch (err.code) {
              case 'ENOTFOUND':
              case 'ENODATA':
                status.result = 'neutral';
                status.comment = `no key`;
                break;

              case 'EINVALIDVER':
                status.result = 'neutral';
                status.comment = `unknown key version`;
                break;

              case 'EINVALIDTYPE':
                status.result = 'neutral';
                status.comment = `unknown key type`;
                break;

              case 'EINVALIDVAL':
                status.result = 'neutral';
                status.comment = `invalid public key`;
                break;

              case 'ESHORTKEY':
                status.result = 'policy';
                if (!status.policy) {
                  status.policy = {};
                }
                status.policy['dkim-rules'] = `weak-key`;
                break;

              default:
                status.result = 'temperror';
                status.comment = `DNS failure: ${err.code || err.message}`;
            }
          }
        }

        signatureHeader.bodyHashedBytes = this.bodyHashes.get(signatureHeader.bodyHashKey)?.bodyHashedBytes;

        if (
          typeof signatureHeader.maxBodyLength === 'number' &&
          signatureHeader.maxBodyLength !== signatureHeader.bodyHashedBytes
        ) {
          status.result = 'fail';
          status.comment = `invalid body length ${signatureHeader.bodyHashedBytes}`;
        }

        let result: { [key: string]: any } = {
          signingDomain: signatureHeader.signingDomain,
          selector: signatureHeader.selector,
          signature: signatureHeader.parsed?.b?.value,
          algo: signatureHeader.parsed?.a?.value,
          format: signatureHeader.parsed?.c?.value,
          bodyHash,
          bodyHashExpecting: signatureHeader.parsed?.bh?.value,
          body: bodyHashObj?.fullBody,
          signingHeaders,
          status,
        };

        if (typeof signatureHeader.bodyHashedBytes === 'number') {
          result.canonBodyLength = signatureHeader.bodyHashedBytes;
        }

        if (typeof signatureHeader.maxBodyLength === 'number') {
          result.bodyLengthCount = signatureHeader.maxBodyLength;
        }

        if (publicKey) {
          result.publicKey = publicKey.toString();
        }

        if (modulusLength) {
          result.modulusLength = modulusLength;
        }

        if (rr) {
          result.rr = rr;
        }

        if (typeof result.status.comment === 'boolean') {
          delete result.status.comment;
        }

        switch (signatureHeader.type) {
          case 'ARC':
            throw Error('ARC not possible');
            break;
          case 'DKIM':
          default:
            this.results.push(result);
            break;
        }
      }
    } finally {
      if (!this.results.length) {
        this.results.push({
          status: {
            result: 'none',
            comment: 'message not signed',
          },
        });
      }

      this.results.forEach((result) => {
        result.info = formatAuthHeaderRow('dkim', result.status);
      });
    }

    if (
      this.seal &&
      this.bodyHashes.has(this.sealBodyHashKey) &&
      typeof this.bodyHashes.get(this.sealBodyHashKey)?.hash === 'string'
    ) {
      this.seal.bodyHash = this.bodyHashes.get(this.sealBodyHashKey).hash;
    }
  }
}



---
File: /@zk-email/helpers/src/lib/mailauth/message-parser.ts
---

// Calculates relaxed body hash for a message body stream
import { Writable, WritableOptions } from 'stream';
import { parseHeaders } from './tools';
import type { ParsedHeaders } from './dkim-verifier';

/**
 * Class for separating header from body
 *
 * @class
 * @extends Writable
 */
export class MessageParser extends Writable {
  byteLength: number;
  headers: ParsedHeaders | boolean;
  private state: string;
  private stateBytes: unknown[];
  private headerChunks: Buffer[];
  private lastByte: number = 0;
  constructor(options?: WritableOptions) {
    super(options);

    this.byteLength = 0;

    this.state = 'header';
    this.stateBytes = [];

    this.headers = false;
    this.headerChunks = [];
  }

  async nextChunk(...args: any) {
    // Override in child class
  }

  async finalChunk(...args: any) {
    // Override in child class
  }

  async messageHeaders(headers: ParsedHeaders) {
    // Override in child class
  }

  async processChunk(chunk: Buffer) {
    if (!chunk || !chunk.length) {
      return;
    }

    if (this.state === 'header') {
      // wait until we have found body part
      for (let i = 0; i < chunk.length; i++) {
        let c = chunk[i];
        this.stateBytes.push(c);
        if (this.stateBytes.length > 4) {
          this.stateBytes = this.stateBytes.slice(-4);
        }

        let b0 = this.stateBytes[this.stateBytes.length - 1];
        let b1 = this.stateBytes.length > 1 && this.stateBytes[this.stateBytes.length - 2];
        let b2 = this.stateBytes.length > 2 && this.stateBytes[this.stateBytes.length - 3];

        if (b0 === 0x0a && (b1 === 0x0a || (b1 === 0x0d && b2 === 0x0a))) {
          // found header ending
          this.state = 'body';
          if (i === chunk.length - 1) {
            //end of chunk
            this.headerChunks.push(chunk);
            this.headers = parseHeaders(Buffer.concat(this.headerChunks));
            await this.messageHeaders(this.headers);
            return;
          }
          this.headerChunks.push(chunk.subarray(0, i + 1));
          this.headers = parseHeaders(Buffer.concat(this.headerChunks));
          await this.messageHeaders(this.headers);
          chunk = chunk.subarray(i + 1);
          break;
        }
      }
    }

    if (this.state !== 'body') {
      this.headerChunks.push(chunk);
      return;
    }

    await this.nextChunk(chunk);
  }

  *ensureLinebreaks(input: Buffer) {
    let pos = 0;
    for (let i = 0; i < input.length; i++) {
      let c = input[i];
      if (c !== 0x0a) {
        this.lastByte = c;
      } else if (this.lastByte !== 0x0d) {
        // emit line break
        let buf;
        if (i === 0 || pos === i) {
          buf = Buffer.from('\r\n');
        } else {
          buf = Buffer.concat([input.subarray(pos, i), Buffer.from('\r\n')]);
        }
        yield buf;

        pos = i + 1;
      }
    }
    if (pos === 0) {
      yield input;
    } else if (pos < input.length) {
      let buf = input.subarray(pos);
      yield buf;
    }
  }

  async writeAsync(chunk: any, encoding: BufferEncoding) {
    if (!chunk || !chunk.length) {
      return;
    }

    if (typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding);
    }

    for (let partialChunk of this.ensureLinebreaks(chunk)) {
      // separate chunk is emitted for every line that uses \n instead of \r\n
      await this.processChunk(partialChunk);
      this.byteLength += partialChunk.length;
    }
  }

  _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void) {
    this.writeAsync(chunk, encoding)
      .then(() => callback())
      .catch((err) => callback(err));
  }

  async finish() {
    // generate final hash and emit it
    await this.finalChunk();

    if (!this.headers && this.headerChunks.length) {
      this.headers = parseHeaders(Buffer.concat(this.headerChunks));
      await this.messageHeaders(this.headers);
    }
  }

  _final(callback: (error?: Error | null) => void) {
    this.finish()
      .then(() => callback())
      .catch((err) => callback(err));
  }
}



---
File: /@zk-email/helpers/src/lib/mailauth/parse-dkim-headers.ts
---

// NB! fails to properly parse nested comments (should be rare enough though)

interface Part {
  [key: string]: string;
}

const valueParser = (str: string) => {
  let line = str.replace(/\s+/g, ' ').trim();

  let parts: Part[] = [];
  let lastState: string | boolean = false;

  const createPart = () => {
    let part: Part = {
      key: '',
      value: '',
    };
    parts.push(part);
    return part;
  };

  const parse = () => {
    let state = 'key';
    let escaped;
    let quote;

    let curPart = createPart();

    for (let i = 0; i < line.length; i++) {
      let c = line.charAt(i);

      switch (state) {
        // @ts-ignore
        case 'key':
          if (c === '=') {
            state = 'value';
            break;
          }
        // falls through

        case 'value': {
          if (escaped === true) {
            curPart[state] += c;
            break;
          }

          switch (c) {
            case ' ':
              // start new part
              curPart = createPart();
              state = 'key';
              break;

            case '\\':
              escaped = true;
              break;

            case '"':
            case "'":
              lastState = state;
              state = 'quoted';
              quote = c;
              break;

            default:
              curPart[state] += c;
              break;
          }

          break;
        }

        case 'quoted':
          if (escaped === true && typeof lastState === 'string') {
            curPart[lastState] += c;
            break;
          }

          switch (c) {
            case '\\':
              escaped = true;
              break;

            case quote:
              state = lastState as string;
              break;

            default:
              if (typeof lastState === 'string') {
                curPart[lastState] += c;
              }
              break;
          }

          break;
      }
    }

    let result: { [key: string]: any } = {
      value: parts[0].key,
    };
    parts.slice(1).forEach((part) => {
      if (part.key || part.value) {
        let path = part.key.split('.');
        let curRes = result;
        let final = path.pop();
        for (let p of path) {
          if (typeof curRes[p] !== 'object' || !curRes[p]) {
            curRes[p] = {};
          }
          curRes = curRes[p];
        }
        curRes[final ?? ''] = part.value;
      }
    });

    return result;
  };

  return parse();
};

const headerParser = (buf: Buffer | string) => {
  let line = (buf || '').toString().trim();
  let splitterPos = line.indexOf(':');
  let headerKey: string;
  if (splitterPos >= 0) {
    headerKey = line.substr(0, splitterPos).trim().toLowerCase();
    line = line.substr(splitterPos + 1).trim();
  }

  let parts: { [key: string]: any }[] = [];
  let lastState: string | boolean = false;

  const createPart = (): { [key: string]: string | boolean } => {
    let part = {
      key: '',
      value: '',
      comment: '',
      hasValue: false,
    };
    parts.push(part);
    return part;
  };

  const parse = () => {
    let state = 'key';
    let escaped;
    let quote;

    let curPart = createPart();

    for (let i = 0; i < line.length; i++) {
      let c = line.charAt(i);

      switch (state) {
        // @ts-ignore
        case 'key':
          if (c === '=') {
            state = 'value';
            curPart.hasValue = true;
            break;
          }
        // falls through

        case 'value': {
          if (escaped === true) {
            curPart[state] += c;
          }

          switch (c) {
            case ';':
              // start new part
              curPart = createPart();
              state = 'key';
              break;

            case '\\':
              escaped = true;
              break;

            case '(':
              lastState = state;
              state = 'comment';
              break;

            case '"':
            case "'":
              lastState = state;
              curPart[state] += c;
              state = 'quoted';
              quote = c;
              break;

            default:
              curPart[state] += c;
              break;
          }

          break;
        }

        case 'comment':
          switch (c) {
            case '\\':
              escaped = true;
              break;

            case ')':
              state = lastState as string;
              break;

            default:
              curPart[state] += c;
              break;
          }

          break;

        case 'quoted':
          switch (c) {
            case '\\':
              escaped = true;
              break;
            // @ts-ignore
            case quote:
              state = lastState as string;
            // falls through

            default:
              if (typeof lastState === 'string') {
                curPart[lastState] += c;
              }
              break;
          }

          break;
      }
    }

    for (let i = parts.length - 1; i >= 0; i--) {
      for (let key of Object.keys(parts[i])) {
        if (typeof parts[i][key] === 'string') {
          parts[i][key] = parts[i][key].replace(/\s+/g, ' ').trim();
        }
      }

      parts[i].key = parts[i].key.toLowerCase();

      if (!parts[i].key) {
        // remove empty value
        parts.splice(i, 1);
      } else if (['bh', 'b', 'p', 'h'].includes(parts[i].key)) {
        // remove unneeded whitespace
        parts[i].value = parts[i].value?.replace(/\s+/g, '');
      } else if (['l', 'v', 't'].includes(parts[i].key) && !isNaN(parts[i].value)) {
        parts[i].value = Number(parts[i].value);
      } else if (parts[i].key === 'i' && /^arc-/i.test(headerKey)) {
        parts[i].value = Number(parts[i].value);
      }
    }

    let result: { [key: string]: any } = {
      header: headerKey,
    };

    for (let i = 0; i < parts.length; i++) {
      // find the first entry with key only and use it as the default value
      if (parts[i].key && !parts[i].hasValue) {
        result.value = parts[i].key;
        parts.splice(i, 1);
        break;
      }
    }

    parts.forEach((part) => {
      let entry: { [key: string]: any } = {
        value: part.value,
      };

      if (
        ['arc-authentication-results', 'authentication-results'].includes(headerKey) &&
        typeof part.value === 'string'
      ) {
        // parse value into subparts as well
        entry = Object.assign(entry, valueParser(entry.value));
      }

      if (part.comment) {
        entry.comment = part.comment;
      }

      if (['arc-authentication-results', 'authentication-results'].includes(headerKey) && part.key === 'dkim') {
        if (!result[part.key]) {
          result[part.key] = [];
        }
        if (Array.isArray(result[part.key])) {
          result[part.key].push(entry);
        }
      } else {
        result[part.key] = entry;
      }
    });

    return result;
  };

  return { parsed: parse(), original: buf };
};

export default headerParser;



---
File: /@zk-email/helpers/src/lib/mailauth/tools.ts
---

// @ts-ignore
import libmime from 'libmime';
// @ts-ignore
import psl from 'psl';
import { setImmediate } from 'timers';
import { pki } from 'node-forge';
import punycode from 'punycode';
import crypto, { KeyObject } from 'crypto';
import parseDkimHeaders from './parse-dkim-headers';
import { DkimVerifier } from './dkim-verifier';
import type { Parsed, SignatureType } from './dkim-verifier';

const IS_BROWSER = typeof window !== 'undefined';

export const defaultDKIMFieldNames =
  'From:Sender:Reply-To:Subject:Date:Message-ID:To:' +
  'Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:' +
  'Content-Description:Resent-Date:Resent-From:Resent-Sender:' +
  'Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:' +
  'List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:' +
  'List-Owner:List-Archive:BIMI-Selector';

const keyOrderingDKIM = ['v', 'a', 'c', 'd', 'h', 'i', 'l', 'q', 's', 't', 'x', 'z', 'bh', 'b'];

export const writeToStream = async (
  stream: DkimVerifier,
  input: Buffer & { pipe: (...args: any) => void; on: (...args: any) => void },
  chunkSize: number = 0,
) => {
  chunkSize = chunkSize || 64 * 1024;

  if (typeof input === 'string') {
    input = Buffer.from(input) as Buffer & {
      pipe: (...args: any) => void;
      on: (...args: any) => void;
    };
  }

  return new Promise((resolve, reject) => {
    if (typeof input?.on === 'function') {
      // pipe as stream
      console.log('pipe');
      input.pipe(stream);
      input.on('error', reject);
    } else {
      let pos = 0;
      let writeChunk = () => {
        if (pos >= input.length) {
          return stream.end();
        }

        let chunk;
        if (pos + chunkSize >= input.length) {
          chunk = input.subarray(pos);
        } else {
          chunk = input.subarray(pos, pos + chunkSize);
        }
        pos += chunk.length;

        if (stream.write(chunk) === false) {
          stream.once('drain', () => writeChunk());
          return;
        }
        setImmediate(writeChunk);
      };
      setImmediate(writeChunk);
    }

    stream.on('end', resolve);
    stream.on('finish', resolve);
    stream.on('error', reject);
  });
};

export const parseHeaders = (buf: Buffer) => {
  let rows: string[][] = buf
    .toString('binary')
    .replace(/[\r\n]+$/, '')
    .split(/\r?\n/)
    .map((row) => [row]);
  for (let i = rows.length - 1; i >= 0; i--) {
    if (i > 0 && /^\s/.test(rows[i][0])) {
      rows[i - 1] = rows[i - 1].concat(rows[i]);
      rows.splice(i, 1);
    }
  }

  const mappedRows: {
    key: string | null;
    casedKey: string | undefined;
    line: Buffer;
  }[] = rows.map((row) => {
    const str = row.join('\r\n');
    let key: RegExpMatchArray | string | null = str.match(/^[^:]+/);
    let casedKey;
    if (key) {
      casedKey = key[0].trim();
      key = casedKey.toLowerCase();
    }

    return { key, casedKey, line: Buffer.from(str, 'binary') };
  });

  return { parsed: mappedRows, original: buf };
};

export const getSigningHeaderLines = (parsedHeaders: Parsed[], fieldNames: string | string[], verify: boolean) => {
  fieldNames = (typeof fieldNames === 'string' ? fieldNames : defaultDKIMFieldNames)
    .split(':')
    .map((key) => key.trim().toLowerCase())
    .filter((key) => key);

  let signingList = [];

  if (verify) {
    let parsedList = ([] as Parsed[]).concat(parsedHeaders);
    for (let fieldName of fieldNames) {
      for (let i = parsedList.length - 1; i >= 0; i--) {
        let header = parsedList[i];
        if (fieldName === header.key) {
          signingList.push(header);
          parsedList.splice(i, 1);
          break;
        }
      }
    }
  } else {
    for (let i = parsedHeaders.length - 1; i >= 0; i--) {
      let header = parsedHeaders[i];
      if (fieldNames.includes(header.key ?? '')) {
        signingList.push(header);
      }
    }
  }

  return {
    keys: signingList.map((entry) => entry.casedKey).join(': '),
    headers: signingList,
  };
};

/**
 * Generates `DKIM-Signature: ...` header for selected values
 * @param {Object} values
 */
export const formatSignatureHeaderLine = (
  type: SignatureType,
  values: Record<string, string | boolean>,
  folded: boolean,
): string => {
  type = (type ?? '').toString().toUpperCase() as SignatureType;

  let keyOrdering: string[], headerKey: string;
  switch (type) {
    case 'DKIM':
      headerKey = 'DKIM-Signature';
      keyOrdering = keyOrderingDKIM;
      values = Object.assign(
        {
          v: 1,
          t: Math.round(Date.now() / 1000),
          q: 'dns/txt',
        },
        values,
      );
      break;

    case 'ARC':
    case 'AS':
      throw Error('err');

    default:
      throw new Error('Unknown Signature type');
  }

  const header =
    `${headerKey}: ` +
    Object.keys(values)
      .filter(
        (key) =>
          values[key] !== false &&
          typeof values[key] !== 'undefined' &&
          values.key !== null &&
          keyOrdering.includes(key),
      )
      .sort((a, b) => keyOrdering.indexOf(a) - keyOrdering.indexOf(b))
      .map((key) => {
        let val = values[key] ?? '';
        if (key === 'b' && folded && val) {
          // fold signature value
          return `${key}=${val}`.replace(/.{75}/g, '$& ').trim();
        }

        if (['d', 's'].includes(key) && typeof val === 'string') {
          try {
            // convert to A-label if needed
            val = punycode.toASCII(val);
          } catch (err) {
            // ignore
          }
        }

        if (key === 'i' && type === 'DKIM' && typeof val === 'string') {
          let atPos = val.indexOf('@');
          if (atPos >= 0) {
            let domainPart = val.substr(atPos + 1);
            try {
              // convert to A-label if needed
              domainPart = punycode.toASCII(domainPart);
            } catch (err) {
              // ignore
            }
            val = val.substr(0, atPos + 1) + domainPart;
          }
        }

        return `${key}=${val}`;
      })
      .join('; ');

  if (folded) {
    return libmime.foldLines(header);
  }

  return header;
};
