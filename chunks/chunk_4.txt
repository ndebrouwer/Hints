        throw std::runtime_error("Invalid number of parameters for number");
    }
    FrElement e;
    a = readInt(v[0]);
    *(u_int64_t *)(&e) = a;
    for (int i=0; i<Fr_N64; i++) {
        if (i+1 < v.size()) {
            a = readInt(v[i+1]);
        } else {
            a = 0;
        }
        e.longVal[i] = a;
    }
    stack.push_back(e);
}

void callFunction(FunctionSpec fs) {
    if (stack.size() < fs.nOps) {
        throw new std::runtime_error("Not enough elements in stack");
    }
    if (fs.nOps == 1) {
        FrElement a = stack.back();
        stack.pop_back();
        FrElement c;
        (*(Func1)fs.fn)(&c, &a);
        stack.push_back(c);
    } else if (fs.nOps == 2) {
        FrElement b = stack.back();
        stack.pop_back();
        FrElement a = stack.back();
        stack.pop_back();
        FrElement c;
        (*(Func2)fs.fn)(&c, &a, &b);
        stack.push_back(c);
    } else {
        assert(false);
    }
}

void processLine(std::string &line) {
    std::regex re("(\\s*[,;]\\s*)|\\s+"); // whitespace

    std::sregex_token_iterator begin( line.begin(), line.end(), re ,-1);
    std::sregex_token_iterator end;
    std::vector<std::string> tokens;

    std::copy(begin, end, std::back_inserter(tokens));

    // Remove initial empty tokens
    while ((tokens.size() > 0)&&(tokens[0] == "")) {
        tokens.erase(tokens.begin());
    }

    // Empty lines are valid but are not processed
    if (tokens.size() == 0) return;

    auto search = functions.find(tokens[0]);
    if (search == functions.end()) {
        pushNumber(tokens);
    } else {
        if (tokens.size() != 1) {
            throw std::runtime_error("Functions does not accept parameters");
        }
        callFunction(search->second);
    }
}

int main(void)
{
    Fr_init();
    fillMap();
    std::string line;
    int i=0;
    while (std::getline(std::cin, line)) {
        processLine(line);
        // if (i%1000 == 0) printf("%d\n", i);
        // printf("%d\n", i);
        i++;
    }
    // Print the elements in the stack
    //
    for (int i=0; i<stack.size(); i++) {
        char *s;
        s = Fr_element2str(&stack[i]);
        printf("%s\n", s);
        free(s);
    }
    return EXIT_SUCCESS;
}



/*


#include <stdlib.h>
#include <string.h>
#include "fr.h"

typedef void (*Func2)(PFrElement, PFrElement, PFrElement);

typedef struct {
    const char *fnName;
    Func2 fn;
} FN;


#define NFN 2
FN fns[NFN] = {
    {"add", Fr_add},
    {"mul", Fr_mul},
};

int main(int argc, char **argv) {

    if (argc <= 1) {
        fprintf( stderr, "invalid number of parameters");
        return 1;
    }

    for (int i=0; i< NFN;i++) {
        if (strcmp(argv[1], fns[i].fnName) == 0) {
            if (argc != 4) {
                fprintf( stderr, "invalid number of parameters");
                return 1;
            }
            FrElement a;
            FrElement b;

            Fr_str2element(&a, argv[2]);
            Fr_str2element(&b, argv[3]);
            FrElement c;
            fns[i].fn(&c, &a, &b);

            char *s;
            s = Fr_element2str(&c);
            printf("%s", s);
            free(s);
            return 0;
        }
    }
    fprintf( stderr, "invalid operation %s", argv[1]);
    return 1;
}

*/



---
File: /@zk-email/helpers/node_modules/circom_runtime/c/old/mainjson.cpp
---

#include <iostream>
#include <nlohmann/json.hpp>
#include <map>
using json = nlohmann::json;


#include "utils.h"
#include "circom.h"
#include "calcwit.h"

auto j = R"(
  {
    "in": "314"
  }
)"_json;

typedef void (*ItFunc)(int idx, json val);

void iterateArr(int o, Circom_Sizes sizes, json jarr, ItFunc f) {
  if (!jarr.is_array()) {
    assert((sizes[0] == 1)&&(sizes[1] == 0));
    f(o, jarr);
  } else {
    int n = sizes[0] / sizes[1];
    for (int i=0; i<n; i++) {
      iterateArr(o + i*sizes[1], sizes+1, jarr[i], f);
    }
  }
}

void itFunc(int o, json v) {
  std::cout << o << " <-- " << v << '\n';
}


int main(int argc, char **argv) {

    Circom_CalcWit *ctx = new Circom_CalcWit(&_circuit);

    for (json::iterator it = j.begin(); it != j.end(); ++it) {
//      std::cout << it.key() << " => " << it.value() << '\n';
      u64 h = fnv1a(it.key());
      int o = ctx->getSignalOffset(0, h);
      Circom_Sizes sizes = ctx->getSignalSizes(0, h);
      iterateArr(o, sizes, it.value(), itFunc);
    }
}




---
File: /@zk-email/helpers/node_modules/circom_runtime/c/old/zqfield.cpp
---

#include "zqfield.h"

ZqField::ZqField(PBigInt ap) {
    mpz_init_set(p, *ap);
    mpz_init_set_ui(zero, 0);
    mpz_init_set_ui(one, 1);
    nBits = mpz_sizeinbase (p, 2);
    mpz_init(mask);
    mpz_mul_2exp(mask, one, nBits-1);
    mpz_sub(mask, mask, one);
}

ZqField::~ZqField() {
    mpz_clear(p);
    mpz_clear(zero);
    mpz_clear(one);
}

void ZqField::add(PBigInt r, PBigInt a, PBigInt b) {
    mpz_add(*r,*a,*b);
    if (mpz_cmp(*r, p) >= 0) {
        mpz_sub(*r, *r, p);
    }
}

void ZqField::sub(PBigInt r, PBigInt a, PBigInt b) {
    if (mpz_cmp(*a, *b) >= 0) {
        mpz_sub(*r, *a, *b);
    } else {
        mpz_sub(*r, *b, *a);
        mpz_sub(*r, p, *r);
    }
}

void ZqField::neg(PBigInt r, PBigInt a) {
    if (mpz_sgn(*a) > 0) {
        mpz_sub(*r, p, *a);
    } else {
        mpz_set(*r, *a);
    }
}

void ZqField::mul(PBigInt r, PBigInt a, PBigInt b) {
    mpz_t tmp;
    mpz_init(tmp);
    mpz_mul(tmp,*a,*b);
    mpz_fdiv_r(*r, tmp, p);
    mpz_clear(tmp);
}

void ZqField::div(PBigInt r, PBigInt a, PBigInt b) {
    mpz_t tmp;
    mpz_init(tmp);
    mpz_invert(tmp, *b, p);
    mpz_mul(tmp,*a,tmp);
    mpz_fdiv_r(*r, tmp, p);
    mpz_clear(tmp);
}

void ZqField::idiv(PBigInt r, PBigInt a, PBigInt b) {
    mpz_fdiv_q(*r, *a, *b);
}

void ZqField::mod(PBigInt r, PBigInt a, PBigInt b) {
    mpz_fdiv_r(*r, *a, *b);
}

void ZqField::pow(PBigInt r, PBigInt a, PBigInt b) {
    mpz_powm(*r, *a, *b, p);
}

void ZqField::lt(PBigInt r, PBigInt a, PBigInt b) {
    int c = mpz_cmp(*a, *b);
    if (c<0) {
        mpz_set(*r, one);
    } else {
        mpz_set(*r, zero);
    }
}

void ZqField::eq(PBigInt r, PBigInt a, PBigInt b) {
    int c = mpz_cmp(*a, *b);
    if (c==0) {
        mpz_set(*r, one);
    } else {
        mpz_set(*r, zero);
    }
}

void ZqField::gt(PBigInt r, PBigInt a, PBigInt b) {
    int c = mpz_cmp(*a, *b);
    if (c>0) {
        mpz_set(*r, one);
    } else {
        mpz_set(*r, zero);
    }
}

void ZqField::leq(PBigInt r, PBigInt a, PBigInt b) {
    int c = mpz_cmp(*a, *b);
    if (c<=0) {
        mpz_set(*r, one);
    } else {
        mpz_set(*r, zero);
    }
}

void ZqField::geq(PBigInt r, PBigInt a, PBigInt b) {
    int c = mpz_cmp(*a, *b);
    if (c>=0) {
        mpz_set(*r, one);
    } else {
        mpz_set(*r, zero);
    }
}

void ZqField::neq(PBigInt r, PBigInt a, PBigInt b) {
    int c = mpz_cmp(*a, *b);
    if (c!=0) {
        mpz_set(*r, one);
    } else {
        mpz_set(*r, zero);
    }
}

void ZqField::land(PBigInt r, PBigInt a, PBigInt b) {
    if (mpz_sgn(*a) && mpz_sgn(*b)) {
        mpz_set(*r, one);
    } else {
        mpz_set(*r, zero);
    }
}

void ZqField::lor(PBigInt r, PBigInt a, PBigInt b) {
    if (mpz_sgn(*a) || mpz_sgn(*b)) {
        mpz_set(*r, one);
    } else {
        mpz_set(*r, zero);
    }
}

void ZqField::lnot(PBigInt r, PBigInt a) {
    if (mpz_sgn(*a)) {
        mpz_set(*r, zero);
    } else {
        mpz_set(*r, one);
    }
}

int ZqField::isTrue(PBigInt a) {
    return mpz_sgn(*a);
}

void ZqField::copyn(PBigInt a, PBigInt b, int n) {
    for (int i=0;i<n; i++) mpz_set(a[i], b[i]);
}

void ZqField::band(PBigInt r, PBigInt a, PBigInt b) {
    mpz_and(*r, *a, *b);
    mpz_and(*r, *r, mask);
}

void ZqField::bor(PBigInt r, PBigInt a, PBigInt b) {
    mpz_ior(*r, *a, *b);
    mpz_and(*r, *r, mask);
}

void ZqField::bxor(PBigInt r, PBigInt a, PBigInt b) {
    mpz_xor(*r, *a, *b);
    mpz_and(*r, *r, mask);
}

void ZqField::bnot(PBigInt r, PBigInt a) {
    mpz_xor(*r, *a, mask);
    mpz_and(*r, *r, mask);
}

void ZqField::shl(PBigInt r, PBigInt a, PBigInt b) {
    if (mpz_cmp_ui(*b, nBits) >= 0) {
        mpz_set(*r, zero);
    } else {
        mpz_mul_2exp(*r, *a, mpz_get_ui(*b));
        mpz_and(*r, *r, mask);
    }
}

void ZqField::shr(PBigInt r, PBigInt a, PBigInt b) {
    if (mpz_cmp_ui(*b, nBits) >= 0) {
        mpz_set(*r, zero);
    } else {
        mpz_tdiv_q_2exp(*r, *a, mpz_get_ui(*b));
        mpz_and(*r, *r, mask);
    }
}

int ZqField::toInt(PBigInt a) {
     return mpz_get_si (*a);
}




---
File: /@zk-email/helpers/node_modules/circom_runtime/c/calcwit.cpp
---

#include <string>
#include <stdexcept>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <stdlib.h>
#include <assert.h>
#include <stdarg.h>
#include <thread>
#include <chrono>
#include "calcwit.hpp"
#include "utils.hpp"

using namespace std::chrono_literals;

Circom_CalcWit::Circom_CalcWit(Circom_Circuit *aCircuit) {
    circuit = aCircuit;

    signalAssigned = new bool[circuit->NSignals];
    signalAssigned[0] = true;

    mutexes = new std::mutex[NMUTEXES];
    cvs = new std::condition_variable[NMUTEXES];
    inputSignalsToTrigger = new int[circuit->NComponents];
    signalValues = new FrElement[circuit->NSignals];

    // Set one signal
    Fr_copy(&signalValues[0], circuit->constants + 1);

    reset();
}


Circom_CalcWit::~Circom_CalcWit() {

    delete signalAssigned;

    delete[] cvs;
    delete[] mutexes;

    delete[] signalValues;
    delete[] inputSignalsToTrigger;

}

void Circom_CalcWit::syncPrintf(const char *format, ...) {
    va_list args;
    va_start(args, format);

    printf_mutex.lock();
    vprintf(format, args);
    printf_mutex.unlock();

    va_end(args);
}

void Circom_CalcWit::reset() {

    #pragma omp parallel for
    for (int i=1; i<circuit->NSignals; i++) {
        signalAssigned[i] = false;
    }

    #pragma omp parallel for
    for (int i=0; i<circuit->NComponents; i++) {
        inputSignalsToTrigger[i] = circuit->components[i].inputSignals;
    }

    for (int i=circuit->NComponents-1; i>=0; i--) {
        if (inputSignalsToTrigger[i] == 0) triggerComponent(i);
    }
}


int Circom_CalcWit::getSubComponentOffset(int cIdx, u64 hash) {
    int hIdx;
    for(hIdx = int(hash & 0xFF); hash!=circuit->components[cIdx].hashTable[hIdx].hash; hIdx++) {
        if (!circuit->components[cIdx].hashTable[hIdx].hash) throw std::runtime_error("hash not found: " + int_to_hex(hash));
    }
    int entryPos = circuit->components[cIdx].hashTable[hIdx].pos;
    if (circuit->components[cIdx].entries[entryPos].type != _typeComponent) {
        throw std::runtime_error("invalid type");
    }
    return circuit->components[cIdx].entries[entryPos].offset;
}


Circom_Sizes Circom_CalcWit::getSubComponentSizes(int cIdx, u64 hash) {
    int hIdx;
    for(hIdx = int(hash & 0xFF); hash!=circuit->components[cIdx].hashTable[hIdx].hash; hIdx++) {
        if (!circuit->components[cIdx].hashTable[hIdx].hash) throw std::runtime_error("hash not found: " + int_to_hex(hash));
    }
    int entryPos = circuit->components[cIdx].hashTable[hIdx].pos;
    if (circuit->components[cIdx].entries[entryPos].type != _typeComponent) {
        throw std::runtime_error("invalid type");
    }
    return circuit->components[cIdx].entries[entryPos].sizes;
}

int Circom_CalcWit::getSignalOffset(int cIdx, u64 hash) {
    int hIdx;
    for(hIdx = int(hash & 0xFF); hash!=circuit->components[cIdx].hashTable[hIdx].hash; hIdx++) {
        if (!circuit->components[cIdx].hashTable[hIdx].hash) throw std::runtime_error("hash not found: " + int_to_hex(hash));
    }
    int entryPos = circuit->components[cIdx].hashTable[hIdx].pos;
    if (circuit->components[cIdx].entries[entryPos].type != _typeSignal) {
        throw std::runtime_error("invalid type");
    }
    return circuit->components[cIdx].entries[entryPos].offset;
}

Circom_Sizes Circom_CalcWit::getSignalSizes(int cIdx, u64 hash) {
    int hIdx;
    for(hIdx = int(hash & 0xFF); hash!=circuit->components[cIdx].hashTable[hIdx].hash; hIdx++) {
        if (!circuit->components[cIdx].hashTable[hIdx].hash) throw std::runtime_error("hash not found: " + int_to_hex(hash));
    }
    int entryPos = circuit->components[cIdx].hashTable[hIdx].pos;
    if (circuit->components[cIdx].entries[entryPos].type != _typeSignal) {
        throw std::runtime_error("invalid type");
    }
    return circuit->components[cIdx].entries[entryPos].sizes;
}

void Circom_CalcWit::getSignal(int currentComponentIdx, int cIdx, int sIdx, PFrElement value) {
    // char *s = Fr_element2str(value);
    // syncPrintf("getSignal: %d %s\n", sIdx, s);
    // delete s;
    if ((circuit->components[cIdx].newThread)&&(currentComponentIdx != cIdx)) {
        std::unique_lock<std::mutex> lk(mutexes[cIdx % NMUTEXES]);
        while (!signalAssigned[sIdx]) {
            cvs[sIdx % NMUTEXES].wait_for(lk, 10ms);
        }
        lk.unlock();
    }
    if (signalAssigned[sIdx] == false) {
        fprintf(stderr, "Accessing a not assigned signal: %d\n", sIdx);
        assert(false);
    }
    Fr_copy(value, signalValues + sIdx);
    /*
    char *valueStr = mpz_get_str(0, 10, *value);
    syncPrintf("%d, Get %d --> %s\n", currentComponentIdx, sIdx, valueStr);
    free(valueStr);
    */
}

void Circom_CalcWit::multiGetSignal(int currentComponentIdx, int cIdx, int sIdx, PFrElement value, int n) {
    for (int i=0; i<n; i++) {
        getSignal(currentComponentIdx, cIdx, sIdx+i, value + i);
    }
}

void Circom_CalcWit::finished(int cIdx) {
    {
        std::lock_guard<std::mutex> lk(mutexes[cIdx % NMUTEXES]);
        inputSignalsToTrigger[cIdx] = -1;
    }
    // syncPrintf("Finished: %d\n", cIdx);
    cvs[cIdx % NMUTEXES].notify_all();
}

void Circom_CalcWit::setSignal(int currentComponentIdx, int cIdx, int sIdx, PFrElement value) {
    // syncPrintf("setSignal: %d\n", sIdx);

    if (signalAssigned[sIdx] == true) {
        fprintf(stderr, "Signal assigned twice: %d\n", sIdx);
        assert(false);
    }
    // Log assignement
    /*
    char *valueStr = mpz_get_str(0, 10, *value);
    syncPrintf("%d, Set %d --> %s\n", currentComponentIdx, sIdx, valueStr);
    free(valueStr);
    */
    Fr_copy(signalValues + sIdx, value);
    signalAssigned[sIdx] = true;
    if ( BITMAP_ISSET(circuit->mapIsInput, sIdx) ) {
        if (inputSignalsToTrigger[cIdx]>0) {
            inputSignalsToTrigger[cIdx]--;
            if (inputSignalsToTrigger[cIdx] == 0) triggerComponent(cIdx);
        } else {
            fprintf(stderr, "Input signals does not match with map: %d\n", sIdx);
            assert(false);
        }
    }
    if ((circuit->components[currentComponentIdx].newThread)&&(currentComponentIdx == cIdx)) {
    // syncPrintf("Finished: %d\n", cIdx);
       cvs[sIdx % NMUTEXES].notify_all();
    }

}

void Circom_CalcWit::checkConstraint(int currentComponentIdx, PFrElement value1, PFrElement value2, char const *err) {
#ifdef SANITY_CHECK
    FrElement tmp;
    Fr_eq(&tmp, value1, value2);
    if (!Fr_isTrue(&tmp)) {
        char *pcV1 = Fr_element2str(value1);
        char *pcV2 = Fr_element2str(value2);
        // throw std::runtime_error(std::to_string(currentComponentIdx) + std::string(", Constraint doesn't match, ") + err + ". " + sV1 + " != " + sV2 );
        fprintf(stderr, "Constraint doesn't match, %s: %s != %s", err, pcV1, pcV2);
        free(pcV1);
        free(pcV2);
        assert(false);
    }
#endif
}

void Circom_CalcWit::checkAssert(int currentComponentIdx, PFrElement value1, char const *err) {
#ifdef SANITY_CHECK
    FrElement tmp;
    if (!Fr_isTrue(value1)) {
        char *pcV1 = Fr_element2str(value1);
        // throw std::runtime_error(std::to_string(currentComponentIdx) + std::string(", Constraint doesn't match, ") + err + ". " + sV1 + " != " + sV2 );
        fprintf(stderr, "Assert fail: %s", err);
        free(pcV1);
        assert(false);
    }
#endif
}

void Circom_CalcWit::triggerComponent(int newCIdx) {
    //int oldCIdx = cIdx;
    // cIdx = newCIdx;
    if (circuit->components[newCIdx].newThread) {
        // syncPrintf("Triggered: %d\n", newCIdx);
        std::thread t(circuit->components[newCIdx].fn, this, newCIdx);
        // t.join();
        t.detach();
    } else {
        (*(circuit->components[newCIdx].fn))(this, newCIdx);
    }
    // cIdx = oldCIdx;
}

void Circom_CalcWit::log(PFrElement value) {
    char *pcV = Fr_element2str(value);
    syncPrintf("Log: %s\n", pcV);
    free(pcV);
}

void Circom_CalcWit::join() {
    for (int i=0; i<circuit->NComponents; i++) {
        std::unique_lock<std::mutex> lk(mutexes[i % NMUTEXES]);
        while (inputSignalsToTrigger[i] != -1) {
            cvs[i % NMUTEXES].wait_for(lk, 10ms);
        }
        // cvs[i % NMUTEXES].wait(lk, [&]{return inputSignalsToTrigger[i] == -1;});
        lk.unlock();
        // syncPrintf("Joined: %d\n", i);
    }

}



void Circom_CalcWit::iterateArr(int o, Circom_Sizes sizes, json jarr) {
  if (!jarr.is_array()) {
    assert((sizes[0] == 1)&&(sizes[1] == 0));
    itFunc(o, jarr);
  } else {
    int n = sizes[0] / sizes[1];
    for (int i=0; i<n; i++) {
      iterateArr(o + i*sizes[1], sizes+1, jarr[i]);
      if (isCanceled()) return;
    }
  }
}


void Circom_CalcWit::itFunc(int o, json val) {

    FrElement v;

    std::string s;

    if (val.is_string()) {
        s = val.get<std::string>();
    } else if (val.is_number()) {

        double vd = val.get<double>();
        std::stringstream stream;
        stream << std::fixed << std::setprecision(0) << vd;
        s = stream.str();
    } else {
        throw new std::runtime_error("Invalid JSON type");
    }

    Fr_str2element (&v, s.c_str());

    setSignal(0, 0, o, &v);
}


void Circom_CalcWit::calculateProve(void *wtns, json &input, std::function<bool()> _isCanceledCB) {
    isCanceledCB = _isCanceledCB;
    reset();
    for (json::iterator it = input.begin(); it != input.end(); ++it) {
//      std::cout << it.key() << " => " << it.value() << '\n';
        u64 h = fnv1a(it.key());
        int o;
        try {
            o = getSignalOffset(0, h);
        } catch (std::runtime_error e) {
            std::ostringstream errStrStream;
            errStrStream << "Error loading variable: " << it.key() << "\n" << e.what();
            throw new std::runtime_error(errStrStream.str());
        }
        Circom_Sizes sizes = getSignalSizes(0, h);
        iterateArr(o, sizes, it.value());
        if (isCanceled()) break;
    }

    join();

    if (!isCanceled()) {

        #pragma omp raw for
        for (unsigned int i=0;i<circuit->NVars;i++) {
            FrElement v;
            getWitness(i, &v);
            Fr_toLongNormal(&v, &v);
            memcpy((uint8_t*)wtns + i*Fr_N64*8, v.longVal, Fr_N64*8);
        }
    }

    if (isCanceled()) throw new std::runtime_error("Aborted");
}

void Circom_CalcWit::calculateProve(void *wtns, std::string &input, std::function<bool()> _isCanceledCB) {

    json inputJson = json::parse(input, nullptr, false);
    if (inputJson.is_discarded()) throw new std::runtime_error("JSonParseError");
    calculateProve(wtns, inputJson, _isCanceledCB);
}






---
File: /@zk-email/helpers/node_modules/circom_runtime/c/main.cpp
---

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <iomanip>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <fcntl.h>
#include <unistd.h>
#include <nlohmann/json.hpp>
#include <sys/time.h>
using json = nlohmann::json;

#include "calcwit.hpp"
#include "circom.hpp"
#include "utils.hpp"

Circom_Circuit *circuit;


#define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define SHMEM_WITNESS_KEY (123456)

// assumptions
// 1) There is only one key assigned for shared memory. This means
//      that only one witness can be computed and used at a time. If several witness
//      are computed before calling the prover, witness memory will be overwritten.
// 2) Prover is responsible for releasing memory once is done with witness
//
// File format:
// Type     : 4B (wshm)
// Version  : 4B
// N Section : 4B
// HDR1     : 12B
// N8       : 4B
// Fr       : N8 B
// NVars    : 4B
// HDR2     : 12B
// ShmemKey : 4B
// Status   : 4B  (0:OK, 0xFFFF: KO)
// ShmemID  : 4B
void writeOutShmem(Circom_CalcWit *ctx, std::string filename) {
    FILE *write_ptr;
    u64 *shbuf;
    int shmid, status = 0;

    write_ptr = fopen(filename.c_str(),"wb");

    fwrite("wshm", 4, 1, write_ptr);

    u32 version = 2;
    fwrite(&version, 4, 1, write_ptr);

    u32 nSections = 2;
    fwrite(&nSections, 4, 1, write_ptr);

    // Header
    u32 idSection1 = 1;
    fwrite(&idSection1, 4, 1, write_ptr);

    u32 n8 = Fr_N64*8;

    u64 idSection1length = 8 + n8;
    fwrite(&idSection1length, 8, 1, write_ptr);

    fwrite(&n8, 4, 1, write_ptr);

    fwrite(Fr_q.longVal, Fr_N64*8, 1, write_ptr);

    u32 nVars = circuit->NVars;
    fwrite(&nVars, 4, 1, write_ptr);

    // Data
    u32 idSection2 = 2;
    fwrite(&idSection2, 4, 1, write_ptr);

    u64 idSection2length = n8*circuit->NVars;
    fwrite(&idSection2length, 8, 1, write_ptr);


    // generate key
    key_t key = SHMEM_WITNESS_KEY;
    fwrite(&key, sizeof(key_t), 1, write_ptr);

    // Setup shared memory
    if ((shmid = shmget(key, circuit->NVars * Fr_N64 * sizeof(u64), IPC_CREAT | 0666)) < 0) {
       // preallocated shared memory segment is too small => Retrieve id by accesing old segment
       // Delete old segment and create new with corret size
       shmid = shmget(key, 4, IPC_CREAT | 0666);
       shmctl(shmid, IPC_RMID, NULL);
       if ((shmid = shmget(key, circuit->NVars * Fr_N64 * sizeof(u64), IPC_CREAT | 0666)) < 0){
         status = -1;
         fwrite(&status, sizeof(status), 1, write_ptr);
         fclose(write_ptr);
         return ;
      }
    }

    // Attach shared memory
    if ((shbuf = (u64 *)shmat(shmid, NULL, 0)) == (u64 *) -1) {
      status = -1;
      fwrite(&status, sizeof(status), 1, write_ptr);
      fclose(write_ptr);
      return;
    }
    fwrite(&status, sizeof(status), 1, write_ptr);

    fwrite(&shmid, sizeof(u32), 1, write_ptr);
    fclose(write_ptr);


    #pragma omp parallel for
    for (int i=0; i<circuit->NVars;i++) {
    	FrElement v;
        ctx->getWitness(i, &v);
        Fr_toLongNormal(&v, &v);
        memcpy(&shbuf[i*Fr_N64], v.longVal, Fr_N64*sizeof(u64));
    }
}


void loadBin(Circom_CalcWit *ctx, std::string filename) {
    int fd;
    struct stat sb;

    // map input
    fd = open(filename.c_str(), O_RDONLY);
    if (fd == -1)
        handle_error("open");

    if (fstat(fd, &sb) == -1)           /* To obtain file size */
        handle_error("fstat");


    u8 *in;

    in = (u8 *)mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (in == MAP_FAILED)
        handle_error("mmap");

    close(fd);

    FrElement v;
    u8 *p = in;
    for (int i=0; i<circuit->NInputs; i++) {
        v.type = Fr_LONG;
        for (int j=0; j<Fr_N64; j++) {
            v.longVal[j] = *(u64 *)p;
        }
        p += 8;
        ctx->setSignal(0, 0, circuit->wit2sig[1 + circuit->NOutputs + i], &v);
    }
}


typedef void (*ItFunc)(Circom_CalcWit *ctx, int idx, json val);

void iterateArr(Circom_CalcWit *ctx, int o, Circom_Sizes sizes, json jarr, ItFunc f) {
  if (!jarr.is_array()) {
    assert((sizes[0] == 1)&&(sizes[1] == 0));
    f(ctx, o, jarr);
  } else {
    int n = sizes[0] / sizes[1];
    for (int i=0; i<n; i++) {
      iterateArr(ctx, o + i*sizes[1], sizes+1, jarr[i], f);
    }
  }
}

void itFunc(Circom_CalcWit *ctx, int o, json val) {

    FrElement v;

    std::string s;

    if (val.is_string()) {
        s = val.get<std::string>();
    } else if (val.is_number()) {

        double vd = val.get<double>();
        std::stringstream stream;
        stream << std::fixed << std::setprecision(0) << vd;
        s = stream.str();
    } else {
        handle_error("Invalid JSON type");
    }

    Fr_str2element (&v, s.c_str());

    ctx->setSignal(0, 0, o, &v);
}

void loadJson(Circom_CalcWit *ctx, std::string filename) {
    std::ifstream inStream(filename);
    json j;
    inStream >> j;

    u64 nItems = j.size();
    printf("Items : %llu\n",nItems);
    for (json::iterator it = j.begin(); it != j.end(); ++it) {
//      std::cout << it.key() << " => " << it.value() << '\n';
      u64 h = fnv1a(it.key());
      int o;
      try {
        o = ctx->getSignalOffset(0, h);
      } catch (std::runtime_error e) {
        std::ostringstream errStrStream;
        errStrStream << "Error loadin variable: " << it.key() << "\n" << e.what();
        throw std::runtime_error(errStrStream.str() );
      }
      Circom_Sizes sizes = ctx->getSignalSizes(0, h);
      iterateArr(ctx, o, sizes, it.value(), itFunc);
    }
}


void writeOutBin(Circom_CalcWit *ctx, std::string filename) {
    FILE *write_ptr;

    write_ptr = fopen(filename.c_str(),"wb");

    fwrite("wtns", 4, 1, write_ptr);

    u32 version = 2;
    fwrite(&version, 4, 1, write_ptr);

    u32 nSections = 2;
    fwrite(&nSections, 4, 1, write_ptr);

    // Header
    u32 idSection1 = 1;
    fwrite(&idSection1, 4, 1, write_ptr);

    u32 n8 = Fr_N64*8;

    u64 idSection1length = 8 + n8;
    fwrite(&idSection1length, 8, 1, write_ptr);

    fwrite(&n8, 4, 1, write_ptr);

    fwrite(Fr_q.longVal, Fr_N64*8, 1, write_ptr);

    u32 nVars = circuit->NVars;
    fwrite(&nVars, 4, 1, write_ptr);


    // Data
    u32 idSection2 = 2;
    fwrite(&idSection2, 4, 1, write_ptr);

    u64 idSection2length = (u64)n8*(u64)circuit->NVars;
    fwrite(&idSection2length, 8, 1, write_ptr);

    FrElement v;

    for (int i=0;i<circuit->NVars;i++) {
        ctx->getWitness(i, &v);
        Fr_toLongNormal(&v, &v);
        fwrite(v.longVal, Fr_N64*8, 1, write_ptr);
    }
    fclose(write_ptr);

}


void writeOutJson(Circom_CalcWit *ctx, std::string filename) {

    std::ofstream outFile;
    outFile.open (filename);

    outFile << "[\n";

    FrElement v;

    for (int i=0;i<circuit->NVars;i++) {
        ctx->getWitness(i, &v);
        char *pcV = Fr_element2str(&v);
        std::string sV = std::string(pcV);
        outFile << (i ? "," : " ") << "\"" << sV << "\"\n";
        free(pcV);
    }

    outFile << "]\n";
    outFile.close();
}

bool hasEnding (std::string const &fullString, std::string const &ending) {
    if (fullString.length() >= ending.length()) {
        return (0 == fullString.compare (fullString.length() - ending.length(), ending.length(), ending));
    } else {
        return false;
    }
}

#define ADJ_P(a) *((void **)&a) = (void *)(((char *)circuit)+ (uint64_t)(a))

Circom_Circuit *loadCircuit(std::string const &datFileName) {
    Circom_Circuit *circuitF;
    Circom_Circuit *circuit;

    int fd;
    struct stat sb;

    fd = open(datFileName.c_str(), O_RDONLY);
    if (fd == -1) {
        std::cout << ".dat file not found: " << datFileName << "\n";
        throw std::system_error(errno, std::generic_category(), "open");
    }

    if (fstat(fd, &sb) == -1) {         /* To obtain file size */
        throw std::system_error(errno, std::generic_category(), "fstat");
    }

    circuitF = (Circom_Circuit *)mmap(NULL, sb.st_size, PROT_READ , MAP_PRIVATE, fd, 0);
    close(fd);

    circuit = (Circom_Circuit *)malloc(sb.st_size);
    memcpy((void *)circuit, (void *)circuitF, sb.st_size);

    munmap(circuitF, sb.st_size);

    ADJ_P(circuit->wit2sig);
    ADJ_P(circuit->components);
    ADJ_P(circuit->mapIsInput);
    ADJ_P(circuit->constants);
    ADJ_P(circuit->P);
    ADJ_P(circuit->componentEntries);

    for (int i=0; i<circuit->NComponents; i++) {
        ADJ_P(circuit->components[i].hashTable);
        ADJ_P(circuit->components[i].entries);
        circuit->components[i].fn = _functionTable[  (uint64_t)circuit->components[i].fn];
    }

    for (int i=0; i<circuit->NComponentEntries; i++) {
        ADJ_P(circuit->componentEntries[i].sizes);
    }

    return circuit;
}

int main(int argc, char *argv[]) {
    if (argc!=3) {
        std::string cl = argv[0];
        std::string base_filename = cl.substr(cl.find_last_of("/\\") + 1);
        std::cout << "Usage: " << base_filename << " <input.<bin|json>> <output.<wtns|json|wshm>>\n";
    } else {

        struct timeval begin, end;
        long seconds, microseconds; 
        double elapsed;

	gettimeofday(&begin,0);

        std::string datFileName = argv[0];
        datFileName += ".dat";

        circuit = loadCircuit(datFileName);

        // open output
        Circom_CalcWit *ctx = new Circom_CalcWit(circuit);

        std::string infilename = argv[1];
	    gettimeofday(&end,0);
            seconds = end.tv_sec - begin.tv_sec;
            microseconds = end.tv_usec - begin.tv_usec;
            elapsed = seconds + microseconds*1e-6;

            printf("Up to loadJson %.20f\n", elapsed);

        if (hasEnding(infilename, std::string(".bin"))) {
            loadBin(ctx, infilename);
        } else if (hasEnding(infilename, std::string(".json"))) {
            loadJson(ctx, infilename);
        } else {
            handle_error("Invalid input extension (.bin / .json)");
        }

        ctx->join();

        // printf("Finished!\n");

        std::string outfilename = argv[2];

        if (hasEnding(outfilename, std::string(".wtns"))) {
	    gettimeofday(&end,0);
            seconds = end.tv_sec - begin.tv_sec;
            microseconds = end.tv_usec - begin.tv_usec;
            elapsed = seconds + microseconds*1e-6;

            printf("Up to WriteWtns %.20f\n", elapsed);
            writeOutBin(ctx, outfilename);
        } else if (hasEnding(outfilename, std::string(".json"))) {
            writeOutJson(ctx, outfilename);
        } else if (hasEnding(outfilename, std::string(".wshm"))) {
	    gettimeofday(&end,0);
            seconds = end.tv_sec - begin.tv_sec;
            microseconds = end.tv_usec - begin.tv_usec;
            elapsed = seconds + microseconds*1e-6;

            printf("Up to WriteShmem %.20f\n", elapsed);
            writeOutShmem(ctx, outfilename);
        } else {
            handle_error("Invalid output extension (.bin / .json)");
        }

        delete ctx;
	    gettimeofday(&end,0);
            seconds = end.tv_sec - begin.tv_sec;
            microseconds = end.tv_usec - begin.tv_usec;
            elapsed = seconds + microseconds*1e-6;

            printf("Total %.20f\n", elapsed);
        exit(EXIT_SUCCESS);
    }
}



---
File: /@zk-email/helpers/node_modules/circom_runtime/c/utils.cpp
---

#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <stdlib.h>

#include "utils.hpp"

std::string int_to_hex( u64 i )
{
  std::stringstream stream;
  stream << "0x"
         << std::setfill ('0') << std::setw(16)
         << std::hex << i;
  return stream.str();
}

u64 fnv1a(std::string s) {
  u64 hash = 0xCBF29CE484222325LL;
  for(char& c : s) {
    hash ^= u64(c);
    hash *= 0x100000001B3LL;
  }
  return hash;
}



---
File: /@zk-email/helpers/node_modules/circom_runtime/js/utils.js
---

/*

Copyright 2020 0KIMS association.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

export function flatArray(a) {
    var res = [];
    fillArray(res, a);
    return res;

    function fillArray(res, a) {
        if (Array.isArray(a)) {
            for (let i=0; i<a.length; i++) {
                fillArray(res, a[i]);
            }
        } else {
            res.push(a);
        }
    }
}

export function fnvHash(str) {
    const uint64_max = BigInt(2) ** BigInt(64);
    let hash = BigInt("0xCBF29CE484222325");
    for (var i = 0; i < str.length; i++) {
    hash ^= BigInt(str[i].charCodeAt());
    hash *= BigInt(0x100000001B3);
    hash %= uint64_max;
    }
    let shash = hash.toString(16);
    let n = 16 - shash.length;
    shash = '0'.repeat(n).concat(shash);
    return shash;
}

// Note that this pads zeros
export function toArray32(s,size) {
    const res = []; //new Uint32Array(size); //has no unshift
    let rem = BigInt(s);
    const radix = BigInt(0x100000000);
    while (rem) {
        res.unshift( Number(rem % radix));
        rem = rem / radix;
    }
    if (size) {
    var i = size - res.length;
    while (i>0) {
        res.unshift(0);
        i--;
    }
    }
    return res;
}



---
File: /@zk-email/helpers/node_modules/circom_runtime/js/witness_calculator.js
---

/* globals WebAssembly */
/*

Copyright 2020 0KIMS association.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

import { flatArray, fnvHash, toArray32 } from "./utils.js";
import { Scalar, F1Field } from "ffjavascript";

export default async function builder(code, options) {

    options = options || {};

    let memorySize = 32767;
    let memory;
    let memoryAllocated = false;
    while (!memoryAllocated){
        try{
            memory = new WebAssembly.Memory({initial:memorySize});
            memoryAllocated = true;
        } catch(err){
            if(memorySize === 1){
                throw err;
            }
            console.warn("Could not allocate " + memorySize * 1024 * 64 + " bytes. This may cause severe instability. Trying with " + memorySize * 1024 * 64 / 2 + " bytes");
            memorySize = Math.floor(memorySize/2);
        }
    }

    const wasmModule = await WebAssembly.compile(code);

    let wc;

    let errStr = "";
    let msgStr = "";

    // Only circom 2 implements version lookup through exports in the WASM
    // We default to `1` and update if we see the `getVersion` export (major version)
    // These are updated after the instance is instantiated, assuming the functions are available
    let majorVersion = 1;
    // After Circom 2.0.7, Blaine added exported functions for getting minor and patch versions
    let minorVersion = 0;
    // If we can't lookup the patch version, assume the lowest
    let patchVersion = 0;

    const instance = await WebAssembly.instantiate(wasmModule, {
        env: {
            "memory": memory
        },
        runtime: {
            exceptionHandler: function(code) {
                let err;
                if (code == 1) {
                    err = "Signal not found. ";
                } else if (code == 2) {
                    err = "Too many signals set. ";
                } else if (code == 3) {
                    err = "Signal already set. ";
                } else if (code == 4) {
                    err = "Assert Failed. ";
                } else if (code == 5) {
                    err = "Not enough memory. ";
                } else if (code == 6) {
                    err = "Input signal array access exceeds the size. ";
                } else {
                    err = "Unknown error. ";
                }
                console.error("ERROR: ", code, errStr);
                throw new Error(err + errStr);
            },
            // A new way of logging messages was added in Circom 2.0.7 that requires 2 new imports
            // `printErrorMessage` and `writeBufferMessage`.
            printErrorMessage: function() {
                errStr += getMessage() + "\n";
            },
            writeBufferMessage: function() {
                const msg = getMessage();
                // Any calls to `log()` will always end with a `\n`, so that's when we print and reset
                if (msg === "\n") {
                    console.log(msgStr);
                    msgStr = "";
                } else {
                    // If we've buffered other content, put a space in between the items
                    if (msgStr !== "") {
                        msgStr += " "
                    }
                    // Then append the message to the message we are creating
                    msgStr += msg;
                }
            },
            showSharedRWMemory: function() {
                const shared_rw_memory_size = instance.exports.getFieldNumLen32();
                const arr = new Uint32Array(shared_rw_memory_size);
                for (let j=0; j<shared_rw_memory_size; j++) {
                    arr[shared_rw_memory_size-1-j] = instance.exports.readSharedRWMemory(j);
                }

                // In circom 2.0.7, they changed the log() function to allow strings and changed the
                // output API. This smoothes over the breaking change.
                if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {
                    // If we've buffered other content, put a space in between the items
                    if (msgStr !== "") {
                        msgStr += " "
                    }
                    // Then append the value to the message we are creating
                    const msg = (Scalar.fromArray(arr, 0x100000000).toString());
                    msgStr += msg;
                } else {
                    console.log(Scalar.fromArray(arr, 0x100000000));
                }
            },
            error: function(code, pstr, a,b,c,d) {
                let errStr;
                if (code == 7) {
                    errStr=p2str(pstr) + " " + wc.getFr(b).toString() + " != " + wc.getFr(c).toString() + " " +p2str(d);
                } else if (code == 9) {
                    errStr=p2str(pstr) + " " + wc.getFr(b).toString() + " " +p2str(c);
                } else if ((code == 5)&&(options.sym)) {
                    errStr=p2str(pstr)+ " " + options.sym.labelIdx2Name[c];
                } else {
                    errStr=p2str(pstr)+ " " + a + " " + b + " " + c + " " + d;
                }
                console.log("ERROR: ", code, errStr);
                throw new Error(errStr);
            },
            log: function(a) {
                console.log(wc.getFr(a).toString());
            },
            logGetSignal: function(signal, pVal) {
                if (options.logGetSignal) {
                    options.logGetSignal(signal, wc.getFr(pVal) );
                }
            },
            logSetSignal: function(signal, pVal) {
                if (options.logSetSignal) {
                    options.logSetSignal(signal, wc.getFr(pVal) );
                }
            },
            logStartComponent: function(cIdx) {
                if (options.logStartComponent) {
                    options.logStartComponent(cIdx);
                }
            },
            logFinishComponent: function(cIdx) {
                if (options.logFinishComponent) {
                    options.logFinishComponent(cIdx);
                }
            }
        }
    });

    if (typeof instance.exports.getVersion == 'function') {
        majorVersion = instance.exports.getVersion();
    }
    if (typeof instance.exports.getMinorVersion == 'function') {
        minorVersion = instance.exports.getMinorVersion();
    }
    if (typeof instance.exports.getPatchVersion == 'function') {
        patchVersion = instance.exports.getPatchVersion();
    }

    const sanityCheck =
        options &&
        (
            options.sanityCheck ||
            options.logGetSignal ||
            options.logSetSignal ||
            options.logStartComponent ||
            options.logFinishComponent
        );

    // We explicitly check for major version 2 in case there's a circom v3 in the future
    if (majorVersion === 2) {
        wc = new WitnessCalculatorCircom2(instance, sanityCheck);
    } else {
        // TODO: Maybe we want to check for the explicit version 1 before choosing this?
        wc = new WitnessCalculatorCircom1(memory, instance, sanityCheck);
    }
    return wc;

    function getMessage() {
        var message = "";
        var c = instance.exports.getMessageChar();
        while ( c != 0 ) {
            message += String.fromCharCode(c);
            c = instance.exports.getMessageChar();
        }
        return message;
    }

    function p2str(p) {
        const i8 = new Uint8Array(memory.buffer);

        const bytes = [];

        for (let i=0; i8[p+i]>0; i++)  bytes.push(i8[p+i]);

        return String.fromCharCode.apply(null, bytes);
    }
};

class WitnessCalculatorCircom1 {
    constructor(memory, instance, sanityCheck) {
        this.memory = memory;
        this.i32 = new Uint32Array(memory.buffer);
        this.instance = instance;

        this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;
        const pRawPrime = this.instance.exports.getPRawPrime();

        const arr = new Array(this.n32);
        for (let i=0; i<this.n32; i++) {
            arr[this.n32-1-i] = this.i32[(pRawPrime >> 2) + i];
        }

        this.prime = Scalar.fromArray(arr, 0x100000000);

        this.Fr = new F1Field(this.prime);

        this.mask32 = Scalar.fromString("FFFFFFFF", 16);
        this.NVars = this.instance.exports.getNVars();
        this.n64 = Math.floor((this.Fr.bitLength - 1) / 64)+1;
        this.R = this.Fr.e( Scalar.shiftLeft(1 , this.n64*64));
        this.RInv = this.Fr.inv(this.R);
        this.sanityCheck = sanityCheck;
    }

    circom_version() {
        return 1;
    }

    async _doCalculateWitness(input, sanityCheck) {
        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);
        const pSigOffset = this.allocInt();
        const pFr = this.allocFr();
        const keys = Object.keys(input);
        keys.forEach( (k) => {
            const h = fnvHash(k);
            const hMSB = parseInt(h.slice(0,8), 16);
            const hLSB = parseInt(h.slice(8,16), 16);
            try {
                this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);
            } catch (err) {
                throw new Error(`Signal ${k} is not an input of the circuit.`);
            }
            const sigOffset = this.getInt(pSigOffset);
            const fArr = flatArray(input[k]);
            for (let i=0; i<fArr.length; i++) {
                this.setFr(pFr, fArr[i]);
                this.instance.exports.setSignal(0, 0, sigOffset + i, pFr);
            }
        });
    }

    async calculateWitness(input, sanityCheck) {
        const self = this;

        const old0 = self.i32[0];
        const w = [];

        await self._doCalculateWitness(input, sanityCheck);

        for (let i=0; i<self.NVars; i++) {
            const pWitness = self.instance.exports.getPWitness(i);
            w.push(self.getFr(pWitness));
        }

        self.i32[0] = old0;
        return w;
    }

    async calculateBinWitness(input, sanityCheck) {
        const self = this;

        const old0 = self.i32[0];

        await self._doCalculateWitness(input, sanityCheck);

        const pWitnessBuffer = self.instance.exports.getWitnessBuffer();

        self.i32[0] = old0;

        const buff = self.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + (self.NVars * self.n64 * 8));
        return new Uint8Array(buff);
    }

    allocInt() {
        const p = this.i32[0];
        this.i32[0] = p+8;
        return p;
    }

    allocFr() {
        const p = this.i32[0];
        this.i32[0] = p+this.n32*4 + 8;
        return p;
    }

    getInt(p) {
        return this.i32[p>>2];
    }

    setInt(p, v) {
        this.i32[p>>2] = v;
    }

    getFr(p) {
        const self = this;
        const idx = (p>>2);

        if (self.i32[idx + 1] & 0x80000000) {
            const arr = new Array(self.n32);
            for (let i=0; i<self.n32; i++) {
                arr[self.n32-1-i] = self.i32[idx+2+i];
            }
            const res = self.Fr.e(Scalar.fromArray(arr, 0x100000000));
            if (self.i32[idx + 1] & 0x40000000) {
                return fromMontgomery(res);
            } else {
                return res;
            }

        } else {
            if (self.i32[idx] & 0x80000000) {
                return self.Fr.e( self.i32[idx] - 0x100000000);
            } else {
                return self.Fr.e(self.i32[idx]);
            }
        }

        function fromMontgomery(n) {
            return self.Fr.mul(self.RInv, n);
        }

    }


    setFr(p, v) {
        const self = this;

        v = self.Fr.e(v);

        const minShort = self.Fr.neg(self.Fr.e("80000000", 16));
        const maxShort = self.Fr.e("7FFFFFFF", 16);

        if (  (self.Fr.geq(v, minShort))
            &&(self.Fr.leq(v, maxShort)))
        {
            let a;
            if (self.Fr.geq(v, self.Fr.zero)) {
                a = Scalar.toNumber(v);
            } else {
                a = Scalar.toNumber( self.Fr.sub(v, minShort));
                a = a - 0x80000000;
                a = 0x100000000 + a;
            }
            self.i32[(p >> 2)] = a;
            self.i32[(p >> 2) + 1] = 0;
            return;
        }

        self.i32[(p >> 2)] = 0;
        self.i32[(p >> 2) + 1] = 0x80000000;
        const arr = Scalar.toArray(v, 0x100000000);
        for (let i=0; i<self.n32; i++) {
            const idx = arr.length-1-i;

            if ( idx >=0) {
                self.i32[(p >> 2) + 2 + i] = arr[idx];
            } else {
                self.i32[(p >> 2) + 2 + i] = 0;
            }
        }
    }
}

class WitnessCalculatorCircom2 {
    constructor(instance, sanityCheck) {
        this.instance = instance;

        this.version = this.instance.exports.getVersion();
        this.n32 = this.instance.exports.getFieldNumLen32();

        this.instance.exports.getRawPrime();
        const arr = new Array(this.n32);
        for (let i=0; i<this.n32; i++) {
            arr[this.n32-1-i] = this.instance.exports.readSharedRWMemory(i);
        }
        this.prime = Scalar.fromArray(arr, 0x100000000);

        this.witnessSize = this.instance.exports.getWitnessSize();

        this.sanityCheck = sanityCheck;
    }

    circom_version() {
        return this.instance.exports.getVersion();
    }

    async _doCalculateWitness(input, sanityCheck) {
        //input is assumed to be a map from signals to arrays of bigints
        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);
        const keys = Object.keys(input);
        var input_counter = 0;
        keys.forEach( (k) => {
            const h = fnvHash(k);
            const hMSB = parseInt(h.slice(0,8), 16);
            const hLSB = parseInt(h.slice(8,16), 16);
            const fArr = flatArray(input[k]);
            for (let i=0; i<fArr.length; i++) {
        const arrFr = toArray32(fArr[i],this.n32)
        for (let j=0; j<this.n32; j++) {
            this.instance.exports.writeSharedRWMemory(j,arrFr[this.n32-1-j]);
        }
        try {
                    this.instance.exports.setInputSignal(hMSB, hLSB,i);
            input_counter++;
        } catch (err) {
            // console.log(`After adding signal ${i} of ${k}`)
                    throw new Error(err);
        }
            }

        });
        if (input_counter < this.instance.exports.getInputSize()) {
            throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);
        }
    }

    async calculateWitness(input, sanityCheck) {
        const w = [];

        await this._doCalculateWitness(input, sanityCheck);

        for (let i=0; i<this.witnessSize; i++) {
            this.instance.exports.getWitness(i);
        const arr = new Uint32Array(this.n32);
            for (let j=0; j<this.n32; j++) {
            arr[this.n32-1-j] = this.instance.exports.readSharedRWMemory(j);
            }
            w.push(Scalar.fromArray(arr, 0x100000000));
        }

        return w;
    }

    async calculateWTNSBin(input, sanityCheck) {
        const buff32 = new Uint32Array(this.witnessSize*this.n32+this.n32+11);
        const buff = new  Uint8Array( buff32.buffer);
        await this._doCalculateWitness(input, sanityCheck);

        //"wtns"
        buff[0] = "w".charCodeAt(0)
        buff[1] = "t".charCodeAt(0)
        buff[2] = "n".charCodeAt(0)
        buff[3] = "s".charCodeAt(0)

        //version 2
        buff32[1] = 2;

        //number of sections: 2
        buff32[2] = 2;

        //id section 1
        buff32[3] = 1;

        const n8 = this.n32*4;
        //id section 1 length in 64bytes
        const idSection1length = 8 + n8;
        const idSection1lengthHex = idSection1length.toString(16);
            buff32[4] = parseInt(idSection1lengthHex.slice(0,8), 16);
            buff32[5] = parseInt(idSection1lengthHex.slice(8,16), 16);

        //this.n32
        buff32[6] = n8;

        //prime number
        this.instance.exports.getRawPrime();

        var pos = 7;
        for (let j=0; j<this.n32; j++) {
            buff32[pos+j] = this.instance.exports.readSharedRWMemory(j);
        }
        pos += this.n32;

        // witness size
        buff32[pos] = this.witnessSize;
        pos++;

        //id section 2
        buff32[pos] = 2;
        pos++;

        // section 2 length
        const idSection2length = n8*this.witnessSize;
        const idSection2lengthHex = idSection2length.toString(16);
        buff32[pos] = parseInt(idSection2lengthHex.slice(0,8), 16);
        buff32[pos+1] = parseInt(idSection2lengthHex.slice(8,16), 16);

        pos += 2;
        for (let i=0; i<this.witnessSize; i++) {
            this.instance.exports.getWitness(i);
            for (let j=0; j<this.n32; j++) {
                buff32[pos+j] = this.instance.exports.readSharedRWMemory(j);
            }
            pos += this.n32;
        }

        return buff;
    }

}



---
File: /@zk-email/helpers/node_modules/circom_runtime/.eslintrc.js
---

module.exports = {
    "env": {
        "es6": true,
        "node": true,
        "mocha": true
    },
    "parserOptions": {
        "ecmaVersion": 2017
    },
    "extends": "eslint:recommended",
    "rules": {
        "indent": [
            "error",
            4
        ],
        "linebreak-style": [
            "error",
            "unix"
        ],
        "quotes": [
            "error",
            "double"
        ],
        "semi": [
            "error",
            "always"
        ]
    }
};



---
File: /@zk-email/helpers/node_modules/circom_runtime/calcwit.js
---

#!/usr/bin/env node
/*

Copyright 2020 0KIMS association.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

import fs from "fs";
const pkg = JSON.parse(fs.readFileSync("./package.json"));
const version = pkg.version;

import WitnessCalculatorBuilder from "./js/witness_calculator.js";
import { utils } from "ffjavascript";
import yargs from "yargs";



const argv = yargs
    .version(version)
    .usage("calcwit -w [wasm file] -i [input file JSON] -o [output ouput file file  .json|.bin]")
    .alias("o", "output")
    .alias("i", "input")
    .alias("w", "wasm")
    .help("h")
    .alias("h", "help")
    .epilogue(`Copyright (C) 2018  0kims association
    This program comes with ABSOLUTELY NO WARRANTY;
    This is free software, and you are welcome to redistribute it
    under certain conditions; see the COPYING file in the official
    repo directory at  https://github.com/iden3/circom `)
    .argv;

const inputFileName = typeof(argv.input) === "string" ?  argv.input : "input.json";
const outputFileName = typeof(argv.output) === "string" ?  argv.output : "witness.bin";
const wasmFileName = typeof(argv.wasm) === "string" ?  argv.wasm : "circuit.wasm";


async function run() {


    const input = utils.unstringifyBigInts(JSON.parse(await fs.promises.readFile(inputFileName, "utf8")));
    const wasm = await fs.promises.readFile(wasmFileName);

    const wc = await WitnessCalculatorBuilder(wasm);

    const outputExtension = outputFileName.split(".").pop();

    if (outputExtension === "json") {
        const w = await wc.calculateWitness(input);

        await fs.promises.writeFile(outputFileName, JSON.stringify(utils.stringifyBigInts(w), null, 1));

    } else {
        const w = await wc.calculateBinWitness(input);

        var wstream = fs.createWriteStream(outputFileName);

        wstream.write(Buffer.from(w));
        wstream.end();
        await new Promise(fulfill => wstream.on("finish", fulfill));
    }


}


run();



---
File: /@zk-email/helpers/node_modules/circom_runtime/main.js
---

export { default as WitnessCalculatorBuilder } from "./js/witness_calculator.js";



---
File: /@zk-email/helpers/node_modules/circom_runtime/rollup.cjs.config.js
---

import fs from "fs";
import { builtinModules as builtin } from "module";

const pkg = JSON.parse(fs.readFileSync("./package.json"));

export default {
    input: "main.js",
    output: {
        file: "build/main.cjs",
        format: "cjs",
    },
    external: [
        ...Object.keys(pkg.dependencies),
        ...builtin,
    ]
};




---
File: /@zk-email/helpers/node_modules/ffjavascript/src/bigbuffer.js
---


const PAGE_SIZE = 1<<30;

export default class BigBuffer {

    constructor(size) {
        this.buffers = [];
        this.byteLength = size;
        for (let i=0; i<size; i+= PAGE_SIZE) {
            const n = Math.min(size-i, PAGE_SIZE);
            this.buffers.push(new Uint8Array(n));
        }

    }

    slice(fr, to) {
        if ( to === undefined ) to = this.byteLength;
        if ( fr === undefined ) fr = 0;
        const len = to-fr;

        const firstPage = Math.floor(fr / PAGE_SIZE);
        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);

        if ((firstPage == lastPage)||(len==0))
            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);

        let buff;

        let p = firstPage;
        let o = fr % PAGE_SIZE;
        // Remaining bytes to read
        let r = len;
        while (r>0) {
            // bytes to copy from this page
            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;
            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);
            if (l == len) return srcView.slice();
            if (!buff) {
                if (len <= PAGE_SIZE) {
                    buff = new Uint8Array(len);
                } else {
                    buff = new BigBuffer(len);
                }
            }
            buff.set(srcView, len-r);
            r = r-l;
            p ++;
            o = 0;
        }

        return buff;
    }

    set(buff, offset) {
        if (offset === undefined) offset = 0;

        const len = buff.byteLength;

        if (len==0) return;

        const firstPage = Math.floor(offset / PAGE_SIZE);
        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);

        if (firstPage == lastPage) {
            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {
                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);
            } else {
                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);
            }

        }


        let p = firstPage;
        let o = offset % PAGE_SIZE;
        let r = len;
        while (r>0) {
            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;
            const srcView = buff.slice( len -r, len -r+l);
            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);
            dstView.set(srcView);
            r = r-l;
            p ++;
            o = 0;
        }

    }
}



---
File: /@zk-email/helpers/node_modules/ffjavascript/src/bls12381.js
---

import { buildBls12381 as buildBls12381wasm } from "wasmcurves";
import buildEngine from "./engine.js";
import * as Scalar from "./scalar.js";
import { ModuleBuilder } from "wasmbuilder";

globalThis.curve_bls12381 = null;

export default async function buildBls12381(singleThread, plugins) {

    const moduleBuilder = new ModuleBuilder();
    moduleBuilder.setMemory(25);
    buildBls12381wasm(moduleBuilder);

    if (plugins) plugins(moduleBuilder);

    const bls12381wasm = {};

    bls12381wasm.code = moduleBuilder.build();
    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;
    bls12381wasm.pr = moduleBuilder.modules.frm.pq;
    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;
    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;
    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;
    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;
    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;
    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;
    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;
    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;
    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;
    bls12381wasm.n8q = 48;
    bls12381wasm.n8r = 32;
    bls12381wasm.q = moduleBuilder.modules.bls12381.q;
    bls12381wasm.r = moduleBuilder.modules.bls12381.r;


    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;
    const params = {
        name: "bls12381",
        wasm: bls12381wasm,
        q: Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16),
        r: Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16),
        n8q: 48,
        n8r: 32,
        cofactorG1: Scalar.e("0x396c8c005555e1568c00aaab0000aaab", 16),
        cofactorG2: Scalar.e("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5", 16),
        singleThread: singleThread ? true : false
    };

    const curve = await buildEngine(params);
    curve.terminate = async function () {
        if (!params.singleThread) {
            globalThis.curve_bls12381 = null;
            await this.tm.terminate();
        }
    };

    if (!singleThread) {
        globalThis.curve_bls12381 = curve;
    }

    return curve;
}




---
File: /@zk-email/helpers/node_modules/ffjavascript/src/bn128.js
---

import { buildBn128 as buildBn128wasm } from "wasmcurves";
import buildEngine from "./engine.js";
import * as Scalar from "./scalar.js";
import { ModuleBuilder } from "wasmbuilder";

globalThis.curve_bn128 = null;

export default async function buildBn128(singleThread, plugins) {

    const moduleBuilder = new ModuleBuilder();
    moduleBuilder.setMemory(25);
    buildBn128wasm(moduleBuilder);

    if (plugins) plugins(moduleBuilder);

    const bn128wasm = {};

    bn128wasm.code = moduleBuilder.build();
    bn128wasm.pq = moduleBuilder.modules.f1m.pq;
    bn128wasm.pr = moduleBuilder.modules.frm.pq;
    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;
    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;
    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;
    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;
    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;
    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;
    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;
    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;
    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;
    bn128wasm.n8q = 32;
    bn128wasm.n8r = 32;
    bn128wasm.q = moduleBuilder.modules.bn128.q;
    bn128wasm.r = moduleBuilder.modules.bn128.r;

    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;
    const params = {
        name: "bn128",
        wasm: bn128wasm,
        q: Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583"),
        r: Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),
        n8q: 32,
        n8r: 32,
        cofactorG2: Scalar.e("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d", 16),
        singleThread: singleThread ? true : false
    };

    const curve = await buildEngine(params);
    curve.terminate = async function () {
        if (!params.singleThread) {
            globalThis.curve_bn128 = null;
            await this.tm.terminate();
        }
    };

    if (!singleThread) {
        globalThis.curve_bn128 = curve;
    }

    return curve;
}




---
File: /@zk-email/helpers/node_modules/ffjavascript/src/chacha.js
---



import * as Scalar from "./scalar.js";


function quarterRound(st, a, b, c, d) {

    st[a] = (st[a] + st[b]) >>> 0;
    st[d] = (st[d] ^ st[a]) >>> 0;
    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;

    st[c] = (st[c] + st[d]) >>> 0;
    st[b] = (st[b] ^ st[c]) >>> 0;
    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;

    st[a] = (st[a] + st[b]) >>> 0;
    st[d] = (st[d] ^ st[a]) >>> 0;
    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;

    st[c] = (st[c] + st[d]) >>> 0;
    st[b] = (st[b] ^ st[c]) >>> 0;
    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;
}

function doubleRound(st) {
    quarterRound(st, 0, 4, 8,12);
    quarterRound(st, 1, 5, 9,13);
    quarterRound(st, 2, 6,10,14);
    quarterRound(st, 3, 7,11,15);

    quarterRound(st, 0, 5,10,15);
    quarterRound(st, 1, 6,11,12);
    quarterRound(st, 2, 7, 8,13);
    quarterRound(st, 3, 4, 9,14);
}

export default class ChaCha {

    constructor(seed) {
        seed = seed || [0,0,0,0,0,0,0,0];
        this.state = [
            0x61707865,
            0x3320646E,
            0x79622D32,
            0x6B206574,
            seed[0],
            seed[1],
            seed[2],
            seed[3],
            seed[4],
            seed[5],
            seed[6],
            seed[7],
            0,
            0,
            0,
            0
        ];
        this.idx = 16;
        this.buff = new Array(16);
    }

    nextU32() {
        if (this.idx == 16) this.update();
        return this.buff[this.idx++];
    }

    nextU64() {
        return Scalar.add(Scalar.mul(this.nextU32(), 0x100000000), this.nextU32());
    }

    nextBool() {
        return (this.nextU32() & 1) == 1;
    }

    update() {
        // Copy the state
        for (let i=0; i<16; i++) this.buff[i] = this.state[i];

        // Apply the rounds
        for (let i=0; i<10; i++) doubleRound(this.buff);

        // Add to the initial
        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;

        this.idx = 0;

        this.state[12] = (this.state[12] + 1) >>> 0;
        if (this.state[12] != 0) return;
        this.state[13] = (this.state[13] + 1) >>> 0;
        if (this.state[13] != 0) return;
        this.state[14] = (this.state[14] + 1) >>> 0;
        if (this.state[14] != 0) return;
        this.state[15] = (this.state[15] + 1) >>> 0;
    }
}



---
File: /@zk-email/helpers/node_modules/ffjavascript/src/curves.js
---

import * as Scalar from "./scalar.js";
import {default as buildBn128} from "./bn128.js";
import {default as buildBls12381} from "./bls12381.js";

const bls12381r = Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
const bn128r = Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");

const bls12381q = Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
const bn128q = Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");

export async function getCurveFromR(r, singleThread, plugins) {
    let curve;
    if (Scalar.eq(r, bn128r)) {
        curve = await buildBn128(singleThread, plugins);
    } else if (Scalar.eq(r, bls12381r)) {
        curve = await buildBls12381(singleThread, plugins);
    } else {
        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);
    }
    return curve;
}

export async function getCurveFromQ(q, singleThread, plugins) {
    let curve;
    if (Scalar.eq(q, bn128q)) {
        curve = await buildBn128(singleThread, plugins);
    } else if (Scalar.eq(q, bls12381q)) {
        curve = await buildBls12381(singleThread, plugins);
    } else {
        throw new Error(`Curve not supported: ${Scalar.toString(q, 16)}`);
    }
    return curve;
}

export async function getCurveFromName(name, singleThread, plugins) {
    let curve;
    const normName = normalizeName(name);
    if (["BN128", "BN254", "ALTBN128"].indexOf(normName) >= 0) {
        curve = await buildBn128(singleThread, plugins);
    } else if (["BLS12381"].indexOf(normName) >= 0) {
        curve = await buildBls12381(singleThread, plugins);
    } else {
        throw new Error(`Curve not supported: ${name}`);
    }
    return curve;

    function normalizeName(n) {
        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join("");
    }

}



---
File: /@zk-email/helpers/node_modules/ffjavascript/src/ec.js
---

/*
    Copyright 2018 0kims association.

    This file is part of snarkjs.

    snarkjs is a free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    snarkjs is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along with
    snarkjs. If not, see <https://www.gnu.org/licenses/>.
*/



import * as fUtils from "./futils.js";
import * as Scalar from "./scalar.js";


function isGreatest(F, a) {
    if (Array.isArray(a)) {
        for (let i=a.length-1; i>=0; i--) {
            if (!F.F.isZero(a[i])) {
                return isGreatest(F.F, a[i]);
            }
        }
        return 0;
    } else {
        const na = F.neg(a);
        return Scalar.gt(a, na);
    }
}


export default class EC {

    constructor(F, g) {
        this.F = F;
        this.g = g;
        if (this.g.length == 2) this.g[2] = this.F.one;
        this.zero = [this.F.zero, this.F.one, this.F.zero];
    }

    add(p1, p2) {

        const F = this.F;

        if (this.eq(p1, this.zero)) return p2;
        if (this.eq(p2, this.zero)) return p1;

        const res = new Array(3);

        const Z1Z1 = F.square( p1[2] );
        const Z2Z2 = F.square( p2[2] );

        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2
        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1

        const Z1_cubed = F.mul( p1[2] , Z1Z1);
        const Z2_cubed = F.mul( p2[2] , Z2Z2);

        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2
        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1

        if (F.eq(U1,U2) && F.eq(S1,S2)) {
            return this.double(p1);
        }

        const H = F.sub( U2 , U1 );                    // H = U2-U1

        const S2_minus_S1 = F.sub( S2 , S1 );

        const I = F.square( F.add(H,H) );         // I = (2 * H)^2
        const J = F.mul( H , I );                      // J = H * I

        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)
        const V = F.mul( U1 , I );                     // V = U1 * I

        res[0] =
            F.sub(
                F.sub( F.square(r) , J ),
                F.add( V , V ));                       // X3 = r^2 - J - 2 * V

        const S1_J = F.mul( S1 , J );

        res[1] =
            F.sub(
                F.mul( r , F.sub(V,res[0])),
                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J

        res[2] =
            F.mul(
                H,
                F.sub(
                    F.square( F.add(p1[2],p2[2]) ),
                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H

        return res;
    }

    neg(p) {
        return [p[0], this.F.neg(p[1]), p[2]];
    }

    sub(a, b) {
        return this.add(a, this.neg(b));
    }

    double(p) {
        const F = this.F;

        const res = new Array(3);

        if (this.eq(p, this.zero)) return p;

        const A = F.square( p[0] );                    // A = X1^2
        const B = F.square( p[1] );                    // B = Y1^2
        const C = F.square( B );                       // C = B^2

        let D =
            F.sub(
                F.square( F.add(p[0] , B )),
